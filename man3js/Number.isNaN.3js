.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Number.isNaN" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Number.isNaN - Number.isNaN()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]Number.isNaN()\f[B]\f[R] static method determines whether
the passed value is the number value \f[V]NaN\f[R], and returns
\f[V]false\f[R] if the input is not of the Number type.
It is a more robust version of the original, global \f[V]isNaN()\f[R]
function.
.SH SYNTAX
.IP
.nf
\f[C]
Number.isNaN(value)
\f[R]
.fi
.SS Parameters
.TP
\f[B]value\f[R]
The value to be tested for \f[V]NaN\f[R].
.SS Return value
.PP
The boolean value \f[V]true\f[R] if the given value is a number with
value \f[V]NaN\f[R].
Otherwise, \f[V]false\f[R].
.SH DESCRIPTION
.PP
The function \f[V]Number.isNaN()\f[R] provides a convenient way to check
for equality with \f[V]NaN\f[R].
Note that you cannot test for equality with \f[V]NaN\f[R] using either
the \f[V]==\f[R] or \f[V]===\f[R] operators, because unlike all other
value comparisons in JavaScript, these evaluate to \f[V]false\f[R]
whenever one operand is \f[V]NaN\f[R], even if the other operand is also
\f[V]NaN\f[R].
.PP
Since \f[V]x !== x\f[R] is only true for \f[V]NaN\f[R] among all
possible JavaScript values, \f[V]Number.isNaN(x)\f[R] can also be
replaced with a test for \f[V]x !== x\f[R], despite the latter being
less readable.
.PP
As opposed to the global \f[V]isNaN()\f[R] function, the
\f[V]Number.isNaN()\f[R] method doesn\[cq]t force-convert the parameter
to a number.
This makes it safe to pass values that would normally convert to
\f[V]NaN\f[R] but aren\[cq]t actually the same value as \f[V]NaN\f[R].
This also means that only values of the Number type that are also
\f[V]NaN\f[R] return \f[V]true\f[R].
.SH EXAMPLES
.SS Using isNaN()
.IP
.nf
\f[C]
Number.isNaN(NaN); // true
Number.isNaN(Number.NaN); // true
Number.isNaN(0 / 0); // true
Number.isNaN(37); // false
\f[R]
.fi
.SS Difference between Number.isNaN() and global isNaN()
.PP
\f[V]Number.isNaN()\f[R] doesn\[cq]t attempt to convert the parameter to
a number, so non-numbers always return \f[V]false\f[R].
The following are all \f[V]false\f[R]:
.IP
.nf
\f[C]
Number.isNaN(\[dq]NaN\[dq]);
Number.isNaN(undefined);
Number.isNaN({});
Number.isNaN(\[dq]blabla\[dq]);
Number.isNaN(true);
Number.isNaN(null);
Number.isNaN(\[dq]37\[dq]);
Number.isNaN(\[dq]37.37\[dq]);
Number.isNaN(\[dq]\[dq]);
Number.isNaN(\[dq] \[dq]);
\f[R]
.fi
.PP
The global \f[V]isNaN()\f[R] coerces its parameter to a number:
.IP
.nf
\f[C]
isNaN(\[dq]NaN\[dq]); // true
isNaN(undefined); // true
isNaN({}); // true
isNaN(\[dq]blabla\[dq]); // true
isNaN(true); // false, this is coerced to 1
isNaN(null); // false, this is coerced to 0
isNaN(\[dq]37\[dq]); // false, this is coerced to 37
isNaN(\[dq]37.37\[dq]); // false, this is coerced to 37.37
isNaN(\[dq]\[dq]); // false, this is coerced to 0
isNaN(\[dq] \[dq]); // false, this is coerced to 0
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]Number.isNaN\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-number)
.IP \[bu] 2
\f[V]Number\f[R]
.IP \[bu] 2
\f[V]isNaN()\f[R]
