.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "parseFloat" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]parseFloat()\f[B]\f[R] function parses a string argument
and returns a floating point number.
.SH Syntax
.IP
.nf
\f[C]
parseFloat(string)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]string\f[R]
.RS 2
.IP \[bu] 2
The value to parse, coerced to a string.
Leading whitespace in this argument is ignored.
.RE
.SS Return value
.PP
A floating point number parsed from the given \f[V]string\f[R], or
\f[V]NaN\f[R] when the first non-whitespace character cannot be
converted to a number.
.RS
.PP
\f[B]Note:\f[R] JavaScript does not have the distinction of
\[lq]floating point numbers\[rq] and \[lq]integers\[rq] on the language
level.
\f[V]parseInt()\f[R] and \f[V]parseFloat()\f[R] only differ in their
parsing behavior, but not necessarily their return values.
For example, \f[V]parseInt(\[dq]42\[dq])\f[R] and
\f[V]parseFloat(\[dq]42\[dq])\f[R] would return the same value: a
\f[V]Number\f[R] 42.
.RE
.SH Description
.PP
The \f[V]parseFloat\f[R] function converts its first argument to a
string, parses that string as a decimal number literal, then returns a
number or \f[V]NaN\f[R].
The number syntax it accepts can be summarized as:
.IP \[bu] 2
The characters accepted by \f[V]parseFloat()\f[R] are plus sign
(\f[V]+\f[R]), minus sign (\f[V]-\f[R] U+002D HYPHEN-MINUS), decimal
digits (\f[V]0\f[R] \[en] \f[V]9\f[R]), decimal point (\f[V].\f[R]),
exponent indicator (\f[V]e\f[R] or \f[V]E\f[R]), and the
\f[V]\[dq]Infinity\[dq]\f[R] literal.
.IP \[bu] 2
The \f[V]+\f[R]/\f[V]-\f[R] signs can only appear strictly at the
beginning of the string, or immediately following the
\f[V]e\f[R]/\f[V]E\f[R] character.
The decimal point can only appear once, and only before the
\f[V]e\f[R]/\f[V]E\f[R] character.
The \f[V]e\f[R]/\f[V]E\f[R] character can only appear once, and only if
there is at least one digit before it.
.IP \[bu] 2
Leading spaces in the argument are trimmed and ignored.
.IP \[bu] 2
\f[V]parseFloat()\f[R] can also parse and return \f[V]Infinity\f[R] or
\f[V]-Infinity\f[R] if the string starts with
\f[V]\[dq]Infinity\[dq]\f[R] or \f[V]\[dq]-Infinity\[dq]\f[R] preceded
by none or more white spaces.
.IP \[bu] 2
\f[V]parseFloat()\f[R] picks the longest substring starting from the
beginning that generates a valid number literal.
If it encounters an invalid character, it returns the number represented
up to that point, ignoring the invalid character and all characters
following it.
.IP \[bu] 2
If the argument\[cq]s first character can\[cq]t start a legal number
literal per the syntax above, \f[V]parseFloat\f[R] returns
\f[V]NaN\f[R].
.PP
Syntax-wise, \f[V]parseFloat()\f[R] parses a subset of the syntax that
the \f[V]Number()\f[R] function accepts.
Namely, \f[V]parseFloat()\f[R] does not support non-decimal literals
with \f[V]0x\f[R], \f[V]0b\f[R], or \f[V]0o\f[R] prefixes but supports
everything else.
However, \f[V]parseFloat()\f[R] is more lenient than \f[V]Number()\f[R]
because it ignores trailing invalid characters, which would cause
\f[V]Number()\f[R] to return \f[V]NaN\f[R].
.PP
Similar to number literals and \f[V]Number()\f[R], the number returned
from \f[V]parseFloat()\f[R] may not be exactly equal to the number
represented by the string, due to floating point range and inaccuracy.
For numbers outside the \f[V]-1.7976931348623158e+308\f[R] \[en]
\f[V]1.7976931348623158e+308\f[R] range (see
\f[V]Number.MAX_VALUE\f[R]), \f[V]-Infinity\f[R] or \f[V]Infinity\f[R]
is returned.
.SH Examples
.SS Using parseFloat()
.PP
The following examples all return \f[V]3.14\f[R]:
.IP
.nf
\f[C]
parseFloat(3.14);
parseFloat(\[dq]3.14\[dq]);
parseFloat(\[dq]  3.14  \[dq]);
parseFloat(\[dq]314e-2\[dq]);
parseFloat(\[dq]0.0314E+2\[dq]);
parseFloat(\[dq]3.14some non-digit characters\[dq]);
parseFloat({
  toString() {
    return \[dq]3.14\[dq];
  },
});
\f[R]
.fi
.SS parseFloat() returning NaN
.PP
The following example returns \f[V]NaN\f[R]:
.IP
.nf
\f[C]
parseFloat(\[dq]FF2\[dq]);
\f[R]
.fi
.PP
Anecdotally, because the string \f[V]NaN\f[R] itself is invalid syntax
as accepted by \f[V]parseFloat()\f[R], passing \f[V]\[dq]NaN\[dq]\f[R]
returns \f[V]NaN\f[R] as well.
.IP
.nf
\f[C]
parseFloat(\[dq]NaN\[dq]); // NaN
\f[R]
.fi
.SS Returning Infinity
.PP
Infinity values are returned when the number is outside the
double-precision 64-bit IEEE 754-2019 format range:
.IP
.nf
\f[C]
parseFloat(\[dq]1.7976931348623159e+308\[dq]); // Infinity
parseFloat(\[dq]-1.7976931348623159e+308\[dq]); // -Infinity
\f[R]
.fi
.PP
Infinity is also returned when the string starts with
\f[V]\[dq]Infinity\[dq]\f[R] or \f[V]\[dq]-Infinity\[dq]\f[R]:
.IP
.nf
\f[C]
parseFloat(\[dq]Infinity\[dq]); // Infinity
parseFloat(\[dq]-Infinity\[dq]); // -Infinity
\f[R]
.fi
.SS Interaction with BigInt values
.PP
\f[V]parseFloat()\f[R] does not handle \f[V]BigInt\f[R] values.
It stops at the \f[V]n\f[R] character, and treats the preceding string
as a normal integer, with possible loss of precision.
If a BigInt value is passed to \f[V]parseFloat()\f[R], it will be
converted to a string, and the string will be parsed as a floating-point
number, which may result in loss of precision as well.
.PP
\f[B]Bad\f[R]
.IP
.nf
\f[C]
parseFloat(900719925474099267n); // 900719925474099300
parseFloat(\[dq]900719925474099267n\[dq]); // 900719925474099300
\f[R]
.fi
.PP
You should pass the string to the \f[V]BigInt()\f[R] function instead,
without the trailing \f[V]n\f[R] character.
.PP
\f[B]Good\f[R]
.IP
.nf
\f[C]
BigInt(\[dq]900719925474099267\[dq]);
// 900719925474099267n
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]parseInt()\f[R]
.IP \[bu] 2
\f[V]Number.parseFloat()\f[R]
.IP \[bu] 2
\f[V]Number.parseInt()\f[R]
.IP \[bu] 2
\f[V]Number.prototype.toFixed()\f[R]
