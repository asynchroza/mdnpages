.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Math.round" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]Math.round()\f[B]\f[R] static method returns the value of
a number rounded to the nearest integer.
.SH Syntax
.IP
.nf
\f[C]
Math.round(x)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]x\f[R]
.RS 2
.IP \[bu] 2
A number.
.RE
.SS Return value
.PP
The value of \f[V]x\f[R] rounded to the nearest integer.
.SH Description
.PP
If the fractional portion of the argument is greater than 0.5, the
argument is rounded to the integer with the next higher absolute value.
If it is less than 0.5, the argument is rounded to the integer with the
lower absolute value.
If the fractional portion is exactly 0.5, the argument is rounded to the
next integer in the direction of +∞.
.RS
.PP
\f[B]Note:\f[R] This differs from many languages\[cq] \f[V]round()\f[R]
functions, which often round half-increments \f[I]away from zero\f[R],
giving a different result in the case of negative numbers with a
fractional part of exactly 0.5.
.RE
.PP
\f[V]Math.round(x)\f[R] is not exactly the same as
\f[V]Math.floor(x + 0.5)\f[R].
When \f[V]x\f[R] is -0, or -0.5 ≤ x < 0, \f[V]Math.round(x)\f[R] returns
-0, while \f[V]Math.floor(x + 0.5)\f[R] returns 0.
However, neglecting that difference and potential precision errors,
\f[V]Math.round(x)\f[R] and \f[V]Math.floor(x + 0.5)\f[R] are generally
equivalent.
.PP
Because \f[V]round()\f[R] is a static method of \f[V]Math\f[R], you
always use it as \f[V]Math.round()\f[R], rather than as a method of a
\f[V]Math\f[R] object you created (\f[V]Math\f[R] has no constructor).
.SH Examples
.SS Using round
.IP
.nf
\f[C]
Math.round(-Infinity); // -Infinity
Math.round(-20.51); // -21
Math.round(-20.5); // -20
Math.round(-0.1); // -0
Math.round(0); // 0
Math.round(20.49); // 20
Math.round(20.5); // 21
Math.round(42); // 42
Math.round(Infinity); // Infinity
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]Number.prototype.toPrecision()\f[R]
.IP \[bu] 2
\f[V]Number.prototype.toFixed()\f[R]
.IP \[bu] 2
\f[V]Math.abs()\f[R]
.IP \[bu] 2
\f[V]Math.ceil()\f[R]
.IP \[bu] 2
\f[V]Math.floor()\f[R]
.IP \[bu] 2
\f[V]Math.sign()\f[R]
.IP \[bu] 2
\f[V]Math.trunc()\f[R]
