.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "String.raw" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]String.raw()\f[B]\f[R] static method is a tag function of
template literals.
This is similar to the \f[V]r\f[R] prefix in Python, or the
\f[V]\[at]\f[R] prefix in C# for string literals.
It\[cq]s used to get the raw string form of template literals \[em] that
is, substitutions (e.g.\ \f[V]${foo}\f[R]) are processed, but escape
sequences (e.g.\ \f[V]\[rs]n\f[R]) are not.
.SH Syntax
.IP
.nf
\f[C]
String.raw(strings, ...substitutions)

String.raw\[ga]templateString\[ga]
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]strings\f[R]
.RS 2
.IP \[bu] 2
Well-formed template literal array object, like
\f[V]{ raw: [\[aq]foo\[aq], \[aq]bar\[aq], \[aq]baz\[aq]] }\f[R].
Should be an object with a \f[V]raw\f[R] property whose value is an
array-like object of strings.
.RE
.IP \[bu] 2
\f[V]...substitutions\f[R]
.RS 2
.IP \[bu] 2
Contains substitution values.
.RE
.IP \[bu] 2
\f[V]templateString\f[R]
.RS 2
.IP \[bu] 2
A template literal, optionally with substitutions (\f[V]${...}\f[R]).
.RE
.SS Return value
.PP
The raw string form of a given template literal.
.SS Exceptions
.IP \[bu] 2
\f[V]TypeError\f[R]
.RS 2
.IP \[bu] 2
Thrown if the first argument doesn\[cq]t have a \f[V]raw\f[R] property,
or the \f[V]raw\f[R] property is \f[V]undefined\f[R] or \f[V]null\f[R].
.RE
.SH Description
.PP
In most cases, \f[V]String.raw()\f[R] is used with template literals.
The first syntax mentioned above is only rarely used, because the
JavaScript engine will call this with proper arguments for you, (just
like with other tag functions).
.PP
\f[V]String.raw()\f[R] is the only built-in template literal tag.
It has close semantics to an untagged literal since it concatenates all
arguments and returns a string.
You can even re-implement it with normal JavaScript code.
.RS
.PP
\f[B]Warning:\f[R] You should not use \f[V]String.raw\f[R] directly as
an \[lq]identity\[rq] tag.
See Building an identity tag for how to implement this.
.RE
.PP
If \f[V]String.raw()\f[R] is called with an object whose \f[V]raw\f[R]
property doesn\[cq]t have a \f[V]length\f[R] property or a non-positive
\f[V]length\f[R], it returns an empty string \f[V]\[dq]\[dq]\f[R].
If \f[V]substitutions.length < strings.raw.length - 1\f[R] (i.e.\ there
are not enough substitutions to fill the placeholders \[em] which
can\[cq]t happen in a well-formed tagged template literal), the rest of
the placeholders are filled with empty strings.
.SH Examples
.SS Using String.raw()
.IP
.nf
\f[C]
String.raw\[ga]Hi\[rs]n${2 + 3}!\[ga];
// \[aq]Hi\[rs]\[rs]n5!\[aq], the character after \[aq]Hi\[aq]
// is not a newline character,
// \[aq]\[rs]\[aq] and \[aq]n\[aq] are two characters.

String.raw\[ga]Hi\[rs]u000A!\[ga];
// \[aq]Hi\[rs]\[rs]u000A!\[aq], same here, this time we will get the
// \[rs], u, 0, 0, 0, A, 6 characters.
// All kinds of escape characters will be ineffective
// and backslashes will be present in the output string.
// You can confirm this by checking the .length property
// of the string.

const name = \[dq]Bob\[dq];
String.raw\[ga]Hi\[rs]n${name}!\[ga];
// \[aq]Hi\[rs]\[rs]nBob!\[aq], substitutions are processed.

String.raw\[ga]Hi \[rs]${name}!\[ga];
// \[aq]Hi \[rs]\[rs]${name}!\[aq], the dollar sign is escaped; there\[aq]s no interpolation.
\f[R]
.fi
.SS Building an identity tag
.PP
Many tools give special treatment to literals tagged by a particular
name.
.IP
.nf
\f[C]
// Some formatters will format this literal\[aq]s content as HTML
const doc = html\[ga]<!DOCTYPE html>
<html lang=\[dq]en-US\[dq]>
  <head>
    <title>Hello</title>
  </head>
  <body>
    <h1>Hello world!</h1>
  </body>
</html>
\[ga];
\f[R]
.fi
.PP
One might na√Øvely implement the \f[V]html\f[R] tag as:
.IP
.nf
\f[C]
const html = String.raw;
\f[R]
.fi
.PP
This, in fact, works for the case above.
However, because \f[V]String.raw\f[R] would concatenate the
\f[I]raw\f[R] string literals instead of the \[lq]cooked\[rq] ones,
escape sequences would not be processed.
.IP
.nf
\f[C]
const doc = html\[ga]<canvas>\[rs]n</canvas>\[ga];
// \[dq]<canvas>\[rs]\[rs]n</canvas>\[dq]
\f[R]
.fi
.PP
This may not be what you want for a \[lq]true identity\[rq] tag, where
the tag is purely for markup and doesn\[cq]t change the literal\[cq]s
value.
In this case, you can create a custom tag and pass the \[lq]cooked\[rq]
(i.e.\ escape sequences are processed) literal array to
\f[V]String.raw\f[R], pretending they are raw strings.
.IP
.nf
\f[C]
const html = (strings, ...values) => String.raw({ raw: strings }, ...values);
// Some formatters will format this literal\[aq]s content as HTML
const doc = html\[ga]<canvas>\[rs]n</canvas>\[ga];
// \[dq]<canvas>\[rs]n</canvas>\[dq]; the \[dq]\[rs]n\[dq] becomes a line break
\f[R]
.fi
.PP
Notice the first argument is an object with a \f[V]raw\f[R] property,
whose value is an array-like object (with a \f[V]length\f[R] property
and integer indexes) representing the separated strings in the template
literal.
The rest of the arguments are the substitutions.
Since the \f[V]raw\f[R] value can be any array-like object, it can even
be a string!
For example, \f[V]\[aq]test\[aq]\f[R] is treated as
\f[V][\[aq]t\[aq], \[aq]e\[aq], \[aq]s\[aq], \[aq]t\[aq]]\f[R].
The following is equivalent to \f[V]\[ga]t${0}e${1}s${2}t\[ga]\f[R]:
.IP
.nf
\f[C]
String.raw({ raw: \[dq]test\[dq] }, 0, 1, 2); // \[aq]t0e1s2t\[aq]
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]String.raw\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-string-and-regexp)
.IP \[bu] 2
Template literals
.IP \[bu] 2
\f[V]String\f[R]
.IP \[bu] 2
Lexical grammar
