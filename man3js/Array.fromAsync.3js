.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.fromAsync" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Array.fromAsync - Array.fromAsync()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]Array.fromAsync()\f[B]\f[R] static method creates a new,
shallow-copied \f[V]Array\f[R] instance from an async iterable,
iterable, or array-like object.
.SH SYNTAX
.IP
.nf
\f[C]
Array.fromAsync(arrayLike)
Array.fromAsync(arrayLike, mapFn)
Array.fromAsync(arrayLike, mapFn, thisArg)
\f[R]
.fi
.SS Parameters
.TP
\f[B]arrayLike\f[R]
An async iterable, iterable, or array-like object to convert to an
array.
.TP
\f[B]mapFn\f[R] \f[I](optional)\f[R]
A function to call on every element of the array.
If provided, every value to be added to the array is first passed
through this function, and \f[V]mapFn\f[R]\[cq]s return value is added
to the array instead (after being awaited).
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the array.
Because all elements are first awaited, this value will never be a
thenable.
.TP
\f[B]index\f[R]
The index of the current element being processed in the array.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
Value to use as \f[V]this\f[R] when executing \f[V]mapFn\f[R].
.SS Return value
.PP
A new \f[V]Promise\f[R] whose fulfillment value is a new \f[V]Array\f[R]
instance.
.SH DESCRIPTION
.PP
\f[V]Array.fromAsync()\f[R] lets you create arrays from:
.IP \[bu] 2
async iterable objects (objects such as \f[V]ReadableStream\f[R] and
\f[V]AsyncGenerator\f[R]); or, if the object is not async iterable,
.IP \[bu] 2
iterable objects (objects such as \f[V]Map\f[R] and \f[V]Set\f[R]); or,
if the object is not iterable,
.IP \[bu] 2
array-like objects (objects with a \f[V]length\f[R] property and indexed
elements).
.PP
\f[V]Array.fromAsync()\f[R] iterates the async iterable in a fashion
very similar to \f[V]for await...of\f[R].
\f[V]Array.fromAsync()\f[R] is almost equivalent to
\f[V]Array.from()\f[R] in terms of behavior, except the following:
.IP \[bu] 2
\f[V]Array.fromAsync()\f[R] handles async iterable objects.
.IP \[bu] 2
\f[V]Array.fromAsync()\f[R] returns a \f[V]Promise\f[R] that fulfills to
the array instance.
.IP \[bu] 2
If \f[V]Array.fromAsync()\f[R] is called with a non-async iterable
object, each element to be added to the array is first awaited.
.IP \[bu] 2
If a \f[V]mapFn\f[R] is provided, its input and output are internally
awaited.
.PP
\f[V]Array.fromAsync()\f[R] and \f[V]Promise.all()\f[R] can both turn an
iterable of promises into a promise of an array.
However, there are two key differences:
.IP \[bu] 2
\f[V]Array.fromAsync()\f[R] awaits each value yielded from the object
sequentially.
\f[V]Promise.all()\f[R] awaits all values in parallel.
.IP \[bu] 2
\f[V]Array.fromAsync()\f[R] iterates the iterable lazily, and
doesn\[cq]t retrieve the next value until the current one is settled.
\f[V]Promise.all()\f[R] retrieves all values in advance and awaits them
all.
.SH EXAMPLES
.SS Array from an async iterable
.IP
.nf
\f[C]
const asyncIterable = (async function* () {
  for (let i = 0; i < 5; i++) {
    await new Promise((resolve) => setTimeout(resolve, 10 * i));
    yield i;
  }
})();

Array.fromAsync(asyncIterable).then((array) => console.log(array));
// [0, 1, 2, 3, 4]
\f[R]
.fi
.SS Array from a sync iterable
.IP
.nf
\f[C]
Array.fromAsync(
  new Map([
    [1, 2],
    [3, 4],
  ]),
).then((array) => console.log(array));
// [[1, 2], [3, 4]]
\f[R]
.fi
.SS Array from a sync iterable that yields promises
.IP
.nf
\f[C]
Array.fromAsync(
  new Set([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]),
).then((array) => console.log(array));
// [1, 2, 3]
\f[R]
.fi
.SS Array from an array-like object of promises
.IP
.nf
\f[C]
Array.fromAsync({
  length: 3,
  0: Promise.resolve(1),
  1: Promise.resolve(2),
  2: Promise.resolve(3),
}).then((array) => console.log(array));
// [1, 2, 3]
\f[R]
.fi
.SS Using mapFn
.PP
Both the input and output of \f[V]mapFn\f[R] are awaited internally by
\f[V]Array.fromAsync()\f[R].
.IP
.nf
\f[C]
function delayedValue(v) {
  return new Promise((resolve) => setTimeout(() => resolve(v), 100));
}

Array.fromAsync(
  [delayedValue(1), delayedValue(2), delayedValue(3)],
  (element) => delayedValue(element * 2),
).then((array) => console.log(array));
// [2, 4, 6]
\f[R]
.fi
.SS Comparison with Promise.all()
.PP
\f[V]Array.fromAsync()\f[R] awaits each value yielded from the object
sequentially.
\f[V]Promise.all()\f[R] awaits all values in parallel.
.IP
.nf
\f[C]
function* makeAsyncIterable() {
  for (let i = 0; i < 5; i++) {
    yield new Promise((resolve) => setTimeout(resolve, 100));
  }
}

(async () => {
  console.time(\[dq]Array.fromAsync() time\[dq]);
  await Array.fromAsync(makeAsyncIterable());
  console.timeEnd(\[dq]Array.fromAsync() time\[dq]);
  // Array.fromAsync() time: 503.610ms

  console.time(\[dq]Promise.all() time\[dq]);
  await Promise.all(makeAsyncIterable());
  console.timeEnd(\[dq]Promise.all() time\[dq]);
  // Promise.all() time: 101.728ms
})();
\f[R]
.fi
.SS No error handling for sync iterables
.PP
Similar to \f[V]for await...of\f[R], if the object being iterated is a
sync iterable, and an error is thrown while iterating, the
\f[V]return()\f[R] method of the underlying iterator will not be called,
so the iterator is not closed.
.IP
.nf
\f[C]
function* generatorWithRejectedPromises() {
  try {
    yield 0;
    yield Promise.reject(3);
  } finally {
    console.log(\[dq]called finally\[dq]);
  }
}

(async () => {
  try {
    await Array.fromAsync(generatorWithRejectedPromises());
  } catch (e) {
    console.log(\[dq]caught\[dq], e);
  }
})();
// caught 3
// No \[dq]called finally\[dq] message
\f[R]
.fi
.PP
If you need to close the iterator, you need to use a \f[V]for...of\f[R]
loop instead, and \f[V]await\f[R] each value yourself.
.IP
.nf
\f[C]
(async () => {
  const arr = [];
  try {
    for (const val of generatorWithRejectedPromises()) {
      arr.push(await val);
    }
  } catch (e) {
    console.log(\[dq]caught\[dq], e);
  }
})();
// called finally
// caught 3
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]Array.fromAsync\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#arrayfromasync)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[V]Array\f[R]
.IP \[bu] 2
\f[V]Array()\f[R]
.IP \[bu] 2
\f[V]Array.of()\f[R]
.IP \[bu] 2
\f[V]Array.from()\f[R]
.IP \[bu] 2
\f[V]for await...of\f[R]
