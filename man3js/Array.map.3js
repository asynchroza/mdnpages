.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.map" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Array.map - Array.prototype.map()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]map()\f[B]\f[R] method \f[B]creates a new array\f[R]
populated with the results of calling a provided function on every
element in the calling array.
.SH SYNTAX
.IP
.nf
\f[C]
map(callbackFn)
map(callbackFn, thisArg)
\f[R]
.fi
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element in the array.
Its return value is added as a single element in the new array.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the array.
.TP
\f[B]index\f[R]
The index of the current element being processed in the array.
.TP
\f[B]array\f[R]
The array \f[V]map()\f[R] was called upon.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
A value to use as \f[V]this\f[R] when executing \f[V]callbackFn\f[R].
See iterative methods.
.SS Return value
.PP
A new array with each element being the result of the callback function.
.SH DESCRIPTION
.PP
The \f[V]map()\f[R] method is an iterative method.
It calls a provided \f[V]callbackFn\f[R] function once for each element
in an array and constructs a new array from the results.
.PP
\f[V]callbackFn\f[R] is invoked only for array indexes which have
assigned values.
It is not invoked for empty slots in sparse arrays.
.PP
The \f[V]map()\f[R] method is a copying method.
It does not alter \f[V]this\f[R].
However, the function provided as \f[V]callbackFn\f[R] can mutate the
array.
Note, however, that the length of the array is saved \f[I]before\f[R]
the first invocation of \f[V]callbackFn\f[R].
Therefore:
.IP \[bu] 2
\f[V]callbackFn\f[R] will not visit any elements added beyond the
array\[cq]s initial length when the call to \f[V]map()\f[R] began.
.IP \[bu] 2
Changes to already-visited indexes do not cause \f[V]callbackFn\f[R] to
be invoked on them again.
.IP \[bu] 2
If an existing, yet-unvisited element of the array is changed by
\f[V]callbackFn\f[R], its value passed to the \f[V]callbackFn\f[R] will
be the value at the time that element gets visited.
Deleted elements are not visited.
.RS
.PP
\f[B]Warning:\f[R] Concurrent modifications of the kind described above
frequently lead to hard-to-understand code and are generally to be
avoided (except in special cases).
.RE
.PP
The \f[V]map()\f[R] method is generic.
It only expects the \f[V]this\f[R] value to have a \f[V]length\f[R]
property and integer-keyed properties.
.PP
Since \f[V]map\f[R] builds a new array, calling it without using the
returned array is an anti-pattern; use \f[V]forEach\f[R] or
\f[V]for...of\f[R] instead.
.SH EXAMPLES
.SS Mapping an array of numbers to an array of square roots
.PP
The following code takes an array of numbers and creates a new array
containing the square roots of the numbers in the first array.
.IP
.nf
\f[C]
const numbers = [1, 4, 9];
const roots = numbers.map((num) => Math.sqrt(num));

// roots is now     [1, 2, 3]
// numbers is still [1, 4, 9]
\f[R]
.fi
.SS Using map to reformat objects in an array
.PP
The following code takes an array of objects and creates a new array
containing the newly reformatted objects.
.IP
.nf
\f[C]
const kvArray = [
  { key: 1, value: 10 },
  { key: 2, value: 20 },
  { key: 3, value: 30 },
];

const reformattedArray = kvArray.map(({ key, value }) => ({ [key]: value }));

console.log(reformattedArray); // [{ 1: 10 }, { 2: 20 }, { 3: 30 }]
console.log(kvArray);
// [
//   { key: 1, value: 10 },
//   { key: 2, value: 20 },
//   { key: 3, value: 30 }
// ]
\f[R]
.fi
.SS Mapping an array of numbers using a function containing an argument
.PP
The following code shows how \f[V]map\f[R] works when a function
requiring one argument is used with it.
The argument will automatically be assigned from each element of the
array as \f[V]map\f[R] loops through the original array.
.IP
.nf
\f[C]
const numbers = [1, 4, 9];
const doubles = numbers.map((num) => num * 2);

console.log(doubles); // [2, 8, 18]
console.log(numbers); // [1, 4, 9]
\f[R]
.fi
.SS Calling map() on non-array objects
.PP
The \f[V]map()\f[R] method reads the \f[V]length\f[R] property of
\f[V]this\f[R] and then accesses each integer index.
.IP
.nf
\f[C]
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.map.call(arrayLike, (x) => x ** 2));
// [ 4, 9, 16 ]
\f[R]
.fi
.SS Using map() generically on a NodeList
.PP
This example shows how to iterate through a collection of objects
collected by \f[V]querySelectorAll\f[R].
This is because \f[V]querySelectorAll\f[R] returns a \f[V]NodeList\f[R]
(which is a collection of objects).
.PP
In this case, we return all the selected \f[V]option\f[R]s\[cq] values
on the screen:
.IP
.nf
\f[C]
const elems = document.querySelectorAll(\[dq]select option:checked\[dq]);
const values = Array.prototype.map.call(elems, ({ value }) => value);
\f[R]
.fi
.PP
An easier way would be the \f[V]Array.from()\f[R] method.
.SS Using map() on sparse arrays
.PP
A sparse array remains sparse after \f[V]map()\f[R].
The indices of empty slots are still empty in the returned array, and
the callback function won\[cq]t be called on them.
.IP
.nf
\f[C]
console.log(
  [1, , 3].map((x, index) => {
    console.log(\[ga]Visit ${index}\[ga]);
    return x * 2;
  }),
);
// Visit 0
// Visit 2
// [2, empty, 6]
\f[R]
.fi
.SS Using parseInt() with map()
.PP
(inspired by this blog post (https://wirfs-brock.com/allen/posts/166))
.PP
It is common to use the callback with one argument (the element being
traversed).
Certain functions are also commonly used with one argument, even though
they take additional optional arguments.
These habits may lead to confusing behaviors.
.PP
Consider:
.IP
.nf
\f[C]
[\[dq]1\[dq], \[dq]2\[dq], \[dq]3\[dq]].map(parseInt);
\f[R]
.fi
.PP
While one might expect \f[V][1, 2, 3]\f[R], the actual result is
\f[V][1, NaN, NaN]\f[R].
.PP
\f[V]parseInt\f[R] is often used with one argument, but takes two.
The first is an expression and the second is the radix to the callback
function, \f[V]Array.prototype.map\f[R] passes 3 arguments:
.IP \[bu] 2
the element
.IP \[bu] 2
the index
.IP \[bu] 2
the array
.PP
The third argument is ignored by \f[V]parseInt\f[R]\[em]but
\f[I]not\f[R] the second one!
This is the source of possible confusion.
.PP
Here is a concise example of the iteration steps:
.IP
.nf
\f[C]
// parseInt(string, radix) -> map(parseInt(value, index))
/* first iteration  (index is 0): */ parseInt(\[dq]1\[dq], 0); // 1
/* second iteration (index is 1): */ parseInt(\[dq]2\[dq], 1); // NaN
/* third iteration  (index is 2): */ parseInt(\[dq]3\[dq], 2); // NaN
\f[R]
.fi
.PP
Then let\[cq]s talk about solutions.
.IP
.nf
\f[C]
const returnInt = (element) => parseInt(element, 10);

[\[dq]1\[dq], \[dq]2\[dq], \[dq]3\[dq]].map(returnInt); // [1, 2, 3]
// Actual result is an array of numbers (as expected)

// Same as above, but using the concise arrow function syntax
[\[dq]1\[dq], \[dq]2\[dq], \[dq]3\[dq]].map((str) => parseInt(str)); // [1, 2, 3]

// A simpler way to achieve the above, while avoiding the \[dq]gotcha\[dq]:
[\[dq]1\[dq], \[dq]2\[dq], \[dq]3\[dq]].map(Number); // [1, 2, 3]

// But unlike parseInt(), Number() will also return a float or (resolved) exponential notation:
[\[dq]1.1\[dq], \[dq]2.2e2\[dq], \[dq]3e300\[dq]].map(Number); // [1.1, 220, 3e+300]

// For comparison, if we use parseInt() on the array above:
[\[dq]1.1\[dq], \[dq]2.2e2\[dq], \[dq]3e300\[dq]].map((str) => parseInt(str)); // [1, 2, 3]
\f[R]
.fi
.PP
One alternative output of the map method being called with
\f[V]parseInt\f[R] as a parameter runs as follows:
.IP
.nf
\f[C]
const strings = [\[dq]10\[dq], \[dq]10\[dq], \[dq]10\[dq]];
const numbers = strings.map(parseInt);

console.log(numbers);
// Actual result of [10, NaN, 2] may be unexpected based on the above description.
\f[R]
.fi
.SS Mapped array contains undefined
.PP
When \f[V]undefined\f[R] or nothing is returned:
.IP
.nf
\f[C]
const numbers = [1, 2, 3, 4];
const filteredNumbers = numbers.map((num, index) => {
  if (index < 3) {
    return num;
  }
});

// index goes from 0, so the filterNumbers are 1,2,3 and undefined.
// filteredNumbers is [1, 2, 3, undefined]
// numbers is still [1, 2, 3, 4]
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]Array.prototype.map\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-array)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[V]Array\f[R]
.IP \[bu] 2
\f[V]Array.prototype.forEach()\f[R]
.IP \[bu] 2
\f[V]Array.from()\f[R]
.IP \[bu] 2
\f[V]TypedArray.prototype.map()\f[R]
.IP \[bu] 2
\f[V]Map\f[R]
