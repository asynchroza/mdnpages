.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Proxy.Proxy" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Proxy.Proxy - Proxy() constructor
.SH SYNOPSIS
.PP
The \f[B]\f[VB]Proxy()\f[B]\f[R] constructor creates \f[V]Proxy\f[R]
objects.
.SH SYNTAX
.IP
.nf
\f[C]
new Proxy(target, handler)
\f[R]
.fi
.RS
.PP
\f[B]Note:\f[R] \f[V]Proxy()\f[R] can only be constructed with
\f[V]new\f[R].
Attempting to call it without \f[V]new\f[R] throws a
\f[V]TypeError\f[R].
.RE
.SS Parameters
.TP
\f[B]target\f[R]
A target object to wrap with \f[V]Proxy\f[R].
It can be any sort of object, including a native array, a function, or
even another proxy.
.TP
\f[B]handler\f[R]
An object whose properties are functions that define the behavior of the
proxy when an operation is performed on it.
.SH DESCRIPTION
.PP
Use the \f[V]Proxy()\f[R] constructor to create a new \f[V]Proxy\f[R]
object.
This constructor takes two mandatory arguments:
.IP \[bu] 2
\f[V]target\f[R] is the object for which you want to create the proxy
.IP \[bu] 2
\f[V]handler\f[R] is the object that defines the custom behavior of the
proxy.
.PP
An empty handler will create a proxy that behaves, in almost all
respects, exactly like the target.
By defining any of a set group of functions on the \f[V]handler\f[R]
object, you can customize specific aspects of the proxy\[cq]s behavior.
For example, by defining \f[V]get()\f[R] you can provide a customized
version of the target\[cq]s property accessor.
.SS Handler functions
.PP
This section lists all the handler functions you can define.
Handler functions are sometimes called \f[I]traps\f[R], because they
trap calls to the underlying target object.
.TP
\f[B]handler.apply()\f[R]
A trap for a function call.
.TP
\f[B]handler.construct()\f[R]
A trap for the \f[V]new\f[R] operator.
.TP
\f[B]handler.defineProperty()\f[R]
A trap for \f[V]Object.defineProperty\f[R].
.TP
\f[B]handler.deleteProperty()\f[R]
A trap for the \f[V]delete\f[R] operator.
.TP
\f[B]handler.get()\f[R]
A trap for getting property values.
.TP
\f[B]handler.getOwnPropertyDescriptor()\f[R]
A trap for \f[V]Object.getOwnPropertyDescriptor\f[R].
.TP
\f[B]handler.getPrototypeOf()\f[R]
A trap for \f[V]Object.getPrototypeOf\f[R].
.TP
\f[B]handler.has()\f[R]
A trap for the \f[V]in\f[R] operator.
.TP
\f[B]handler.isExtensible()\f[R]
A trap for \f[V]Object.isExtensible\f[R].
.TP
\f[B]handler.ownKeys()\f[R]
A trap for \f[V]Object.getOwnPropertyNames\f[R] and
\f[V]Object.getOwnPropertySymbols\f[R].
.TP
\f[B]handler.preventExtensions()\f[R]
A trap for \f[V]Object.preventExtensions\f[R].
.TP
\f[B]handler.set()\f[R]
A trap for setting property values.
.TP
\f[B]handler.setPrototypeOf()\f[R]
A trap for \f[V]Object.setPrototypeOf\f[R].
.SH EXAMPLES
.SS Selectively proxy property accessors
.PP
In this example the target has two properties, \f[V]notProxied\f[R] and
\f[V]proxied\f[R].
We define a handler that returns a different value for
\f[V]proxied\f[R], and lets any other accesses through to the target.
.IP
.nf
\f[C]
const target = {
  notProxied: \[dq]original value\[dq],
  proxied: \[dq]original value\[dq],
};

const handler = {
  get(target, prop, receiver) {
    if (prop === \[dq]proxied\[dq]) {
      return \[dq]replaced value\[dq];
    }
    return Reflect.get(...arguments);
  },
};

const proxy = new Proxy(target, handler);

console.log(proxy.notProxied); // \[dq]original value\[dq]
console.log(proxy.proxied); // \[dq]replaced value\[dq]
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
\f[V]Proxy\f[R] and \f[V]Reflect\f[R] in the JavaScript Guide
.IP \[bu] 2
\f[V]Reflect\f[R]
