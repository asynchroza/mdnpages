.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Object.freeze" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]Object.freeze()\f[B]\f[R] static method \f[I]freezes\f[R]
an object.
Freezing an object prevents extensions and makes existing properties
non-writable and non-configurable.
A frozen object can no longer be changed: new properties cannot be
added, existing properties cannot be removed, their enumerability,
configurability, writability, or value cannot be changed, and the
object\[cq]s prototype cannot be re-assigned.
\f[V]freeze()\f[R] returns the same object that was passed in.
.PP
Freezing an object is the highest integrity level that JavaScript
provides.
.SH Syntax
.IP
.nf
\f[C]
Object.freeze(obj)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]obj\f[R]
.RS 2
.IP \[bu] 2
The object to freeze.
.RE
.SS Return value
.PP
The object that was passed to the function.
.SH Description
.PP
Freezing an object is equivalent to preventing extensions and then
changing all existing properties\[cq] descriptors\[cq]
\f[V]configurable\f[R] to \f[V]false\f[R] \[em] and for data properties,
\f[V]writable\f[R] to \f[V]false\f[R] as well.
Nothing can be added to or removed from the properties set of a frozen
object.
Any attempt to do so will fail, either silently or by throwing a
\f[V]TypeError\f[R] exception (most commonly, but not exclusively, when
in \f[V]strict mode\f[R]).
.PP
For data properties of a frozen object, their values cannot be changed
since the writable and configurable attributes are set to false.
Accessor properties (getters and setters) work the same \[em] the
property value returned by the getter may still change, and the setter
can still be called without throwing errors when setting the property.
Note that values that are objects can still be modified, unless they are
also frozen.
As an object, an array can be frozen; after doing so, its elements
cannot be altered and no elements can be added to or removed from the
array.
.PP
\f[V]freeze()\f[R] returns the same object that was passed into the
function.
It \f[I]does not\f[R] create a frozen copy.
.PP
A \f[V]TypedArray\f[R] or a \f[V]DataView\f[R] with elements will cause
a \f[V]TypeError\f[R], as they are views over memory and will definitely
cause other possible issues:
.IP
.nf
\f[C]
Object.freeze(new Uint8Array(0)); // No elements
// Uint8Array []

Object.freeze(new Uint8Array(1)); // Has elements
// TypeError: Cannot freeze array buffer views with elements

Object.freeze(new DataView(new ArrayBuffer(32))); // No elements
// DataView {}

Object.freeze(new Float64Array(new ArrayBuffer(64), 63, 0)); // No elements
// Float64Array []

Object.freeze(new Float64Array(new ArrayBuffer(64), 32, 2)); // Has elements
// TypeError: Cannot freeze array buffer views with elements
\f[R]
.fi
.PP
Note that as the standard three properties (\f[V]buf.byteLength\f[R],
\f[V]buf.byteOffset\f[R] and \f[V]buf.buffer\f[R]) are read-only (as are
those of an \f[V]ArrayBuffer\f[R] or \f[V]SharedArrayBuffer\f[R]), there
is no reason for attempting to freeze these properties.
.PP
Unlike \f[V]Object.seal()\f[R], existing properties in objects frozen
with \f[V]Object.freeze()\f[R] are made immutable and data properties
cannot be re-assigned.
.SH Examples
.SS Freezing objects
.IP
.nf
\f[C]
const obj = {
  prop() {},
  foo: \[dq]bar\[dq],
};

// Before freezing: new properties may be added,
// and existing properties may be changed or removed
obj.foo = \[dq]baz\[dq];
obj.lumpy = \[dq]woof\[dq];
delete obj.prop;

// Freeze.
const o = Object.freeze(obj);

// The return value is just the same object we passed in.
o === obj; // true

// The object has become frozen.
Object.isFrozen(obj); // === true

// Now any changes will fail
obj.foo = \[dq]quux\[dq]; // silently does nothing
// silently doesn\[aq]t add the property
obj.quaxxor = \[dq]the friendly duck\[dq];

// In strict mode such attempts will throw TypeErrors
function fail() {
  \[dq]use strict\[dq];
  obj.foo = \[dq]sparky\[dq]; // throws a TypeError
  delete obj.foo; // throws a TypeError
  delete obj.quaxxor; // returns true since attribute \[aq]quaxxor\[aq] was never added
  obj.sparky = \[dq]arf\[dq]; // throws a TypeError
}

fail();

// Attempted changes through Object.defineProperty;
// both statements below throw a TypeError.
Object.defineProperty(obj, \[dq]ohai\[dq], { value: 17 });
Object.defineProperty(obj, \[dq]foo\[dq], { value: \[dq]eit\[dq] });

// It\[aq]s also impossible to change the prototype
// both statements below will throw a TypeError.
Object.setPrototypeOf(obj, { x: 20 });
obj.__proto__ = { x: 20 };
\f[R]
.fi
.SS Freezing arrays
.IP
.nf
\f[C]
const a = [0];
Object.freeze(a); // The array cannot be modified now.

a[0] = 1; // fails silently

// In strict mode such attempt will throw a TypeError
function fail() {
  \[dq]use strict\[dq];
  a[0] = 1;
}

fail();

// Attempted to push
a.push(2); // throws a TypeError
\f[R]
.fi
.PP
The object being frozen is \f[I]immutable\f[R].
However, it is not necessarily \f[I]constant\f[R].
The following example shows that a frozen object is not constant (freeze
is shallow).
.IP
.nf
\f[C]
const obj1 = {
  internal: {},
};

Object.freeze(obj1);
obj1.internal.a = \[dq]aValue\[dq];

obj1.internal.a; // \[aq]aValue\[aq]
\f[R]
.fi
.PP
To be a constant object, the entire reference graph (direct and indirect
references to other objects) must reference only immutable frozen
objects.
The object being frozen is said to be immutable because the entire
object \f[I]state\f[R] (values and references to other objects) within
the whole object is fixed.
Note that strings, numbers, and booleans are always immutable and that
Functions and Arrays are objects.
.SS What is \[lq]shallow freeze\[rq]?
.PP
The result of calling \f[V]Object.freeze(object)\f[R] only applies to
the immediate properties of \f[V]object\f[R] itself and will prevent
future property addition, removal or value re-assignment operations
\f[I]only\f[R] on \f[V]object\f[R].
If the value of those properties are objects themselves, those objects
are not frozen and may be the target of property addition, removal or
value re-assignment operations.
.IP
.nf
\f[C]
const employee = {
  name: \[dq]Mayank\[dq],
  designation: \[dq]Developer\[dq],
  address: {
    street: \[dq]Rohini\[dq],
    city: \[dq]Delhi\[dq],
  },
};

Object.freeze(employee);

employee.name = \[dq]Dummy\[dq]; // fails silently in non-strict mode
employee.address.city = \[dq]Noida\[dq]; // attributes of child object can be modified

console.log(employee.address.city); // \[dq]Noida\[dq]
\f[R]
.fi
.PP
To make an object immutable, recursively freeze each non-primitive
property (deep freeze).
Use the pattern on a case-by-case basis based on your design when you
know the object contains no
cycles (https://en.wikipedia.org/wiki/Cycle_(graph_theory)) in the
reference graph, otherwise an endless loop will be triggered.
An enhancement to \f[V]deepFreeze()\f[R] would be to have an internal
function that receives a path (e.g.\ an Array) argument so you can
suppress calling \f[V]deepFreeze()\f[R] recursively when an object is in
the process of being made immutable.
You still run a risk of freezing an object that shouldn\[cq]t be frozen,
such as [window].
.IP
.nf
\f[C]
function deepFreeze(object) {
  // Retrieve the property names defined on object
  const propNames = Reflect.ownKeys(object);

  // Freeze properties before freezing self
  for (const name of propNames) {
    const value = object[name];

    if ((value && typeof value === \[dq]object\[dq]) || typeof value === \[dq]function\[dq]) {
      deepFreeze(value);
    }
  }

  return Object.freeze(object);
}

const obj2 = {
  internal: {
    a: null,
  },
};

deepFreeze(obj2);

obj2.internal.a = \[dq]anotherValue\[dq]; // fails silently in non-strict mode
obj2.internal.a; // null
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]Object.isFrozen()\f[R]
.IP \[bu] 2
\f[V]Object.preventExtensions()\f[R]
.IP \[bu] 2
\f[V]Object.isExtensible()\f[R]
.IP \[bu] 2
\f[V]Object.seal()\f[R]
.IP \[bu] 2
\f[V]Object.isSealed()\f[R]
