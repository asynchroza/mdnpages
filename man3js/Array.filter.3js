.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.filter" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Array.filter - Array.prototype.filter()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]filter()\f[B]\f[R] method creates a shallow copy of a
portion of a given array, filtered down to just the elements from the
given array that pass the test implemented by the provided function.
.SH SYNTAX
.IP
.nf
\f[C]
filter(callbackFn)
filter(callbackFn, thisArg)
\f[R]
.fi
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element in the array.
It should return a truthy value to keep the element in the resulting
array, and a falsy value otherwise.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the array.
.TP
\f[B]index\f[R]
The index of the current element being processed in the array.
.TP
\f[B]array\f[R]
The array \f[V]filter()\f[R] was called upon.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
A value to use as \f[V]this\f[R] when executing \f[V]callbackFn\f[R].
See iterative methods.
.SS Return value
.PP
A shallow copy of a portion of the given array, filtered down to just
the elements from the given array that pass the test implemented by the
provided function.
If no elements pass the test, an empty array will be returned.
.SH DESCRIPTION
.PP
The \f[V]filter()\f[R] method is an iterative method.
It calls a provided \f[V]callbackFn\f[R] function once for each element
in an array, and constructs a new array of all the values for which
\f[V]callbackFn\f[R] returns a truthy value.
Array elements which do not pass the \f[V]callbackFn\f[R] test are not
included in the new array.
.PP
\f[V]callbackFn\f[R] is invoked only for array indexes which have
assigned values.
It is not invoked for empty slots in sparse arrays.
.PP
The \f[V]filter()\f[R] method is a copying method.
It does not alter \f[V]this\f[R] but instead returns a shallow copy that
contains the same elements as the ones from the original array (with
some filtered out).
However, the function provided as \f[V]callbackFn\f[R] can mutate the
array.
Note, however, that the length of the array is saved \f[I]before\f[R]
the first invocation of \f[V]callbackFn\f[R].
Therefore:
.IP \[bu] 2
\f[V]callbackFn\f[R] will not visit any elements added beyond the
array\[cq]s initial length when the call to \f[V]filter()\f[R] began.
.IP \[bu] 2
Changes to already-visited indexes do not cause \f[V]callbackFn\f[R] to
be invoked on them again.
.IP \[bu] 2
If an existing, yet-unvisited element of the array is changed by
\f[V]callbackFn\f[R], its value passed to the \f[V]callbackFn\f[R] will
be the value at the time that element gets visited.
Deleted elements are not visited.
.RS
.PP
\f[B]Warning:\f[R] Concurrent modifications of the kind described above
frequently lead to hard-to-understand code and are generally to be
avoided (except in special cases).
.RE
.PP
The \f[V]filter()\f[R] method is generic.
It only expects the \f[V]this\f[R] value to have a \f[V]length\f[R]
property and integer-keyed properties.
.SH EXAMPLES
.SS Filtering out all small values
.PP
The following example uses \f[V]filter()\f[R] to create a filtered array
that has all elements with values less than \f[V]10\f[R] removed.
.IP
.nf
\f[C]
function isBigEnough(value) {
  return value >= 10;
}

const filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
// filtered is [12, 130, 44]
\f[R]
.fi
.SS Find all prime numbers in an array
.PP
The following example returns all prime numbers in the array:
.IP
.nf
\f[C]
const array = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];

function isPrime(num) {
  for (let i = 2; num > i; i++) {
    if (num % i === 0) {
      return false;
    }
  }
  return num > 1;
}

console.log(array.filter(isPrime)); // [2, 3, 5, 7, 11, 13]
\f[R]
.fi
.SS Filtering invalid entries from JSON
.PP
The following example uses \f[V]filter()\f[R] to create a filtered JSON
of all elements with non-zero, numeric \f[V]id\f[R].
.IP
.nf
\f[C]
const arr = [
  { id: 15 },
  { id: -1 },
  { id: 0 },
  { id: 3 },
  { id: 12.2 },
  {},
  { id: null },
  { id: NaN },
  { id: \[dq]undefined\[dq] },
];

let invalidEntries = 0;

function filterByID(item) {
  if (Number.isFinite(item.id) && item.id !== 0) {
    return true;
  }
  invalidEntries++;
  return false;
}

const arrByID = arr.filter(filterByID);

console.log(\[dq]Filtered Array\[rs]n\[dq], arrByID);
// Filtered Array
// [{ id: 15 }, { id: -1 }, { id: 3 }, { id: 12.2 }]

console.log(\[dq]Number of Invalid Entries =\[dq], invalidEntries);
// Number of Invalid Entries = 5
\f[R]
.fi
.SS Searching in array
.PP
Following example uses \f[V]filter()\f[R] to filter array content based
on search criteria.
.IP
.nf
\f[C]
const fruits = [\[dq]apple\[dq], \[dq]banana\[dq], \[dq]grapes\[dq], \[dq]mango\[dq], \[dq]orange\[dq]];

/**
 * Filter array items based on search criteria (query)
 */
function filterItems(arr, query) {
  return arr.filter((el) => el.toLowerCase().includes(query.toLowerCase()));
}

console.log(filterItems(fruits, \[dq]ap\[dq])); // [\[aq]apple\[aq], \[aq]grapes\[aq]]
console.log(filterItems(fruits, \[dq]an\[dq])); // [\[aq]banana\[aq], \[aq]mango\[aq], \[aq]orange\[aq]]
\f[R]
.fi
.SS Using filter() on sparse arrays
.PP
\f[V]filter()\f[R] will skip empty slots.
.IP
.nf
\f[C]
console.log([1, , undefined].filter((x) => x === undefined)); // [undefined]
console.log([1, , undefined].filter((x) => x !== 2)); // [1, undefined]
\f[R]
.fi
.SS Calling filter() on non-array objects
.PP
The \f[V]filter()\f[R] method reads the \f[V]length\f[R] property of
\f[V]this\f[R] and then accesses each integer index.
.IP
.nf
\f[C]
const arrayLike = {
  length: 3,
  0: \[dq]a\[dq],
  1: \[dq]b\[dq],
  2: \[dq]c\[dq],
};
console.log(Array.prototype.filter.call(arrayLike, (x) => x <= \[dq]b\[dq]));
// [ \[aq]a\[aq], \[aq]b\[aq] ]
\f[R]
.fi
.SS Affecting Initial Array (modifying, appending and deleting)
.PP
The following example tests the behavior of the \f[V]filter\f[R] method
when the array is modified.
.IP
.nf
\f[C]
// Modifying each word
let words = [\[dq]spray\[dq], \[dq]limit\[dq], \[dq]exuberant\[dq], \[dq]destruction\[dq], \[dq]elite\[dq], \[dq]present\[dq]];

const modifiedWords = words.filter((word, index, arr) => {
  arr[index + 1] += \[dq] extra\[dq];
  return word.length < 6;
});

console.log(modifiedWords);
// Notice there are three words below length 6, but since they\[aq]ve been modified one is returned
// [\[dq]spray\[dq]]

// Appending new words
words = [\[dq]spray\[dq], \[dq]limit\[dq], \[dq]exuberant\[dq], \[dq]destruction\[dq], \[dq]elite\[dq], \[dq]present\[dq]];
const appendedWords = words.filter((word, index, arr) => {
  arr.push(\[dq]new\[dq]);
  return word.length < 6;
});

console.log(appendedWords);
// Only three fits the condition even though the \[ga]words\[ga] itself now has a lot more words with character length less than 6
// [\[dq]spray\[dq] ,\[dq]limit\[dq] ,\[dq]elite\[dq]]

// Deleting words
words = [\[dq]spray\[dq], \[dq]limit\[dq], \[dq]exuberant\[dq], \[dq]destruction\[dq], \[dq]elite\[dq], \[dq]present\[dq]];
const deleteWords = words.filter((word, index, arr) => {
  arr.pop();
  return word.length < 6;
});

console.log(deleteWords);
// Notice \[aq]elite\[aq] is not even obtained as it\[aq]s been popped off \[aq]words\[aq] before filter can even get there
// [\[dq]spray\[dq] ,\[dq]limit\[dq]]
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]Array.prototype.filter\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-array)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[V]Array\f[R]
.IP \[bu] 2
\f[V]Array.prototype.forEach()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.every()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.map()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.some()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.reduce()\f[R]
.IP \[bu] 2
\f[V]TypedArray.prototype.filter()\f[R]
