.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Error" "JS" "September 25, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Error - Error
.SH SYNOPSIS
\f[B]\f[CB]Error\f[B]\f[R] objects are thrown when runtime errors occur.
The \f[CR]Error\f[R] object can also be used as a base object for
user-defined exceptions.
See below for standard built-in error types.
.SH DESCRIPTION
Runtime errors result in new \f[CR]Error\f[R] objects being created and
thrown.
.PP
\f[CR]Error\f[R] is a serializable object, so it can be cloned with
\f[CR]structuredClone()\f[R] or copied between Workers using
\f[CR]postMessage()\f[R].
.SS Error types
Besides the generic \f[CR]Error\f[R] constructor, there are other core
error constructors in JavaScript.
For client-side exceptions, see Exception handling statements.
.TP
\f[B]EvalError\f[R]
Creates an instance representing an error that occurs regarding the
global function \f[CR]eval()\f[R].
.TP
\f[B]RangeError\f[R]
Creates an instance representing an error that occurs when a numeric
variable or parameter is outside its valid range.
.TP
\f[B]ReferenceError\f[R]
Creates an instance representing an error that occurs when
de-referencing an invalid reference.
.TP
\f[B]SyntaxError\f[R]
Creates an instance representing a syntax error.
.TP
\f[B]TypeError\f[R]
Creates an instance representing an error that occurs when a variable or
parameter is not of a valid type.
.TP
\f[B]URIError\f[R]
Creates an instance representing an error that occurs when
\f[CR]encodeURI()\f[R] or \f[CR]decodeURI()\f[R] are passed invalid
parameters.
.TP
\f[B]AggregateError\f[R]
Creates an instance representing several errors wrapped in a single
error when multiple errors need to be reported by an operation, for
example by \f[CR]Promise.any()\f[R].
.TP
\f[B]InternalError\f[R] \f[I](non-standard)\f[R]
Creates an instance representing an error that occurs when an internal
error in the JavaScript engine is thrown.
E.g.
\[lq]too much recursion\[rq].
.SH CONSTRUCTOR
.TP
\f[B]Error()\f[R]
Creates a new \f[CR]Error\f[R] object.
.SH STATIC METHODS
.TP
\f[B]Error.captureStackTrace()\f[R] \f[I](non-standard)\f[R]
A non-standard V8 function that creates the \f[CR]stack\f[R] property on
an Error instance.
.TP
\f[B]Error.stackTraceLimit\f[R] \f[I](non-standard)\f[R]
A non-standard V8 numerical property that limits how many stack frames
to include in an error stacktrace.
.TP
\f[B]Error.prepareStackTrace()\f[R] \f[I](non-standard)\f[R] \f[I](optional)\f[R]
A non-standard V8 function that, if provided by usercode, is called by
the V8 JavaScript engine for thrown exceptions, allowing the user to
provide custom formatting for stacktraces.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]Error.prototype\f[R] and shared by
all \f[CR]Error\f[R] instances.
.TP
\f[B]Error.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]Error\f[R] instances, the initial value is the
\f[CR]Error\f[R] constructor.
.TP
\f[B]Error.prototype.name\f[R]
Represents the name for the type of error.
For \f[CR]Error.prototype.name\f[R], the initial value is
\f[CR]\[dq]Error\[dq]\f[R].
Subclasses like \f[CR]TypeError\f[R] and \f[CR]SyntaxError\f[R] provide
their own \f[CR]name\f[R] properties.
.TP
\f[B]Error.prototype.stack\f[R] \f[I](non-standard)\f[R]
A non-standard property for a stack trace.
.PP
These properties are own properties of each \f[CR]Error\f[R] instance.
.TP
\f[B]cause\f[R]
Error cause indicating the reason why the current error is thrown \[em]
usually another caught error.
For user-created \f[CR]Error\f[R] objects, this is the value provided as
the \f[CR]cause\f[R] property of the constructor\[cq]s second argument.
.TP
\f[B]columnNumber\f[R] \f[I](non-standard)\f[R]
A non-standard Mozilla property for the column number in the line that
raised this error.
.TP
\f[B]fileName\f[R] \f[I](non-standard)\f[R]
A non-standard Mozilla property for the path to the file that raised
this error.
.TP
\f[B]lineNumber\f[R] \f[I](non-standard)\f[R]
A non-standard Mozilla property for the line number in the file that
raised this error.
.TP
\f[B]message\f[R]
Error message.
For user-created \f[CR]Error\f[R] objects, this is the string provided
as the constructor\[cq]s first argument.
.SH INSTANCE METHODS
.TP
\f[B]Error.prototype.toString()\f[R]
Returns a string representing the specified object.
Overrides the \f[CR]Object.prototype.toString()\f[R] method.
.SH EXAMPLES
.SS Throwing a generic error
Usually you create an \f[CR]Error\f[R] object with the intention of
raising it using the \f[CR]throw\f[R] keyword.
You can handle the error using the \f[CR]try...catch\f[R] construct:
.IP
.EX
try {
  throw new Error(\[dq]Whoops!\[dq]);
} catch (e) {
  console.error(\[ga]${e.name}: ${e.message}\[ga]);
}
.EE
.SS Handling a specific error type
You can choose to handle only specific error types by testing the error
type with the \f[CR]instanceof\f[R] keyword:
.IP
.EX
try {
  foo.bar();
} catch (e) {
  if (e instanceof EvalError) {
    console.error(\[ga]${e.name}: ${e.message}\[ga]);
  } else if (e instanceof RangeError) {
    console.error(\[ga]${e.name}: ${e.message}\[ga]);
  }
  // etc.
  else {
    // If none of our cases matched leave the Error unhandled
    throw e;
  }
}
.EE
.SS Differentiate between similar errors
Sometimes a block of code can fail for reasons that require different
handling, but which throw very similar errors (i.e.\ with the same type
and message).
.PP
If you don\[cq]t have control over the original errors that are thrown,
one option is to catch them and throw new \f[CR]Error\f[R] objects that
have more specific messages.
The original error should be passed to the new \f[CR]Error\f[R] in the
constructor\[cq]s \f[CR]options\f[R] parameter as its \f[CR]cause\f[R]
property.
This ensures that the original error and stack trace are available to
higher-level try/catch blocks.
.PP
The example below shows this for two methods that would otherwise fail
with similar errors (\f[CR]doFailSomeWay()\f[R] and
\f[CR]doFailAnotherWay()\f[R]):
.IP
.EX
function doWork() {
  try {
    doFailSomeWay();
  } catch (err) {
    throw new Error(\[dq]Failed in some way\[dq], { cause: err });
  }
  try {
    doFailAnotherWay();
  } catch (err) {
    throw new Error(\[dq]Failed in another way\[dq], { cause: err });
  }
}

try {
  doWork();
} catch (err) {
  switch (err.message) {
    case \[dq]Failed in some way\[dq]:
      handleFailSomeWay(err.cause);
      break;
    case \[dq]Failed in another way\[dq]:
      handleFailAnotherWay(err.cause);
      break;
  }
}
.EE
.RS
.PP
\f[B]Note:\f[R] If you are making a library, you should prefer to use
error cause to discriminate between different errors emitted \[em]
rather than asking your consumers to parse the error message.
See the error cause page for an example.
.RE
.PP
Custom error types can also use the \f[CR]cause\f[R] property, provided
the subclasses\[cq] constructor passes the \f[CR]options\f[R] parameter
when calling \f[CR]super()\f[R].
The \f[CR]Error()\f[R] base class constructor will read
\f[CR]options.cause\f[R] and define the \f[CR]cause\f[R] property on the
new error instance.
.IP
.EX
class MyError extends Error {
  constructor(message, options) {
    // Need to pass \[ga]options\[ga] as the second parameter to install the \[dq]cause\[dq] property.
    super(message, options);
  }
}

console.log(new MyError(\[dq]test\[dq], { cause: new Error(\[dq]cause\[dq]) }).cause);
// Error: cause
.EE
.SS Custom error types
You might want to define your own error types deriving from
\f[CR]Error\f[R] to be able to \f[CR]throw new MyError()\f[R] and use
\f[CR]instanceof MyError\f[R] to check the kind of error in the
exception handler.
This results in cleaner and more consistent error handling code.
.PP
See \[lq]What\[cq]s a good way to extend Error in
JavaScript?\[rq] (https://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript)
on StackOverflow for an in-depth discussion.
.RS
.PP
\f[B]Warning:\f[R] Builtin subclassing cannot be reliably transpiled to
pre-ES6 code, because there\[cq]s no way to construct the base class
with a particular \f[CR]new.target\f[R] without
\f[CR]Reflect.construct()\f[R].
You need additional
configuration (https://github.com/loganfsmyth/babel-plugin-transform-builtin-extend)
or manually call
\f[CR]Object.setPrototypeOf(this, CustomError.prototype)\f[R] at the end
of the constructor; otherwise, the constructed instance will not be a
\f[CR]CustomError\f[R] instance.
See the TypeScript
FAQ (https://github.com/microsoft/TypeScript/wiki/FAQ#why-doesnt-extending-built-ins-like-error-array-and-map-work)
for more information.
.RE
.RS
.PP
\f[B]Note:\f[R] Some browsers include the \f[CR]CustomError\f[R]
constructor in the stack trace when using ES2015 classes.
.RE
.IP
.EX
class CustomError extends Error {
  constructor(foo = \[dq]bar\[dq], ...params) {
    // Pass remaining arguments (including vendor specific ones) to parent constructor
    super(...params);

    // Maintains proper stack trace for where our error was thrown (only available on V8)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CustomError);
    }

    this.name = \[dq]CustomError\[dq];
    // Custom debugging information
    this.foo = foo;
    this.date = new Date();
  }
}

try {
  throw new CustomError(\[dq]baz\[dq], \[dq]bazMessage\[dq]);
} catch (e) {
  console.error(e.name); // CustomError
  console.error(e.foo); // baz
  console.error(e.message); // bazMessage
  console.error(e.stack); // stacktrace
}
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]Error\f[R] with \f[CR]cause\f[R] support in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-error)
.IP \[bu] 2
\f[CR]throw\f[R]
.IP \[bu] 2
\f[CR]try...catch\f[R]
.IP \[bu] 2
Stack trace API (https://v8.dev/docs/stack-trace-api) in the V8 docs
