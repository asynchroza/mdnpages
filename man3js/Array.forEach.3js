.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Array.forEach" "JS" "April 17, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.forEach - Array.prototype.forEach()
.SH SYNOPSIS
The \f[B]\f[CB]forEach()\f[B]\f[R] method executes a provided function
once for each array element.
.SH SYNTAX
.IP
.EX
forEach(callbackFn)
forEach(callbackFn, thisArg)
.EE
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element in the array.
Its return value is discarded.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the array.
.TP
\f[B]index\f[R]
The index of the current element being processed in the array.
.TP
\f[B]array\f[R]
The array \f[CR]forEach()\f[R] was called upon.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
A value to use as \f[CR]this\f[R] when executing \f[CR]callbackFn\f[R].
See iterative methods.
.SS Return value
\f[CR]undefined\f[R].
.SH DESCRIPTION
The \f[CR]forEach()\f[R] method is an iterative method.
It calls a provided \f[CR]callbackFn\f[R] function once for each element
in an array in ascending-index order.
Unlike \f[CR]map()\f[R], \f[CR]forEach()\f[R] always returns
\f[CR]undefined\f[R] and is not chainable.
The typical use case is to execute side effects at the end of a chain.
.PP
\f[CR]callbackFn\f[R] is invoked only for array indexes which have
assigned values.
It is not invoked for empty slots in sparse arrays.
.PP
\f[CR]forEach()\f[R] does not mutate the array on which it is called,
but the function provided as \f[CR]callbackFn\f[R] can.
Note, however, that the length of the array is saved \f[I]before\f[R]
the first invocation of \f[CR]callbackFn\f[R].
Therefore:
.IP \[bu] 2
\f[CR]callbackFn\f[R] will not visit any elements added beyond the
array\[cq]s initial length when the call to \f[CR]forEach()\f[R] began.
.IP \[bu] 2
Changes to already-visited indexes do not cause \f[CR]callbackFn\f[R] to
be invoked on them again.
.IP \[bu] 2
If an existing, yet-unvisited element of the array is changed by
\f[CR]callbackFn\f[R], its value passed to the \f[CR]callbackFn\f[R]
will be the value at the time that element gets visited.
Deleted elements are not visited.
.RS
.PP
\f[B]Warning:\f[R] Concurrent modifications of the kind described above
frequently lead to hard-to-understand code and are generally to be
avoided (except in special cases).
.RE
.PP
The \f[CR]forEach()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer-keyed properties.
.PP
There is no way to stop or break a \f[CR]forEach()\f[R] loop other than
by throwing an exception.
If you need such behavior, the \f[CR]forEach()\f[R] method is the wrong
tool.
.PP
Early termination may be accomplished with looping statements like
\f[CR]for\f[R], \f[CR]for...of\f[R], and \f[CR]for...in\f[R].
Array methods like \f[CR]every()\f[R], \f[CR]some()\f[R],
\f[CR]find()\f[R], and \f[CR]findIndex()\f[R] also stops iteration
immediately when further iteration is not necessary.
.PP
\f[CR]forEach()\f[R] expects a synchronous function \[em] it does not
wait for promises.
Make sure you are aware of the implications while using promises (or
async functions) as \f[CR]forEach\f[R] callbacks.
.IP
.EX
const ratings = [5, 4, 5];
let sum = 0;

const sumFunction = async (a, b) => a + b;

ratings.forEach(async (rating) => {
  sum = await sumFunction(sum, rating);
});

console.log(sum);
// Naively expected output: 14
// Actual output: 0
.EE
.PP
To run a series of asynchronous operations sequentially or concurrently,
see promise composition.
.SH EXAMPLES
.SS Using forEach() on sparse arrays
.IP
.EX
const arraySparse = [1, 3, /* empty */, 7];
let numCallbackRuns = 0;

arraySparse.forEach((element) => {
  console.log({ element });
  numCallbackRuns++;
});

console.log({ numCallbackRuns });

// { element: 1 }
// { element: 3 }
// { element: 7 }
// { numCallbackRuns: 3 }
.EE
.PP
The callback function is not invoked for the missing value at index 2.
.SS Converting a for loop to forEach
.IP
.EX
const items = [\[dq]item1\[dq], \[dq]item2\[dq], \[dq]item3\[dq]];
const copyItems = [];

// before
for (let i = 0; i < items.length; i++) {
  copyItems.push(items[i]);
}

// after
items.forEach((item) => {
  copyItems.push(item);
});
.EE
.SS Printing the contents of an array
.RS
.PP
\f[B]Note:\f[R] In order to display the content of an array in the
console, you can use \f[CR]console.table()\f[R], which prints a
formatted version of the array.
.PP
The following example illustrates an alternative approach, using
\f[CR]forEach()\f[R].
.RE
.PP
The following code logs a line for each element in an array:
.IP
.EX
const logArrayElements = (element, index /*, array */) => {
  console.log(\[ga]a[${index}] = ${element}\[ga]);
};

// Notice that index 2 is skipped, since there is no item at
// that position in the array.
[2, 5, , 9].forEach(logArrayElements);
// Logs:
// a[0] = 2
// a[1] = 5
// a[3] = 9
.EE
.SS Using thisArg
The following (contrived) example updates an object\[cq]s properties
from each entry in the array:
.IP
.EX
class Counter {
  constructor() {
    this.sum = 0;
    this.count = 0;
  }
  add(array) {
    // Only function expressions will have its own this binding
    array.forEach(function countEntry(entry) {
      this.sum += entry;
      ++this.count;
    }, this);
  }
}

const obj = new Counter();
obj.add([2, 5, 9]);
console.log(obj.count); // 3
console.log(obj.sum); // 16
.EE
.PP
Since the \f[CR]thisArg\f[R] parameter (\f[CR]this\f[R]) is provided to
\f[CR]forEach()\f[R], it is passed to \f[CR]callback\f[R] each time
it\[cq]s invoked.
The callback uses it as its \f[CR]this\f[R] value.
.RS
.PP
\f[B]Note:\f[R] If passing the callback function used an arrow function
expression, the \f[CR]thisArg\f[R] parameter could be omitted, since all
arrow functions lexically bind the \f[CR]this\f[R] value.
.RE
.SS An object copy function
The following code creates a copy of a given object.
.PP
There are different ways to create a copy of an object.
The following is just one way and is presented to explain how
\f[CR]Array.prototype.forEach()\f[R] works by using \f[CR]Object.*\f[R]
utility functions.
.IP
.EX
const copy = (obj) => {
  const copy = Object.create(Object.getPrototypeOf(obj));
  const propNames = Object.getOwnPropertyNames(obj);
  propNames.forEach((name) => {
    const desc = Object.getOwnPropertyDescriptor(obj, name);
    Object.defineProperty(copy, name, desc);
  });
  return copy;
};

const obj1 = { a: 1, b: 2 };
const obj2 = copy(obj1); // obj2 looks like obj1 now
.EE
.SS Modifying the array during iteration
The following example logs \f[CR]one\f[R], \f[CR]two\f[R],
\f[CR]four\f[R].
.PP
When the entry containing the value \f[CR]two\f[R] is reached, the first
entry of the whole array is shifted off\[em]resulting in all remaining
entries moving up one position.
Because element \f[CR]four\f[R] is now at an earlier position in the
array, \f[CR]three\f[R] will be skipped.
.PP
\f[CR]forEach()\f[R] does not make a copy of the array before iterating.
.IP
.EX
const words = [\[dq]one\[dq], \[dq]two\[dq], \[dq]three\[dq], \[dq]four\[dq]];
words.forEach((word) => {
  console.log(word);
  if (word === \[dq]two\[dq]) {
    words.shift(); //\[aq]one\[aq] will delete from array
  }
}); // one // two // four

console.log(words); // [\[aq]two\[aq], \[aq]three\[aq], \[aq]four\[aq]]
.EE
.SS Flatten an array
The following example is only here for learning purpose.
If you want to flatten an array using built-in methods, you can use
\f[CR]Array.prototype.flat()\f[R].
.IP
.EX
const flatten = (arr) => {
  const result = [];
  arr.forEach((item) => {
    if (Array.isArray(item)) {
      result.push(...flatten(item));
    } else {
      result.push(item);
    }
  });
  return result;
};

// Usage
const nested = [1, 2, 3, [4, 5, [6, 7], 8, 9]];
console.log(flatten(nested)); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
.EE
.SS Calling forEach() on non-array objects
The \f[CR]forEach()\f[R] method reads the \f[CR]length\f[R] property of
\f[CR]this\f[R] and then accesses each integer index.
.IP
.EX
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
Array.prototype.forEach.call(arrayLike, (x) => console.log(x));
// 2
// 3
// 4
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]Array.prototype.forEach\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-array)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.find()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.map()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.filter()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.every()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.some()\f[R]
.IP \[bu] 2
\f[CR]TypedArray.prototype.forEach()\f[R]
.IP \[bu] 2
\f[CR]Map.prototype.forEach()\f[R]
.IP \[bu] 2
\f[CR]Set.prototype.forEach()\f[R]
