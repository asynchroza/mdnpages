.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "String.match" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
String.match - String.prototype.match()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]match()\f[B]\f[R] method retrieves the result of matching
a string against a regular expression.
.SH SYNTAX
.IP
.nf
\f[C]
match(regexp)
\f[R]
.fi
.SS Parameters
.TP
\f[B]regexp\f[R]
A regular expression object, or any object that has a
\f[V]Symbol.match\f[R] method.
.RS
.PP
If \f[V]regexp\f[R] is not a \f[V]RegExp\f[R] object and does not have a
\f[V]Symbol.match\f[R] method, it is implicitly converted to a
\f[V]RegExp\f[R] by using \f[V]new RegExp(regexp)\f[R].
.PP
If you don\[cq]t give any parameter and use the \f[V]match()\f[R] method
directly, you will get an \f[V]Array\f[R] with an empty string:
\f[V][\[dq]\[dq]]\f[R], because this is equivalent to
\f[V]match(/(?:)/)\f[R].
.RE
.SS Return value
.PP
An \f[V]Array\f[R] whose contents depend on the presence or absence of
the global (\f[V]g\f[R]) flag, or \f[V]null\f[R] if no matches are
found.
.IP \[bu] 2
If the \f[V]g\f[R] flag is used, all results matching the complete
regular expression will be returned, but capturing groups are not
included.
.IP \[bu] 2
If the \f[V]g\f[R] flag is not used, only the first complete match and
its related capturing groups are returned.
In this case, \f[V]match()\f[R] will return the same result as
\f[V]RegExp.prototype.exec()\f[R] (an array with some extra properties).
.SH DESCRIPTION
.PP
The implementation of \f[V]String.prototype.match\f[R] itself is very
simple \[em] it simply calls the \f[V]Symbol.match\f[R] method of the
argument with the string as the first parameter.
The actual implementation comes from
\f[V]RegExp.prototype[\[at]\[at]match]()\f[R].
.IP \[bu] 2
If you need to know if a string matches a regular expression
\f[V]RegExp\f[R], use \f[V]RegExp.prototype.test()\f[R].
.IP \[bu] 2
If you only want the first match found, you might want to use
\f[V]RegExp.prototype.exec()\f[R] instead.
.IP \[bu] 2
If you want to obtain capture groups and the global flag is set, you
need to use \f[V]RegExp.prototype.exec()\f[R] or
\f[V]String.prototype.matchAll()\f[R] instead.
.PP
For more information about the semantics of \f[V]match()\f[R] when a
regex is passed, see \f[V]RegExp.prototype[\[at]\[at]match]()\f[R].
.SH EXAMPLES
.SS Using match()
.PP
In the following example, \f[V]match()\f[R] is used to find
\f[V]\[dq]Chapter\[dq]\f[R] followed by one or more numeric characters
followed by a decimal point and numeric character zero or more times.
.PP
The regular expression includes the \f[V]i\f[R] flag so that upper/lower
case differences will be ignored.
.IP
.nf
\f[C]
const str = \[dq]For more information, see Chapter 3.4.5.1\[dq];
const re = /see (chapter \[rs]d+(\[rs].\[rs]d)*)/i;
const found = str.match(re);

console.log(found);
// [
//   \[aq]see Chapter 3.4.5.1\[aq],
//   \[aq]Chapter 3.4.5.1\[aq],
//   \[aq].1\[aq],
//   index: 22,
//   input: \[aq]For more information, see Chapter 3.4.5.1\[aq],
//   groups: undefined
// ]
\f[R]
.fi
.PP
In the match result above, \f[V]\[aq]see Chapter 3.4.5.1\[aq]\f[R] is
the whole match.
\f[V]\[aq]Chapter 3.4.5.1\[aq]\f[R] was captured by
\f[V](chapter \[rs]d+(\[rs].\[rs]d)*)\f[R].
\f[V]\[aq].1\[aq]\f[R] was the last value captured by
\f[V](\[rs].\[rs]d)\f[R].
The \f[V]index\f[R] property (\f[V]22\f[R]) is the zero-based index of
the whole match.
The \f[V]input\f[R] property is the original string that was parsed.
.SS Using global and ignoreCase flags with match()
.PP
The following example demonstrates the use of the global flag and
ignore-case flag with \f[V]match()\f[R].
All letters \f[V]A\f[R] through \f[V]E\f[R] and \f[V]a\f[R] through
\f[V]e\f[R] are returned, each its own element in the array.
.IP
.nf
\f[C]
const str = \[dq]ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\[dq];
const regexp = /[A-E]/gi;
const matches = str.match(regexp);

console.log(matches);
// [\[aq]A\[aq], \[aq]B\[aq], \[aq]C\[aq], \[aq]D\[aq], \[aq]E\[aq], \[aq]a\[aq], \[aq]b\[aq], \[aq]c\[aq], \[aq]d\[aq], \[aq]e\[aq]]
\f[R]
.fi
.RS
.PP
\f[B]Note:\f[R] See also \f[V]String.prototype.matchAll()\f[R] and
Advanced searching with flags.
.RE
.SS Using named capturing groups
.PP
In browsers which support named capturing groups, the following code
captures \f[V]\[dq]fox\[dq]\f[R] or \f[V]\[dq]cat\[dq]\f[R] into a group
named \f[V]animal\f[R]:
.IP
.nf
\f[C]
const paragraph = \[dq]The quick brown fox jumps over the lazy dog. It barked.\[dq];

const capturingRegex = /(?<animal>fox|cat) jumps over/;
const found = paragraph.match(capturingRegex);
console.log(found.groups); // {animal: \[dq]fox\[dq]}
\f[R]
.fi
.SS Using match() with no parameter
.IP
.nf
\f[C]
const str = \[dq]Nothing will come of nothing.\[dq];

str.match(); // returns [\[dq]\[dq]]
\f[R]
.fi
.SS Using match() with a non-RegExp implementing \[at]\[at]match
.PP
If an object has a \f[V]Symbol.match\f[R] method, it can be used as a
custom matcher.
The return value of \f[V]Symbol.match\f[R] becomes the return value of
\f[V]match()\f[R].
.IP
.nf
\f[C]
const str = \[dq]Hmm, this is interesting.\[dq];

str.match({
  [Symbol.match](str) {
    return [\[dq]Yes, it\[aq]s interesting.\[dq]];
  },
}); // returns [\[dq]Yes, it\[aq]s interesting.\[dq]]
\f[R]
.fi
.SS A non-RegExp as the parameter
.PP
When the \f[V]regexp\f[R] parameter is a string or a number, it is
implicitly converted to a \f[V]RegExp\f[R] by using
\f[V]new RegExp(regexp)\f[R].
.IP
.nf
\f[C]
const str1 =
  \[dq]NaN means not a number. Infinity contains -Infinity and +Infinity in JavaScript.\[dq];
const str2 =
  \[dq]My grandfather is 65 years old and My grandmother is 63 years old.\[dq];
const str3 = \[dq]The contract was declared null and void.\[dq];
str1.match(\[dq]number\[dq]); // \[dq]number\[dq] is a string. returns [\[dq]number\[dq]]
str1.match(NaN); // the type of NaN is the number. returns [\[dq]NaN\[dq]]
str1.match(Infinity); // the type of Infinity is the number. returns [\[dq]Infinity\[dq]]
str1.match(+Infinity); // returns [\[dq]Infinity\[dq]]
str1.match(-Infinity); // returns [\[dq]-Infinity\[dq]]
str2.match(65); // returns [\[dq]65\[dq]]
str2.match(+65); // A number with a positive sign. returns [\[dq]65\[dq]]
str3.match(null); // returns [\[dq]null\[dq]]
\f[R]
.fi
.PP
This may have unexpected results if special characters are not properly
escaped.
.IP
.nf
\f[C]
console.log(\[dq]123\[dq].match(\[dq]1.3\[dq])); // [ \[dq]123\[dq] ]
\f[R]
.fi
.PP
This is a match because \f[V].\f[R] in a regex matches any character.
In order to make it only match specifically a dot character, you need to
escape the input.
.IP
.nf
\f[C]
console.log(\[dq]123\[dq].match(\[dq]1\[rs]\[rs].3\[dq])); // null
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]String.prototype.match\f[R] in \f[V]core-js\f[R] with
fixes and implementation of modern behavior like \f[V]Symbol.match\f[R]
support (https://github.com/zloirock/core-js#ecmascript-string-and-regexp)
.IP \[bu] 2
\f[V]String.prototype.matchAll()\f[R]
.IP \[bu] 2
\f[V]RegExp\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype.exec()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype.test()\f[R]
