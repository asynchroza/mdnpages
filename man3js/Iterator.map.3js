.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Iterator.map" "JS" "August 26, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Iterator.map - Iterator.prototype.map()
.SH SYNOPSIS
The \f[B]\f[CB]map()\f[B]\f[R] method of \f[CR]Iterator\f[R] instances
returns a new iterator helper that yields elements of the iterator, each
transformed by a mapping function.
.SH SYNTAX
.IP
.EX
map(callbackFn)
.EE
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element produced by the iterator.
Its return value is yielded by the iterator helper.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed.
.TP
\f[B]index\f[R]
The index of the current element being processed.
.RE
.SS Return value
A new iterator helper.
Each time the iterator helper\[cq]s \f[CR]next()\f[R] method is called,
it gets the next element from the underlying iterator, applies
\f[CR]callbackFn\f[R], and yields the return value.
When the underlying iterator is completed, the iterator helper is also
completed (the \f[CR]next()\f[R] method produces
\f[CR]{ value: undefined, done: true }\f[R]).
.SH DESCRIPTION
The main advantage of iterator helpers over array methods is their
ability to work with infinite iterators.
With infinite iterators, \f[CR]map()\f[R] allows you to create a new
iterator that, when iterated, produces transformed elements.
.SH EXAMPLES
.SS Using map()
The following example creates an iterator that yields terms in the
Fibonacci sequence, transforms it into a new sequence with each term
squared, and then reads the first few terms:
.IP
.EX
function* fibonacci() {
  let current = 1;
  let next = 1;
  while (true) {
    yield current;
    [current, next] = [next, current + next];
  }
}

const seq = fibonacci().map((x) => x ** 2);
console.log(seq.next().value); // 1
console.log(seq.next().value); // 1
console.log(seq.next().value); // 4
.EE
.SS Using map() with a for\&...of loop
\f[CR]map()\f[R] is most convenient when you are not hand-rolling the
iterator.
Because iterators are also iterable, you can iterate the returned helper
with a \f[CR]for...of\f[R] loop:
.IP
.EX
for (const n of fibonacci().map((x) => x ** 2)) {
  console.log(n);
  if (n > 30) {
    break;
  }
}

// Logs:
// 1
// 1
// 4
// 9
// 25
// 64
.EE
.PP
This is equivalent to:
.IP
.EX
for (const n of fibonacci()) {
  const n2 = n ** 2;
  console.log(n2);
  if (n2 > 30) {
    break;
  }
}
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]Iterator.prototype.map\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#iterator-helpers)
