.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "TypedArray.from" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
TypedArray.from - TypedArray.from()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]TypedArray.from()\f[B]\f[R] static method creates a new
typed array from an array-like or iterable object.
This method is nearly the same as \f[V]Array.from()\f[R].
.SH SYNTAX
.IP
.nf
\f[C]
TypedArray.from(arrayLike, mapFn)
TypedArray.from(arrayLike, mapFn, thisArg)
\f[R]
.fi
.PP
Where \f[V]TypedArray\f[R] is one of:
.IP \[bu] 2
\f[V]Int8Array\f[R]
.IP \[bu] 2
\f[V]Uint8Array\f[R]
.IP \[bu] 2
\f[V]Uint8ClampedArray\f[R]
.IP \[bu] 2
\f[V]Int16Array\f[R]
.IP \[bu] 2
\f[V]Uint16Array\f[R]
.IP \[bu] 2
\f[V]Int32Array\f[R]
.IP \[bu] 2
\f[V]Uint32Array\f[R]
.IP \[bu] 2
\f[V]Float32Array\f[R]
.IP \[bu] 2
\f[V]Float64Array\f[R]
.IP \[bu] 2
\f[V]BigInt64Array\f[R]
.IP \[bu] 2
\f[V]BigUint64Array\f[R]
.SS Parameters
.TP
\f[B]arrayLike\f[R]
An iterable or array-like object to convert to a typed array.
.TP
\f[B]mapFn\f[R] \f[I](optional)\f[R]
A function to call on every element of the typed array.
If provided, every value to be added to the array is first passed
through this function, and \f[V]mapFn\f[R]\[cq]s return value is added
to the typed array instead.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the typed array.
.TP
\f[B]index\f[R]
The index of the current element being processed in the typed array.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
Value to use as \f[V]this\f[R] when executing \f[V]mapFn\f[R].
.SS Return value
.PP
A new \f[V]TypedArray\f[R] instance.
.SH DESCRIPTION
.PP
See \f[V]Array.from()\f[R] for more details.
.PP
There are some subtle distinctions between \f[V]Array.from()\f[R] and
\f[V]TypedArray.from()\f[R] (note: the \f[V]this\f[R] value mentioned
below is the \f[V]this\f[R] value that \f[V]TypedArray.from()\f[R] was
called with, not the \f[V]thisArg\f[R] argument used to invoke
\f[V]mapFn\f[R]):
.IP \[bu] 2
If the \f[V]this\f[R] value of \f[V]TypedArray.from()\f[R] is not a
constructor, \f[V]TypedArray.from()\f[R] will throw a
\f[V]TypeError\f[R], while \f[V]Array.from()\f[R] defaults to creating a
new \f[V]Array\f[R].
.IP \[bu] 2
The object constructed by \f[V]this\f[R] must be a \f[V]TypedArray\f[R]
instance, while \f[V]Array.from()\f[R] allows its \f[V]this\f[R] value
to be constructed to any object.
.IP \[bu] 2
When the \f[V]source\f[R] parameter is an iterator,
\f[V]TypedArray.from()\f[R] first collects all the values from the
iterator, then creates an instance of \f[V]this\f[R] using the count,
and finally sets the values on the instance.
\f[V]Array.from()\f[R] sets each value as it receives them from the
iterator, then sets its \f[V]length\f[R] at the end.
.IP \[bu] 2
\f[V]TypedArray.from()\f[R] uses \f[V][[Set]]\f[R] while
\f[V]Array.from()\f[R] uses \f[V][[DefineOwnProperty]]\f[R].
Hence, when working with \f[V]Proxy\f[R] objects, it calls
\f[V]handler.set()\f[R] to create new elements rather than
\f[V]handler.defineProperty()\f[R].
.IP \[bu] 2
When \f[V]Array.from()\f[R] gets an array-like which isn\[cq]t an
iterator, it respects holes.
\f[V]TypedArray.from()\f[R] will ensure the result is dense.
.SH EXAMPLES
.SS From an iterable object (Set)
.IP
.nf
\f[C]
const s = new Set([1, 2, 3]);
Uint8Array.from(s);
// Uint8Array [ 1, 2, 3 ]
\f[R]
.fi
.SS From a string
.IP
.nf
\f[C]
Int16Array.from(\[dq]123\[dq]);
// Int16Array [ 1, 2, 3 ]
\f[R]
.fi
.SS Use with arrow function and map
.PP
Using an arrow function as the map function to manipulate the elements
.IP
.nf
\f[C]
Float32Array.from([1, 2, 3], (x) => x + x);
// Float32Array [ 2, 4, 6 ]
\f[R]
.fi
.SS Generate a sequence of numbers
.IP
.nf
\f[C]
Uint8Array.from({ length: 5 }, (v, k) => k);
// Uint8Array [ 0, 1, 2, 3, 4 ]
\f[R]
.fi
.SS Calling from() on non-TypedArray constructors
.PP
The \f[V]this\f[R] value of \f[V]from()\f[R] must be a constructor that
returns a \f[V]TypedArray\f[R] instance.
.IP
.nf
\f[C]
function NotArray(len) {
  console.log(\[dq]NotArray called with length\[dq], len);
}

Int8Array.from.call({}, []); // TypeError: #<Object> is not a constructor
Int8Array.from.call(NotArray, []);
// NotArray called with length 0
// TypeError: Method %TypedArray%.from called on incompatible receiver #<NotArray>
\f[R]
.fi
.IP
.nf
\f[C]
function NotArray2(len) {
  console.log(\[dq]NotArray2 called with length\[dq], len);
  return new Uint8Array(len);
}
console.log(Int8Array.from.call(NotArray2, [1, 2, 3]));
// NotArray2 called with length 3
// Uint8Array(3) [ 1, 2, 3 ]
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]TypedArray.from\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-typed-arrays)
.IP \[bu] 2
\f[V]TypedArray.of()\f[R]
.IP \[bu] 2
\f[V]Array.from()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.map()\f[R]
