.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "TypedArray.from" "JS" "May 17, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
TypedArray.from - TypedArray.from()
.SH SYNOPSIS
The \f[B]\f[CB]TypedArray.from()\f[B]\f[R] static method creates a new
typed array from an array-like or iterable object.
This method is nearly the same as \f[CR]Array.from()\f[R].
.SH SYNTAX
.IP
.EX
TypedArray.from(arrayLike, mapFn)
TypedArray.from(arrayLike, mapFn, thisArg)
.EE
.PP
Where \f[CR]TypedArray\f[R] is one of:
.IP \[bu] 2
\f[CR]Int8Array\f[R]
.IP \[bu] 2
\f[CR]Uint8Array\f[R]
.IP \[bu] 2
\f[CR]Uint8ClampedArray\f[R]
.IP \[bu] 2
\f[CR]Int16Array\f[R]
.IP \[bu] 2
\f[CR]Uint16Array\f[R]
.IP \[bu] 2
\f[CR]Int32Array\f[R]
.IP \[bu] 2
\f[CR]Uint32Array\f[R]
.IP \[bu] 2
\f[CR]Float32Array\f[R]
.IP \[bu] 2
\f[CR]Float64Array\f[R]
.IP \[bu] 2
\f[CR]BigInt64Array\f[R]
.IP \[bu] 2
\f[CR]BigUint64Array\f[R]
.SS Parameters
.TP
\f[B]arrayLike\f[R]
An iterable or array-like object to convert to a typed array.
.TP
\f[B]mapFn\f[R] \f[I](optional)\f[R]
A function to call on every element of the typed array.
If provided, every value to be added to the array is first passed
through this function, and \f[CR]mapFn\f[R]\[cq]s return value is added
to the typed array instead.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the typed array.
.TP
\f[B]index\f[R]
The index of the current element being processed in the typed array.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
Value to use as \f[CR]this\f[R] when executing \f[CR]mapFn\f[R].
.SS Return value
A new \f[CR]TypedArray\f[R] instance.
.SH DESCRIPTION
See \f[CR]Array.from()\f[R] for more details.
.PP
There are some subtle distinctions between \f[CR]Array.from()\f[R] and
\f[CR]TypedArray.from()\f[R] (note: the \f[CR]this\f[R] value mentioned
below is the \f[CR]this\f[R] value that \f[CR]TypedArray.from()\f[R] was
called with, not the \f[CR]thisArg\f[R] argument used to invoke
\f[CR]mapFn\f[R]):
.IP \[bu] 2
If the \f[CR]this\f[R] value of \f[CR]TypedArray.from()\f[R] is not a
constructor, \f[CR]TypedArray.from()\f[R] will throw a
\f[CR]TypeError\f[R], while \f[CR]Array.from()\f[R] defaults to creating
a new \f[CR]Array\f[R].
.IP \[bu] 2
The object constructed by \f[CR]this\f[R] must be a
\f[CR]TypedArray\f[R] instance, while \f[CR]Array.from()\f[R] allows its
\f[CR]this\f[R] value to be constructed to any object.
.IP \[bu] 2
When the \f[CR]source\f[R] parameter is an iterator,
\f[CR]TypedArray.from()\f[R] first collects all the values from the
iterator, then creates an instance of \f[CR]this\f[R] using the count,
and finally sets the values on the instance.
\f[CR]Array.from()\f[R] sets each value as it receives them from the
iterator, then sets its \f[CR]length\f[R] at the end.
.IP \[bu] 2
\f[CR]TypedArray.from()\f[R] uses \f[CR][[Set]]\f[R] while
\f[CR]Array.from()\f[R] uses \f[CR][[DefineOwnProperty]]\f[R].
Hence, when working with \f[CR]Proxy\f[R] objects, it calls
\f[CR]handler.set()\f[R] to create new elements rather than
\f[CR]handler.defineProperty()\f[R].
.IP \[bu] 2
When \f[CR]Array.from()\f[R] gets an array-like which isn\[cq]t an
iterator, it respects holes.
\f[CR]TypedArray.from()\f[R] will ensure the result is dense.
.SH EXAMPLES
.SS From an iterable object (Set)
.IP
.EX
const s = new Set([1, 2, 3]);
Uint8Array.from(s);
// Uint8Array [ 1, 2, 3 ]
.EE
.SS From a string
.IP
.EX
Int16Array.from(\[dq]123\[dq]);
// Int16Array [ 1, 2, 3 ]
.EE
.SS Use with arrow function and map
Using an arrow function as the map function to manipulate the elements
.IP
.EX
Float32Array.from([1, 2, 3], (x) => x + x);
// Float32Array [ 2, 4, 6 ]
.EE
.SS Generate a sequence of numbers
.IP
.EX
Uint8Array.from({ length: 5 }, (v, k) => k);
// Uint8Array [ 0, 1, 2, 3, 4 ]
.EE
.SS Calling from() on non-TypedArray constructors
The \f[CR]this\f[R] value of \f[CR]from()\f[R] must be a constructor
that returns a \f[CR]TypedArray\f[R] instance.
.IP
.EX
function NotArray(len) {
  console.log(\[dq]NotArray called with length\[dq], len);
}

Int8Array.from.call({}, []); // TypeError: #<Object> is not a constructor
Int8Array.from.call(NotArray, []);
// NotArray called with length 0
// TypeError: Method %TypedArray%.from called on incompatible receiver #<NotArray>
.EE
.IP
.EX
function NotArray2(len) {
  console.log(\[dq]NotArray2 called with length\[dq], len);
  return new Uint8Array(len);
}
console.log(Int8Array.from.call(NotArray2, [1, 2, 3]));
// NotArray2 called with length 3
// Uint8Array(3) [ 1, 2, 3 ]
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]TypedArray.from\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-typed-arrays)
.IP \[bu] 2
\f[CR]TypedArray.of()\f[R]
.IP \[bu] 2
\f[CR]Array.from()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.map()\f[R]
