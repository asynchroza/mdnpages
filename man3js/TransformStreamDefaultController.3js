.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "TransformStreamDefaultController" "JS" "July 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
TransformStreamDefaultController \- TransformStreamDefaultController
.SH SYNOPSIS
The \f[B]\f[CB]TransformStreamDefaultController\f[B]\f[R] interface of
the Streams API provides methods to manipulate the associated
\f[CR]ReadableStream\f[R] and \f[CR]WritableStream\f[R].
.PP
When constructing a \f[CR]TransformStream\f[R], the
\f[CR]TransformStreamDefaultController\f[R] is created.
It therefore has no constructor.
The way to get an instance of
\f[CR]TransformStreamDefaultController\f[R] is via the callback methods
of \f[CR]TransformStream()\f[R].
.SH INSTANCE PROPERTIES
.TP
\f[B]TransformStreamDefaultController.desiredSize\f[R] \f[I](read\-only)\f[R]
Returns the desired size to fill the readable side of the stream\[cq]s
internal queue.
.SH INSTANCE METHODS
.TP
\f[B]TransformStreamDefaultController.enqueue()\f[R]
Enqueues a chunk (single piece of data) in the readable side of the
stream.
.TP
\f[B]TransformStreamDefaultController.error()\f[R]
Errors both the readable and writable side of the transform stream.
.TP
\f[B]TransformStreamDefaultController.terminate()\f[R]
Closes the readable side and errors the writable side of the stream.
.SH EXAMPLES
In the following example, a transform stream passes through all chunks
it receives as \f[CR]Uint8Array\f[R] values, using the
\f[CR]error()\f[R] and \f[CR]enqueue()\f[R] methods.
.IP
.EX
const transformContent = {
  start() {}, // required.
  async transform(chunk, controller) {
    chunk = await chunk;
    switch (typeof chunk) {
      case \[dq]object\[dq]:
        // just say the stream is done I guess
        if (chunk === null) {
          controller.terminate();
        } else if (ArrayBuffer.isView(chunk)) {
          controller.enqueue(
            new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength),
          );
        } else if (
          Array.isArray(chunk) &&
          chunk.every((value) => typeof value === \[dq]number\[dq])
        ) {
          controller.enqueue(new Uint8Array(chunk));
        } else if (
          typeof chunk.valueOf === \[dq]function\[dq] &&
          chunk.valueOf() !== chunk
        ) {
          this.transform(chunk.valueOf(), controller); // hack
        } else if (\[dq]toJSON\[dq] in chunk) {
          this.transform(JSON.stringify(chunk), controller);
        }
        break;
      case \[dq]symbol\[dq]:
        controller.error(\[dq]Cannot send a symbol as a chunk part\[dq]);
        break;
      case \[dq]undefined\[dq]:
        controller.error(\[dq]Cannot send undefined as a chunk part\[dq]);
        break;
      default:
        controller.enqueue(this.textencoder.encode(String(chunk)));
        break;
    }
  },
  flush() {
    /* do any destructor work here */
  },
};

class AnyToU8Stream extends TransformStream {
  constructor() {
    super({ ...transformContent, textencoder: new TextEncoder() });
  }
}
.EE
