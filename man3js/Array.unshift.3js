.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Array.unshift" "JS" "April 17, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.unshift - Array.prototype.unshift()
.SH SYNOPSIS
The \f[B]\f[CB]unshift()\f[B]\f[R] method adds the specified elements to
the beginning of an array and returns the new length of the array.
.SH SYNTAX
.IP
.EX
unshift()
unshift(element0)
unshift(element0, element1)
unshift(element0, element1, /* \&... ,*/ elementN)
.EE
.SS Parameters
.TP
\f[B]elementN\f[R]
The elements to add to the front of the \f[CR]arr\f[R].
.SS Return value
The new \f[CR]length\f[R] property of the object upon which the method
was called.
.SH DESCRIPTION
The \f[CR]unshift()\f[R] method inserts the given values to the
beginning of an array-like object.
.PP
\f[CR]Array.prototype.push()\f[R] has similar behavior to
\f[CR]unshift()\f[R], but applied to the end of an array.
.PP
Please note that, if multiple elements are passed as parameters,
they\[cq]re inserted in chunk at the beginning of the object, in the
exact same order they were passed as parameters.
Hence, calling \f[CR]unshift()\f[R] with \f[CR]n\f[R] arguments
\f[B]once\f[R], or calling it \f[CR]n\f[R] times with \f[B]1\f[R]
argument (with a loop, for example), don\[cq]t yield the same results.
.PP
See example:
.IP
.EX
let arr = [4, 5, 6];

arr.unshift(1, 2, 3);
console.log(arr);
// [1, 2, 3, 4, 5, 6]

arr = [4, 5, 6]; // resetting the array

arr.unshift(1);
arr.unshift(2);
arr.unshift(3);

console.log(arr);
// [3, 2, 1, 4, 5, 6]
.EE
.PP
The \f[CR]unshift()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer-keyed properties.
Although strings are also array-like, this method is not suitable to be
applied on them, as strings are immutable.
.SH EXAMPLES
.SS Using unshift()
.IP
.EX
const arr = [1, 2];

arr.unshift(0); // result of the call is 3, which is the new array length
// arr is [0, 1, 2]

arr.unshift(-2, -1); // the new array length is 5
// arr is [-2, -1, 0, 1, 2]

arr.unshift([-4, -3]); // the new array length is 6
// arr is [[-4, -3], -2, -1, 0, 1, 2]

arr.unshift([-7, -6], [-5]); // the new array length is 8
// arr is [ [-7, -6], [-5], [-4, -3], -2, -1, 0, 1, 2 ]
.EE
.SS Calling unshift() on non-array objects
The \f[CR]unshift()\f[R] method reads the \f[CR]length\f[R] property of
\f[CR]this\f[R].
It then shifts all properties in the range \f[CR]0\f[R] to
\f[CR]length - 1\f[R] right by the number of arguments and sets each
index starting at \f[CR]0\f[R] with the arguments passed to
\f[CR]unshift()\f[R].
Finally, it sets the \f[CR]length\f[R] to the previous length plus the
number of prepended elements.
.IP
.EX
const arrayLike = {
  length: 3,
  unrelated: \[dq]foo\[dq],
  2: 4,
};
Array.prototype.unshift.call(arrayLike, 1, 2);
console.log(arrayLike);
// { \[aq]0\[aq]: 1, \[aq]1\[aq]: 2, \[aq]4\[aq]: 4, length: 5, unrelated: \[aq]foo\[aq] }

const plainObj = {};
// There\[aq]s no length property, so the length is 0
Array.prototype.unshift.call(plainObj, 1, 2);
console.log(plainObj);
// { \[aq]0\[aq]: 1, \[aq]1\[aq]: 2, length: 2 }
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]Array.prototype.unshift\f[R] in \f[CR]core-js\f[R]
with fixes of this
method (https://github.com/zloirock/core-js#ecmascript-array)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.push()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.pop()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.shift()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.concat()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.splice()\f[R]
