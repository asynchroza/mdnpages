.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "ReadableStream" "JS" "December 29, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
ReadableStream \- ReadableStream
.SH SYNOPSIS
The \f[CR]ReadableStream\f[R] interface of the Streams API represents a
readable stream of byte data.
The Fetch API offers a concrete instance of a \f[CR]ReadableStream\f[R]
through the \f[CR]body\f[R] property of a \f[CR]Response\f[R] object.
.PP
\f[CR]ReadableStream\f[R] is a transferable object.
.SH CONSTRUCTOR
.TP
\f[B]ReadableStream()\f[R]
Creates and returns a readable stream object from the given handlers.
.SH INSTANCE PROPERTIES
.TP
\f[B]ReadableStream.locked\f[R] \f[I](read\-only)\f[R]
Returns a boolean indicating whether or not the readable stream is
locked to a reader.
.SH STATIC METHODS
.TP
\f[B]ReadableStream.from()\f[R] \f[I](experimental)\f[R]
Returns \f[CR]ReadableStream\f[R] from a provided iterable or async
iterable object, such as an array, a set, an async generator, and so on.
.SH INSTANCE METHODS
.TP
\f[B]ReadableStream.cancel()\f[R]
Returns a \f[CR]Promise\f[R] that resolves when the stream is canceled.
Calling this method signals a loss of interest in the stream by a
consumer.
The supplied \f[CR]reason\f[R] argument will be given to the underlying
source, which may or may not use it.
.TP
\f[B]ReadableStream.getReader()\f[R]
Creates a reader and locks the stream to it.
While the stream is locked, no other reader can be acquired until this
one is released.
.TP
\f[B]ReadableStream.pipeThrough()\f[R]
Provides a chainable way of piping the current stream through a
transform stream or any other writable/readable pair.
.TP
\f[B]ReadableStream.pipeTo()\f[R]
Pipes the current ReadableStream to a given \f[CR]WritableStream\f[R]
and returns a \f[CR]Promise\f[R] that fulfills when the piping process
completes successfully, or rejects if any errors were encountered.
.TP
\f[B]ReadableStream.tee()\f[R]
The \f[CR]tee\f[R] method \c
.UR https://streams.spec.whatwg.org/#tee-a-readable-stream
tees
.UE \c
\ this readable stream, returning a two\-element array containing the
two resulting branches as new \f[CR]ReadableStream\f[R] instances.
Each of those streams receives the same incoming data.
.SH ASYNC ITERATION
\f[CR]ReadableStream\f[R] implements the async iterable protocol.
This enables asynchronous iteration over the chunks in a stream using
the \f[CR]for await...of\f[R] syntax:
.IP
.EX
const stream = new ReadableStream(getSomeSource());

for await (const chunk of stream) {
  // Do something with each \[aq]chunk\[aq]
}
.EE
.PP
The async iterator consumes the stream until it runs out of data or
otherwise terminates.
The loop can also exit early due to a \f[CR]break\f[R],
\f[CR]throw\f[R], or \f[CR]return\f[R] statement.
.PP
While iterating, the stream is locked to prevent other consumers from
acquiring a reader (attempting to iterate over a stream that is already
locked will throw a \f[CR]TypeError\f[R]).
This lock is released when the loop exits.
.PP
By default, exiting the loop will also cancel the stream, so that it can
no longer be used.
To continue to use a stream after exiting the loop, pass
\f[CR]{ preventCancel: true }\f[R] to the stream\[cq]s
\f[CR]values()\f[R] method:
.IP
.EX
for await (const chunk of stream.values({ preventCancel: true })) {
  // Do something with \[aq]chunk\[aq]
  break;
}
// Acquire a reader for the stream and continue reading ...
.EE
.SH EXAMPLES
.SS Fetch stream
In the following example, an artificial \f[CR]Response\f[R] is created
to stream HTML fragments fetched from another resource to the browser.
.PP
It demonstrates the usage of a \f[CR]ReadableStream\f[R] in combination
with a \f[CR]Uint8Array\f[R].
.IP
.EX
fetch(\[dq]https://www.example.org\[dq])
  .then((response) => response.body)
  .then((rb) => {
    const reader = rb.getReader();

    return new ReadableStream({
      start(controller) {
        // The following function handles each data chunk
        function push() {
          // \[dq]done\[dq] is a Boolean and value a \[dq]Uint8Array\[dq]
          reader.read().then(({ done, value }) => {
            // If there is no more data to read
            if (done) {
              console.log(\[dq]done\[dq], done);
              controller.close();
              return;
            }
            // Get the data and send it to the browser via the controller
            controller.enqueue(value);
            // Check chunks by logging to the console
            console.log(done, value);
            push();
          });
        }

        push();
      },
    });
  })
  .then((stream) =>
    // Respond with our stream
    new Response(stream, { headers: { \[dq]Content\-Type\[dq]: \[dq]text/html\[dq] } }).text(),
  )
  .then((result) => {
    // Do things with result
    console.log(result);
  });
.EE
.SS Convert an iterator or async iterator to a stream
The \f[CR]from()\f[R] static method can convert an iterator, such as an
\f[CR]Array\f[R] or \f[CR]Map\f[R], or an (async) iterator to a readable
stream:
.IP
.EX
const myReadableStream = ReadableStream.from(iteratorOrAsyncIterator);
.EE
.PP
On browsers that don\[cq]t support the \f[CR]from()\f[R] method you can
instead create your own custom readable stream to achieve the same
result:
.IP
.EX
function iteratorToStream(iterator) {
  return new ReadableStream({
    async pull(controller) {
      const { value, done } = await iterator.next();

      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
  });
}
.EE
.SS Async iteration of a stream using for await\&...of
This example shows how you can process the \f[CR]fetch()\f[R] response
using a \f[CR]for await...of\f[R] loop to iterate through the arriving
chunks.
.IP
.EX
const response = await fetch(\[dq]https://www.example.org\[dq]);
let total = 0;

// Iterate response.body (a ReadableStream) asynchronously
for await (const chunk of response.body) {
  // Do something with each chunk
  // Here we just accumulate the size of the response.
  total += chunk.length;
}

// Do something with the total
console.log(total);
.EE
.SH SEE ALSO
.IP \[bu] 2
Streams API concepts
.IP \[bu] 2
Using readable streams
.IP \[bu] 2
Using readable byte stream
.IP \[bu] 2
\c
.UR https://whatwg-stream-visualizer.glitch.me/
WHATWG Stream Visualizer
.UE \c
, for a basic visualization of readable, writable, and transform
streams.
.IP \[bu] 2
\c
.UR https://github.com/MattiasBuelens/web-streams-polyfill
Web\-streams\-polyfill
.UE \c
\ or \c
.UR https://github.com/stardazed/sd-streams
sd\-streams
.UE \c
\ \- polyfills
