.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Object.valueOf" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Object.valueOf - Object.prototype.valueOf()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]valueOf()\f[B]\f[R] method of \f[V]Object\f[R] instances
converts the \f[V]this\f[R] value to an object.
This method is meant to be overridden by derived objects for custom type
conversion logic.
.SH SYNTAX
.IP
.nf
\f[C]
valueOf()
\f[R]
.fi
.SS Parameters
.PP
None.
.SS Return value
.PP
The \f[V]this\f[R] value, converted to an object.
.RS
.PP
\f[B]Note:\f[R] In order for \f[V]valueOf\f[R] to be useful during type
conversion, it must return a primitive.
Because all primitive types have their own \f[V]valueOf()\f[R] methods,
calling \f[V]aPrimitiveValue.valueOf()\f[R] generally does not invoke
\f[V]Object.prototype.valueOf()\f[R].
.RE
.SH DESCRIPTION
.PP
JavaScript calls the \f[V]valueOf\f[R] method to convert an object to a
primitive value.
You rarely need to invoke the \f[V]valueOf\f[R] method yourself;
JavaScript automatically invokes it when encountering an object where a
primitive value is expected.
.PP
This method is called in priority by numeric conversion and primitive
conversion, but string conversion calls \f[V]toString()\f[R] in
priority, and \f[V]toString()\f[R] is very likely to return a string
value (even for the \f[V]Object.prototype.toString()\f[R] base
implementation), so \f[V]valueOf()\f[R] is usually not called in this
case.
.PP
All objects that inherit from \f[V]Object.prototype\f[R] (that is, all
except \f[V]null\f[R]-prototype objects) inherit the
\f[V]toString()\f[R] method.
The \f[V]Object.prototype.valueOf()\f[R] base implementation is
deliberately useless: by returning an object, its return value will
never be used by any primitive conversion algorithm.
Many built-in objects override this method to return an appropriate
primitive value.
When you create a custom object, you can override \f[V]valueOf()\f[R] to
call a custom method, so that your custom object can be converted to a
primitive value.
Generally, \f[V]valueOf()\f[R] is used to return a value that is most
meaningful for the object \[em] unlike \f[V]toString()\f[R], it does not
need to be a string.
Alternatively, you can add a \f[V]\[at]\[at]toPrimitive\f[R] method,
which allows even more control over the conversion process, and will
always be preferred over \f[V]valueOf\f[R] or \f[V]toString\f[R] for any
type conversion.
.SH EXAMPLES
.SS Using valueOf()
.PP
The base \f[V]valueOf()\f[R] method returns the \f[V]this\f[R] value
itself, converted to an object if it isn\[cq]t already.
Therefore its return value will never be used by any primitive
conversion algorithm.
.IP
.nf
\f[C]
const obj = { foo: 1 };
console.log(obj.valueOf() === obj); // true

console.log(Object.prototype.valueOf.call(\[dq]primitive\[dq]));
// [String: \[aq]primitive\[aq]] (a wrapper object)
\f[R]
.fi
.SS Overriding valueOf for custom objects
.PP
You can create a function to be called in place of the default
\f[V]valueOf\f[R] method.
Your function should take no arguments, since it won\[cq]t be passed any
when called during type conversion.
.PP
For example, you can add a \f[V]valueOf\f[R] method to your custom class
\f[V]Box\f[R].
.IP
.nf
\f[C]
class Box {
  #value;
  constructor(value) {
    this.#value = value;
  }
  valueOf() {
    return this.#value;
  }
}
\f[R]
.fi
.PP
With the preceding code in place, any time an object of type
\f[V]Box\f[R] is used in a context where it is to be represented as a
primitive value (but not specifically a string), JavaScript
automatically calls the function defined in the preceding code.
.IP
.nf
\f[C]
const box = new Box(123);
console.log(box + 456); // 579
console.log(box == 123); // true
\f[R]
.fi
.PP
An object\[cq]s \f[V]valueOf\f[R] method is usually invoked by
JavaScript, but you can invoke it yourself as follows:
.IP
.nf
\f[C]
box.valueOf();
\f[R]
.fi
.SS Using unary plus on objects
.PP
Unary plus performs number coercion on its operand, which, for most
objects without \f[V]\[at]\[at]toPrimitive\f[R], means calling its
\f[V]valueOf()\f[R].
However, if the object doesn\[cq]t have a custom \f[V]valueOf()\f[R]
method, the base implementation will cause \f[V]valueOf()\f[R] to be
ignored and the return value of \f[V]toString()\f[R] to be used instead.
.IP
.nf
\f[C]
+new Date(); // the current timestamp; same as new Date().getTime()
+{}; // NaN (toString() returns \[dq][object Object]\[dq])
+[]; // 0 (toString() returns an empty string list)
+[1]; // 1 (toString() returns \[dq]1\[dq])
+[1, 2]; // NaN (toString() returns \[dq]1,2\[dq])
+new Set([1]); // NaN (toString() returns \[dq][object Set]\[dq])
+{ valueOf: () => 42 }; // 42
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
\f[V]Object.prototype.toString()\f[R]
.IP \[bu] 2
\f[V]parseInt()\f[R]
.IP \[bu] 2
\f[V]Symbol.toPrimitive\f[R]
