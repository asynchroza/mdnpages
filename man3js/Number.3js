.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Number" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
\f[B]\f[VB]Number\f[B]\f[R] values represent floating-point numbers like
\f[V]37\f[R] or \f[V]-9.25\f[R].
.PP
The \f[V]Number\f[R] constructor contains constants and methods for
working with numbers.
Values of other types can be converted to numbers using the
\f[V]Number()\f[R] function.
.SH Description
.PP
Numbers are most commonly expressed in literal forms like \f[V]255\f[R]
or \f[V]3.14159\f[R].
The lexical grammar contains a more detailed reference.
.IP
.nf
\f[C]
255; // two-hundred and fifty-five
255.0; // same number
255 === 255.0; // true
255 === 0xff; // true (hexadecimal notation)
255 === 0b11111111; // true (binary notation)
255 === 0.255e3; // true (decimal exponential notation)
\f[R]
.fi
.PP
A number literal like \f[V]37\f[R] in JavaScript code is a
floating-point value, not an integer.
There is no separate integer type in common everyday use.
(JavaScript also has a \f[V]BigInt\f[R] type, but it\[cq]s not designed
to replace Number for everyday uses.
\f[V]37\f[R] is still a number, not a BigInt.)
.PP
When used as a function, \f[V]Number(value)\f[R] converts a string or
other value to the Number type.
If the value can\[cq]t be converted, it returns \f[V]NaN\f[R].
.IP
.nf
\f[C]
Number(\[dq]123\[dq]); // returns the number 123
Number(\[dq]123\[dq]) === 123; // true

Number(\[dq]unicorn\[dq]); // NaN
Number(undefined); // NaN
\f[R]
.fi
.SS Number encoding
.PP
The JavaScript \f[V]Number\f[R] type is a double-precision 64-bit binary
format IEEE
754 (https://en.wikipedia.org/wiki/Double_precision_floating-point_format)
value, like \f[V]double\f[R] in Java or C#.
This means it can represent fractional values, but there are some limits
to the stored number\[cq]s magnitude and precision.
Very briefly, an IEEE 754 double-precision number uses 64 bits to
represent 3 parts:
.IP \[bu] 2
1 bit for the \f[I]sign\f[R] (positive or negative)
.IP \[bu] 2
11 bits for the \f[I]exponent\f[R] (-1022 to 1023)
.IP \[bu] 2
52 bits for the \f[I]mantissa\f[R] (representing a number between 0 and
1)
.PP
The mantissa (also called \f[I]significand\f[R]) is the part of the
number representing the actual value (significant digits).
The exponent is the power of 2 that the mantissa should be multiplied
by.
Thinking about it as scientific notation:
.PP
Number=(−1)sign⋅(1+mantissa)⋅2exponent = ({-1})\[ha]{} (1 + ) \[ha]{}
.PP
The mantissa is stored with 52 bits, interpreted as digits after
\f[V]1.\&...\f[R] in a binary fractional number.
Therefore, the mantissa\[cq]s precision is 2-52 (obtainable via
\f[V]Number.EPSILON\f[R]), or about 15 to 17 decimal places; arithmetic
above that level of precision is subject to
rounding (https://en.wikipedia.org/wiki/Floating-point_arithmetic#Representable_numbers,_conversion_and_rounding).
.PP
The largest value a number can hold is 21024 - 1 (with the exponent
being 1023 and the mantissa being 0.1111\&...
in base 2), which is obtainable via \f[V]Number.MAX_VALUE\f[R].
Values higher than that are replaced with the special number constant
\f[V]Infinity\f[R].
.PP
Integers can only be represented without loss of precision in the range
-253 + 1 to 253 - 1, inclusive (obtainable via
\f[V]Number.MIN_SAFE_INTEGER\f[R] and
\f[V]Number.MAX_SAFE_INTEGER\f[R]), because the mantissa can only hold
53 bits (including the leading 1).
.PP
More details on this are described in the ECMAScript
standard (https://tc39.es/ecma262/#sec-ecmascript-language-types-number-type).
.SS Number coercion
.PP
Many built-in operations that expect numbers first coerce their
arguments to numbers (which is largely why \f[V]Number\f[R] objects
behave similarly to number primitives).
The operation (https://tc39.es/ecma262/#sec-tonumber) can be summarized
as follows:
.IP \[bu] 2
Numbers are returned as-is.
.IP \[bu] 2
\f[V]undefined\f[R] turns into \f[V]NaN\f[R].
.IP \[bu] 2
\f[V]null\f[R] turns into \f[V]0\f[R].
.IP \[bu] 2
\f[V]true\f[R] turns into \f[V]1\f[R]; \f[V]false\f[R] turns into
\f[V]0\f[R].
.IP \[bu] 2
Strings are converted by parsing them as if they contain a number
literal.
Parsing failure results in \f[V]NaN\f[R].
There are some minor differences compared to an actual number literal:
.RS 2
.IP \[bu] 2
Leading and trailing whitespace/line terminators are ignored.
.IP \[bu] 2
A leading \f[V]0\f[R] digit does not cause the number to become an octal
literal (or get rejected in strict mode).
.IP \[bu] 2
\f[V]+\f[R] and \f[V]-\f[R] are allowed at the start of the string to
indicate its sign.
(In actual code, they \[lq]look like\[rq] part of the literal, but are
actually separate unary operators.)
However, the sign can only appear once, and must not be followed by
whitespace.
.IP \[bu] 2
\f[V]Infinity\f[R] and \f[V]-Infinity\f[R] are recognized as literals.
In actual code, they are global variables.
.IP \[bu] 2
Empty or whitespace-only strings are converted to \f[V]0\f[R].
.IP \[bu] 2
Numeric separators are not allowed.
.RE
.IP \[bu] 2
BigInts throw a \f[V]TypeError\f[R] to prevent unintended implicit
coercion causing loss of precision.
.IP \[bu] 2
Symbols throw a \f[V]TypeError\f[R].
.IP \[bu] 2
Objects are first converted to a primitive by calling their
\f[V][\[at]\[at]toPrimitive]()\f[R] (with \f[V]\[dq]number\[dq]\f[R] as
hint), \f[V]valueOf()\f[R], and \f[V]toString()\f[R] methods, in that
order.
The resulting primitive is then converted to a number.
.PP
There are two ways to achieve nearly the same effect in JavaScript.
.IP \[bu] 2
Unary plus: \f[V]+x\f[R] does exactly the number coercion steps
explained above to convert \f[V]x\f[R].
.IP \[bu] 2
The \f[V]Number()\f[R] function: \f[V]Number(x)\f[R] uses the same
algorithm to convert \f[V]x\f[R], except that BigInts don\[cq]t throw a
\f[V]TypeError\f[R], but return their number value, with possible loss
of precision.
.PP
\f[V]Number.parseFloat()\f[R] and \f[V]Number.parseInt()\f[R] are
similar to \f[V]Number()\f[R] but only convert strings, and have
slightly different parsing rules.
For example, \f[V]parseInt()\f[R] doesn\[cq]t recognize the decimal
point, and \f[V]parseFloat()\f[R] doesn\[cq]t recognize the \f[V]0x\f[R]
prefix.
.SS Integer conversion
.PP
Some operations expect integers, most notably those that work with
array/string indices, date/time components, and number radixes.
After performing the number coercion steps above, the result is
truncated to an integer (by discarding the fractional part).
If the number is ±Infinity, it\[cq]s returned as-is.
If the number is \f[V]NaN\f[R] or \f[V]-0\f[R], it\[cq]s returned as
\f[V]0\f[R].
The result is therefore always an integer (which is not \f[V]-0\f[R]) or
±Infinity.
.PP
Notably, when converted to integers, both \f[V]undefined\f[R] and
\f[V]null\f[R] become \f[V]0\f[R], because \f[V]undefined\f[R] is
converted to \f[V]NaN\f[R], which also becomes \f[V]0\f[R].
.SS Fixed-width number conversion
.PP
JavaScript has some lower-level functions that deal with the binary
encoding of integer numbers, most notably bitwise operators and
\f[V]TypedArray\f[R] objects.
Bitwise operators always convert the operands to 32-bit integers.
In these cases, after converting the value to a number, the number is
then normalized to the given width by first truncating the fractional
part and then taking the lowest bits in the integer\[cq]s two\[cq]s
complement encoding.
.IP
.nf
\f[C]
new Int32Array([1.1, 1.9, -1.1, -1.9]); // Int32Array(4) [ 1, 1, -1, -1 ]

new Int8Array([257, -257]); // Int8Array(2) [ 1, -1 ]
// 257 = 0001 0000 0001
//     =      0000 0001 (mod 2\[ha]8)
//     = 1
// -257 = 1110 1111 1111
//      =      1111 1111 (mod 2\[ha]8)
//      = -1 (as signed integer)

new Uint8Array([257, -257]); // Uint8Array(2) [ 1, 255 ]
// -257 = 1110 1111 1111
//      =      1111 1111 (mod 2\[ha]8)
//      = 255 (as unsigned integer)
\f[R]
.fi
.SH Constructor
.IP \[bu] 2
\f[V]Number()\f[R]
.RS 2
.IP \[bu] 2
Creates a new \f[V]Number\f[R] value.
.RE
.PP
When \f[V]Number\f[R] is called as a constructor (with \f[V]new\f[R]),
it creates a \f[V]Number\f[R] object, which is \f[B]not\f[R] a
primitive.
For example, \f[V]typeof new Number(42) === \[dq]object\[dq]\f[R], and
\f[V]new Number(42) !== 42\f[R] (although
\f[V]new Number(42) == 42\f[R]).
.RS
.PP
\f[B]Warning:\f[R] You should rarely find yourself using
\f[V]Number\f[R] as a constructor.
.RE
.SH Static properties
.IP \[bu] 2
\f[V]Number.EPSILON\f[R]
.RS 2
.IP \[bu] 2
The smallest interval between two representable numbers.
.RE
.IP \[bu] 2
\f[V]Number.MAX_SAFE_INTEGER\f[R]
.RS 2
.IP \[bu] 2
The maximum safe integer in JavaScript (253 - 1).
.RE
.IP \[bu] 2
\f[V]Number.MAX_VALUE\f[R]
.RS 2
.IP \[bu] 2
The largest positive representable number.
.RE
.IP \[bu] 2
\f[V]Number.MIN_SAFE_INTEGER\f[R]
.RS 2
.IP \[bu] 2
The minimum safe integer in JavaScript (-(253 - 1)).
.RE
.IP \[bu] 2
\f[V]Number.MIN_VALUE\f[R]
.RS 2
.IP \[bu] 2
The smallest positive representable number\[em]that is, the positive
number closest to zero (without actually being zero).
.RE
.IP \[bu] 2
\f[V]Number.NaN\f[R]
.RS 2
.IP \[bu] 2
Special \[lq]\f[B]N\f[R]ot \f[B]a\f[R] \f[B]N\f[R]umber\[rq] value.
.RE
.IP \[bu] 2
\f[V]Number.NEGATIVE_INFINITY\f[R]
.RS 2
.IP \[bu] 2
Special value representing negative infinity.
Returned on overflow.
.RE
.IP \[bu] 2
\f[V]Number.POSITIVE_INFINITY\f[R]
.RS 2
.IP \[bu] 2
Special value representing infinity.
Returned on overflow.
.RE
.SH Static methods
.IP \[bu] 2
\f[V]Number.isFinite()\f[R]
.RS 2
.IP \[bu] 2
Determine whether the passed value is a finite number.
.RE
.IP \[bu] 2
\f[V]Number.isInteger()\f[R]
.RS 2
.IP \[bu] 2
Determine whether the passed value is an integer.
.RE
.IP \[bu] 2
\f[V]Number.isNaN()\f[R]
.RS 2
.IP \[bu] 2
Determine whether the passed value is \f[V]NaN\f[R].
.RE
.IP \[bu] 2
\f[V]Number.isSafeInteger()\f[R]
.RS 2
.IP \[bu] 2
Determine whether the passed value is a safe integer (number between
-(253 - 1) and 253 - 1).
.RE
.IP \[bu] 2
\f[V]Number.parseFloat()\f[R]
.RS 2
.IP \[bu] 2
This is the same as the global \f[V]parseFloat()\f[R] function.
.RE
.IP \[bu] 2
\f[V]Number.parseInt()\f[R]
.RS 2
.IP \[bu] 2
This is the same as the global \f[V]parseInt()\f[R] function.
.RE
.SH Instance properties
.PP
These properties are defined on \f[V]Number.prototype\f[R] and shared by
all \f[V]Number\f[R] instances.
.IP \[bu] 2
\f[V]Number.prototype.constructor\f[R]
.RS 2
.IP \[bu] 2
The constructor function that created the instance object.
For \f[V]Number\f[R] instances, the initial value is the
\f[V]Number\f[R] constructor.
.RE
.SH Instance methods
.IP \[bu] 2
\f[V]Number.prototype.toExponential()\f[R]
.RS 2
.IP \[bu] 2
Returns a string representing the number in exponential notation.
.RE
.IP \[bu] 2
\f[V]Number.prototype.toFixed()\f[R]
.RS 2
.IP \[bu] 2
Returns a string representing the number in fixed-point notation.
.RE
.IP \[bu] 2
\f[V]Number.prototype.toLocaleString()\f[R]
.RS 2
.IP \[bu] 2
Returns a string with a language sensitive representation of this
number.
Overrides the \f[V]Object.prototype.toLocaleString()\f[R] method.
.RE
.IP \[bu] 2
\f[V]Number.prototype.toPrecision()\f[R]
.RS 2
.IP \[bu] 2
Returns a string representing the number to a specified precision in
fixed-point or exponential notation.
.RE
.IP \[bu] 2
\f[V]Number.prototype.toString()\f[R]
.RS 2
.IP \[bu] 2
Returns a string representing the specified object in the specified
\f[I]radix\f[R] (\[lq]base\[rq]).
Overrides the \f[V]Object.prototype.toString()\f[R] method.
.RE
.IP \[bu] 2
\f[V]Number.prototype.valueOf()\f[R]
.RS 2
.IP \[bu] 2
Returns the primitive value of the specified object.
Overrides the \f[V]Object.prototype.valueOf()\f[R] method.
.RE
.SH Examples
.SS Using the Number object to assign values to numeric variables
.PP
The following example uses the \f[V]Number\f[R] object\[cq]s properties
to assign values to several numeric variables:
.IP
.nf
\f[C]
const biggestNum = Number.MAX_VALUE;
const smallestNum = Number.MIN_VALUE;
const infiniteNum = Number.POSITIVE_INFINITY;
const negInfiniteNum = Number.NEGATIVE_INFINITY;
const notANum = Number.NaN;
\f[R]
.fi
.SS Integer range for Number
.PP
The following example shows the minimum and maximum integer values that
can be represented as \f[V]Number\f[R] object.
.IP
.nf
\f[C]
const biggestInt = Number.MAX_SAFE_INTEGER; // (2**53 - 1) => 9007199254740991
const smallestInt = Number.MIN_SAFE_INTEGER; // -(2**53 - 1) => -9007199254740991
\f[R]
.fi
.PP
When parsing data that has been serialized to JSON, integer values
falling outside of this range can be expected to become corrupted when
JSON parser coerces them to \f[V]Number\f[R] type.
.PP
A possible workaround is to use \f[V]String\f[R] instead.
.PP
Larger numbers can be represented using the \f[V]BigInt\f[R] type.
.SS Using Number() to convert a Date object
.PP
The following example converts the \f[V]Date\f[R] object to a numerical
value using \f[V]Number\f[R] as a function:
.IP
.nf
\f[C]
const d = new Date(\[dq]1995-12-17T03:24:00\[dq]);
console.log(Number(d));
\f[R]
.fi
.PP
This logs \f[V]819199440000\f[R].
.SS Convert numeric strings and null to numbers
.IP
.nf
\f[C]
Number(\[dq]123\[dq]); // 123
Number(\[dq]123\[dq]) === 123; // true
Number(\[dq]12.3\[dq]); // 12.3
Number(\[dq]12.00\[dq]); // 12
Number(\[dq]123e-1\[dq]); // 12.3
Number(\[dq]\[dq]); // 0
Number(null); // 0
Number(\[dq]0x11\[dq]); // 17
Number(\[dq]0b11\[dq]); // 3
Number(\[dq]0o11\[dq]); // 9
Number(\[dq]foo\[dq]); // NaN
Number(\[dq]100a\[dq]); // NaN
Number(\[dq]-Infinity\[dq]); // -Infinity
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of modern \f[V]Number\f[R] behavior (with support binary and
octal literals) in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-number)
.IP \[bu] 2
\f[V]NaN\f[R]
.IP \[bu] 2
Arithmetic operators
.IP \[bu] 2
The \f[V]Math\f[R] global object
.IP \[bu] 2
Integers with arbitrary precision: \f[V]BigInt\f[R]
