'\" t
.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Atomics.and" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]Atomics.and()\f[B]\f[R] static method computes a bitwise
AND with a given value at a given position in the array, and returns the
old value at that position.
This atomic operation guarantees that no other write happens until the
modified value is written back.
.SH Syntax
.IP
.nf
\f[C]
Atomics.and(typedArray, index, value)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]typedArray\f[R]
.RS 2
.IP \[bu] 2
An integer typed array.
One of \f[V]Int8Array\f[R], \f[V]Uint8Array\f[R], \f[V]Int16Array\f[R],
\f[V]Uint16Array\f[R], \f[V]Int32Array\f[R], \f[V]Uint32Array\f[R],
\f[V]BigInt64Array\f[R], or \f[V]BigUint64Array\f[R].
.RE
.IP \[bu] 2
\f[V]index\f[R]
.RS 2
.IP \[bu] 2
The position in the \f[V]typedArray\f[R] to compute the bitwise AND.
.RE
.IP \[bu] 2
\f[V]value\f[R]
.RS 2
.IP \[bu] 2
The number to compute the bitwise AND with.
.RE
.SS Return value
.PP
The old value at the given position (\f[V]typedArray[index]\f[R]).
.SS Exceptions
.IP \[bu] 2
\f[V]TypeError\f[R]
.RS 2
.IP \[bu] 2
Thrown if \f[V]typedArray\f[R] is not one of the allowed integer types.
.RE
.IP \[bu] 2
\f[V]RangeError\f[R]
.RS 2
.IP \[bu] 2
Thrown if \f[V]index\f[R] is out of bounds in the \f[V]typedArray\f[R].
.RE
.SH Description
.PP
The bitwise AND operation only yields 1, if both \f[V]a\f[R] and
\f[V]b\f[R] are 1.
The truth table for the AND operation is:
.PP
.TS
tab(@);
l l l.
T{
\f[V]a\f[R]
T}@T{
\f[V]b\f[R]
T}@T{
\f[V]a & b\f[R]
T}
_
T{
0
T}@T{
0
T}@T{
0
T}
T{
0
T}@T{
1
T}@T{
0
T}
T{
1
T}@T{
0
T}@T{
0
T}
T{
1
T}@T{
1
T}@T{
1
T}
.TE
.PP
For example, a bitwise AND of \f[V]5 & 1\f[R] results in \f[V]0001\f[R]
which is 1 in decimal.
.IP
.nf
\f[C]
5  0101
1  0001
   ----
1  0001
\f[R]
.fi
.SH Examples
.SS Using and()
.IP
.nf
\f[C]
const sab = new SharedArrayBuffer(1024);
const ta = new Uint8Array(sab);
ta[0] = 5;

Atomics.and(ta, 0, 1); // returns 5, the old value
Atomics.load(ta, 0); // 1
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]Atomics\f[R]
.IP \[bu] 2
\f[V]Atomics.or()\f[R]
.IP \[bu] 2
\f[V]Atomics.xor()\f[R]
