.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "PointerEvent.getPredictedEvents" "JS" "June 23, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
PointerEvent.getPredictedEvents \- PointerEvent: getPredictedEvents()
method
.SH SYNOPSIS
The \f[B]\f[CB]getPredictedEvents()\f[B]\f[R] method of the
\f[CR]PointerEvent\f[R] interface returns a sequence of
\f[CR]PointerEvent\f[R] instances that are estimated future pointer
positions.
How the predicted positions are calculated depends on the user agent,
but they are based on past points, current velocity, and trajectory.
.PP
Applications can use the predicted events to \[lq]draw ahead\[rq] to a
predicted position which may reduce perceived latency depending on the
application\[cq]s interpretation of the predicted events and the use
case.
.PP
For an illustration of predicted events, see \c
.UR https://w3c.github.io/pointerevents/#figure_predicted
Figure 8 in the specification
.UE \c
\&.
.SH SYNTAX
.IP
.EX
getPredictedEvents()
.EE
.SS Parameters
None.
.SS Return value
A sequence of \f[CR]PointerEvent\f[R] instances.
.SH EXAMPLE
.SS HTML
.IP
.EX
<canvas id=\[dq]target\[dq] width=\[dq]600\[dq] height=\[dq]300\[dq]></canvas>
.EE
.SS JavaScript
.IP
.EX
const canvas = document.getElementById(\[dq]target\[dq]);
const ctx = canvas.getContext(\[dq]2d\[dq]);

const pointerEvents = [];

function drawCircle(x, y, color) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // draw the last 20 events
  if (pointerEvents.length > 20) {
    pointerEvents.shift();
  }
  pointerEvents.push({ x, y, color });

  for (const pointerEvent of pointerEvents) {
    ctx.beginPath();
    ctx.arc(pointerEvent.x, pointerEvent.y, 10, 0, 2 * Math.PI);
    ctx.strokeStyle = pointerEvent.color;
    ctx.stroke();
  }
}

canvas.addEventListener(\[dq]pointermove\[dq], (e) => {
  // draw a circle for the current event
  drawCircle(e.clientX, e.clientY, \[dq]black\[dq]);

  const predictedEvents = e.getPredictedEvents();
  for (let predictedEvent of predictedEvents) {
    // give it an offset so we can see the difference and color it red
    drawCircle(predictedEvent.clientX + 20, predictedEvent.clientY + 20, \[dq]red\[dq]);
  }
});
.EE
.SS Result
