.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "RegExp.\[at]\[at]replace" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
RegExp.\[at]\[at]replace - RegExp.prototype\[at]\[at]replace
.SH SYNOPSIS
.PP
The \f[B]\f[VB][\[at]\[at]replace]()\f[B]\f[R] method of
\f[V]RegExp\f[R] instances specifies how
\f[V]String.prototype.replace()\f[R] and
\f[V]String.prototype.replaceAll()\f[R] should behave when the regular
expression is passed in as the pattern.
.SH SYNTAX
.IP
.nf
\f[C]
regexp[Symbol.replace](str, replacement)
\f[R]
.fi
.SS Parameters
.TP
\f[B]str\f[R]
A \f[V]String\f[R] that is a target of the replacement.
.TP
\f[B]replacement\f[R]
Can be a string or a function.
.RS
.IP \[bu] 2
If it\[cq]s a string, it will replace the substring matched by the
current regexp.
A number of special replacement patterns are supported; see the
Specifying a string as the replacement section of
\f[V]String.prototype.replace\f[R].
.IP \[bu] 2
If it\[cq]s a function, it will be invoked for every match and the
return value is used as the replacement text.
The arguments supplied to this function are described in the Specifying
a function as the replacement section of
\f[V]String.prototype.replace\f[R].
.RE
.SS Return value
.PP
A new string, with one, some, or all matches of the pattern replaced by
the specified replacement.
.SH DESCRIPTION
.PP
This method is called internally in \f[V]String.prototype.replace()\f[R]
and \f[V]String.prototype.replaceAll()\f[R] if the \f[V]pattern\f[R]
argument is a \f[V]RegExp\f[R] object.
For example, the following two examples return the same result.
.IP
.nf
\f[C]
\[dq]abc\[dq].replace(/a/, \[dq]A\[dq]);

/a/[Symbol.replace](\[dq]abc\[dq], \[dq]A\[dq]);
\f[R]
.fi
.PP
If the regex is global (with the \f[V]g\f[R] flag), the regex\[cq]s
\f[V]exec()\f[R] method will be repeatedly called until \f[V]exec()\f[R]
returns \f[V]null\f[R].
Otherwise, \f[V]exec()\f[R] would only be called once.
For each \f[V]exec()\f[R] result, the substitution will be prepared
based on the description in \f[V]String.prototype.replace()\f[R].
.PP
Because \f[V]\[at]\[at]replace\f[R] would keep calling \f[V]exec()\f[R]
until it returns \f[V]null\f[R], and \f[V]exec()\f[R] would
automatically reset the regex\[cq]s \f[V]lastIndex\f[R] to 0 when the
last match fails, \f[V]\[at]\[at]replace\f[R] would typically not have
side effects when it exits.
However, when the regex is sticky but not global, \f[V]lastIndex\f[R]
would not be reset.
In this case, each call to \f[V]replace()\f[R] may return a different
result.
.IP
.nf
\f[C]
const re = /a/y;

for (let i = 0; i < 5; i++) {
  console.log(\[dq]aaa\[dq].replace(re, \[dq]b\[dq]), re.lastIndex);
}

// baa 1
// aba 2
// aab 3
// aaa 0
// baa 1
\f[R]
.fi
.PP
When the regex is sticky and global, it would still perform sticky
matches \[em] i.e.\ it would fail to match any occurrences beyond the
\f[V]lastIndex\f[R].
.IP
.nf
\f[C]
console.log(\[dq]aa-a\[dq].replace(/a/gy, \[dq]b\[dq])); // \[dq]bb-a\[dq]
\f[R]
.fi
.PP
If the current match is an empty string, the \f[V]lastIndex\f[R] would
still be advanced \[em] if the regex has the \f[V]u\f[R] flag, it would
advance by one Unicode code point; otherwise, it advances by one UTF-16
code unit.
.IP
.nf
\f[C]
console.log(\[dq]ðŸ˜„\[dq].replace(/(?:)/g, \[dq] \[dq])); // \[dq] \[rs]ud83d \[rs]ude04 \[dq]
console.log(\[dq]ðŸ˜„\[dq].replace(/(?:)/gu, \[dq] \[dq])); // \[dq] ðŸ˜„ \[dq]
\f[R]
.fi
.PP
This method exists for customizing replace behavior in \f[V]RegExp\f[R]
subclasses.
.SH EXAMPLES
.SS Direct call
.PP
This method can be used in almost the same way as
\f[V]String.prototype.replace()\f[R], except the different
\f[V]this\f[R] and the different arguments order.
.IP
.nf
\f[C]
const re = /-/g;
const str = \[dq]2016-01-01\[dq];
const newstr = re[Symbol.replace](str, \[dq].\[dq]);
console.log(newstr); // 2016.01.01
\f[R]
.fi
.SS Using \[at]\[at]replace in subclasses
.PP
Subclasses of \f[V]RegExp\f[R] can override the
\f[V][\[at]\[at]replace]()\f[R] method to modify the default behavior.
.IP
.nf
\f[C]
class MyRegExp extends RegExp {
  constructor(pattern, flags, count) {
    super(pattern, flags);
    this.count = count;
  }
  [Symbol.replace](str, replacement) {
    // Perform \[at]\[at]replace |count| times.
    let result = str;
    for (let i = 0; i < this.count; i++) {
      result = RegExp.prototype[Symbol.replace].call(this, result, replacement);
    }
    return result;
  }
}

const re = new MyRegExp(\[dq]\[rs]\[rs]d\[dq], \[dq]\[dq], 3);
const str = \[dq]01234567\[dq];
const newstr = str.replace(re, \[dq]#\[dq]); // String.prototype.replace calls re[\[at]\[at]replace].
console.log(newstr); // ###34567
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]RegExp.prototype[\[at]\[at]replace]\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-string-and-regexp)
.IP \[bu] 2
\f[V]String.prototype.replace()\f[R]
.IP \[bu] 2
\f[V]String.prototype.replaceAll()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype[\[at]\[at]match]()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype[\[at]\[at]matchAll]()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype[\[at]\[at]search]()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype[\[at]\[at]split]()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype.exec()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype.test()\f[R]
.IP \[bu] 2
\f[V]Symbol.replace\f[R]
