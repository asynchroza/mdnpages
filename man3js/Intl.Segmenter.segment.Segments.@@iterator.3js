.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "Intl.Segmenter.segment.Segments.\[at]\[at]iterator" "JS" "August 25, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Intl.Segmenter.segment.Segments.\[at]\[at]iterator \-
Segments.prototype\[at]\[at]iterator
.SH SYNOPSIS
The \f[B]\f[CB][\[at]\[at]iterator]()\f[B]\f[R] method of
\f[CR]Segments\f[R] instances implements the iterable protocol and
allows \f[CR]Segments\f[R] objects to be consumed by most syntaxes
expecting iterables, such as the spread syntax and \f[CR]for...of\f[R]
loops.
It returns a segments iterator object that yields data about each
segment.
.SH SYNTAX
.IP
.EX
segments[Symbol.iterator]()
.EE
.SS Parameters
None.
.SS Return value
A new iterable iterator object that yields data about each segment.
Each yielded object has the same properties as the object returned by
the \f[CR]containing()\f[R] method.
.SH EXAMPLES
.SS Iteration using for\&...of loop
Note that you seldom need to call this method directly.
The existence of the \f[CR]\[at]\[at]iterator\f[R] method makes
\f[CR]Segments\f[R] objects iterable, and iterating syntaxes like the
\f[CR]for...of\f[R] loop automatically call this method to obtain the
iterator to loop over.
.IP
.EX
const segmenter = new Intl.Segmenter(\[dq]zh\-CN\[dq], { granularity: \[dq]word\[dq] });
const input = \[dq]你好，世界！我爱编程。\[dq];

for (const value of segmenter.segment(input)) {
  console.log(value);
}

/*
{segment: \[aq]你好\[aq], index: 0, input: \[aq]你好，世界！我爱编程。\[aq], isWordLike: true}
{segment: \[aq]，\[aq], index: 2, input: \[aq]你好，世界！我爱编程。\[aq], isWordLike: false}
{segment: \[aq]世界\[aq], index: 3, input: \[aq]你好，世界！我爱编程。\[aq], isWordLike: true}
{segment: \[aq]！\[aq], index: 5, input: \[aq]你好，世界！我爱编程。\[aq], isWordLike: false}
{segment: \[aq]我\[aq], index: 6, input: \[aq]你好，世界！我爱编程。\[aq], isWordLike: true}
{segment: \[aq]爱\[aq], index: 7, input: \[aq]你好，世界！我爱编程。\[aq], isWordLike: true}
{segment: \[aq]编\[aq], index: 8, input: \[aq]你好，世界！我爱编程。\[aq], isWordLike: true}
{segment: \[aq]程\[aq], index: 9, input: \[aq]你好，世界！我爱编程。\[aq], isWordLike: true}
{segment: \[aq]。\[aq], index: 10, input: \[aq]你好，世界！我爱编程。\[aq], isWordLike: false}
*/
.EE
.SS Manually hand\-rolling the iterator
You may still manually call the \f[CR]next()\f[R] method of the returned
iterator object to achieve maximum control over the iteration process.
.IP
.EX
const segmenter = new Intl.Segmenter(\[dq]fr\[dq], { granularity: \[dq]word\[dq] });
const input = \[dq]Moi ? N\[aq]est\-ce pas ?\[dq];
const segments = segmenter.segment(input);
const iterator = segments[Symbol.iterator]();

let result = iterator.next();

while (!result.done) {
  console.log(result.value);
  result = iterator.next();
}

/*
{segment: \[aq]Moi\[aq], index: 0, input: \[dq]Moi ? N\[aq]est\-ce pas ?\[dq], isWordLike: true}
{segment: \[aq] \[aq], index: 3, input: \[dq]Moi ? N\[aq]est\-ce pas ?\[dq], isWordLike: false}
{segment: \[aq]?\[aq], index: 4, input: \[dq]Moi ? N\[aq]est\-ce pas ?\[dq], isWordLike: false}
{segment: \[aq] \[aq], index: 5, input: \[dq]Moi ? N\[aq]est\-ce pas ?\[dq], isWordLike: false}
{segment: \[dq]N\[aq]est\[dq], index: 6, input: \[dq]Moi ? N\[aq]est\-ce pas ?\[dq], isWordLike: true}
{segment: \[aq]\-\[aq], index: 11, input: \[dq]Moi ? N\[aq]est\-ce pas ?\[dq], isWordLike: false}
{segment: \[aq]ce\[aq], index: 12, input: \[dq]Moi ? N\[aq]est\-ce pas ?\[dq], isWordLike: true}
{segment: \[aq] \[aq], index: 14, input: \[dq]Moi ? N\[aq]est\-ce pas ?\[dq], isWordLike: false}
{segment: \[aq]pas\[aq], index: 15, input: \[dq]Moi ? N\[aq]est\-ce pas ?\[dq], isWordLike: true}
{segment: \[aq] \[aq], index: 18, input: \[dq]Moi ? N\[aq]est\-ce pas ?\[dq], isWordLike: false}
{segment: \[aq]?\[aq], index: 19, input: \[dq]Moi ? N\[aq]est\-ce pas ?\[dq], isWordLike: false}
*/
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Intl.Segmenter\f[R]
.IP \[bu] 2
\f[CR]Intl.Segmenter.prototype.segment()\f[R]
.IP \[bu] 2
\f[CR]Symbol.iterator\f[R]
.IP \[bu] 2
Iteration protocols
