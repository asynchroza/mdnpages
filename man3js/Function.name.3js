'\" t
.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Function.name" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]name\f[B]\f[R] data property of a \f[V]Function\f[R]
instance indicates the function\[cq]s name as specified when it was
created, or it may be either \f[V]anonymous\f[R] or \f[V]\[aq]\[aq]\f[R]
(an empty string) for functions created anonymously.
.SH Value
.PP
A string.
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
no
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
yes
T}
.TE
.RS
.PP
\f[B]Note:\f[R] In non-standard, pre-ES2015 implementations the
\f[V]configurable\f[R] attribute was \f[V]false\f[R] as well.
.RE
.SH Description
.PP
The function\[cq]s \f[V]name\f[R] property can be used to identify the
function in debugging tools or error messages.
It has no semantic significance to the language itself.
.PP
The \f[V]name\f[R] property is read-only and cannot be changed by the
assignment operator:
.IP
.nf
\f[C]
function someFunction() {}

someFunction.name = \[dq]otherFunction\[dq];
console.log(someFunction.name); // someFunction
\f[R]
.fi
.PP
To change it, use \f[V]Object.defineProperty()\f[R].
.PP
The \f[V]name\f[R] property is typically inferred from how the function
is defined.
In the following sections, we will describe the various ways in which it
can be inferred.
.SS Function declaration
.PP
The \f[V]name\f[R] property returns the name of a function declaration.
.IP
.nf
\f[C]
function doSomething() {}
doSomething.name; // \[dq]doSomething\[dq]
\f[R]
.fi
.SS Default-exported function declaration
.PP
An \f[V]export default\f[R] declaration exports the function as a
declaration instead of an expression.
If the declaration is anonymous, the name is
\f[V]\[dq]default\[dq]\f[R].
.IP
.nf
\f[C]
// -- someModule.js --
export default function () {}

// -- main.js --
import someModule from \[dq]./someModule.js\[dq];

someModule.name; // \[dq]default\[dq]
\f[R]
.fi
.SS Function constructor
.PP
Functions created with the \f[V]Function()\f[R] constructor have name
\[lq]anonymous\[rq].
.IP
.nf
\f[C]
new Function().name; // \[dq]anonymous\[dq]
\f[R]
.fi
.SS Function expression
.PP
If the function expression is named, that name is used as the
\f[V]name\f[R] property.
.IP
.nf
\f[C]
const someFunction = function someFunctionName() {};
someFunction.name; // \[dq]someFunctionName\[dq]
\f[R]
.fi
.PP
Anonymous function expressions created using the keyword
\f[V]function\f[R] or arrow functions would have \f[V]\[dq]\[dq]\f[R]
(an empty string) as their name.
.IP
.nf
\f[C]
(function () {}).name; // \[dq]\[dq]
(() => {}).name; // \[dq]\[dq]
\f[R]
.fi
.PP
However, such cases are rare \[em] usually, in order to refer to the
expression elsewhere, the function expression is attached to an
identifier when it\[cq]s created (such as in a variable declaration).
In such cases, the name can be inferred, as the following few
subsections demonstrate.
.PP
One practical case where the name cannot be inferred is a function
returned from another function:
.IP
.nf
\f[C]
function getFoo() {
  return () => {};
}
getFoo().name; // \[dq]\[dq]
\f[R]
.fi
.SS Variable declaration and method
.PP
Variables and methods can infer the name of an anonymous function from
its syntactic position.
.IP
.nf
\f[C]
const f = function () {};
const object = {
  someMethod: function () {},
};

console.log(f.name); // \[dq]f\[dq]
console.log(object.someMethod.name); // \[dq]someMethod\[dq]
\f[R]
.fi
.PP
The same applies to assignment:
.IP
.nf
\f[C]
let f;
f = () => {};
f.name; // \[dq]f\[dq]
\f[R]
.fi
.SS Initializer and default value
.PP
Functions in initializers (default values) of destructuring, default
parameters, class fields, etc., will inherit the name of the bound
identifier as their \f[V]name\f[R].
.IP
.nf
\f[C]
const [f = () => {}] = [];
f.name; // \[dq]f\[dq]

const { someMethod: m = () => {} } = {};
m.name; // \[dq]m\[dq]

function foo(f = () => {}) {
  console.log(f.name);
}
foo(); // \[dq]f\[dq]

class Foo {
  static someMethod = () => {};
}
Foo.someMethod.name; // someMethod
\f[R]
.fi
.SS Shorthand method
.IP
.nf
\f[C]
const o = {
  foo() {},
};
o.foo.name; // \[dq]foo\[dq];
\f[R]
.fi
.SS Bound function
.PP
\f[V]Function.prototype.bind()\f[R] produces a function whose name is
\[lq]bound\[rq] plus the function name.
.IP
.nf
\f[C]
function foo() {}
foo.bind({}).name; // \[dq]bound foo\[dq]
\f[R]
.fi
.SS Getter and setter
.PP
When using \f[V]get\f[R] and \f[V]set\f[R] accessor properties,
\[lq]get\[rq] or \[lq]set\[rq] will appear in the function name.
.IP
.nf
\f[C]
const o = {
  get foo() {},
  set foo(x) {},
};

const descriptor = Object.getOwnPropertyDescriptor(o, \[dq]foo\[dq]);
descriptor.get.name; // \[dq]get foo\[dq]
descriptor.set.name; // \[dq]set foo\[dq];
\f[R]
.fi
.SS Class
.PP
A class\[cq]s name follows the same algorithm as function declarations
and expressions.
.IP
.nf
\f[C]
class Foo {}
Foo.name; // \[dq]Foo\[dq]
\f[R]
.fi
.RS
.PP
\f[B]Warning:\f[R] JavaScript will set the function\[cq]s \f[V]name\f[R]
property only if a function does not have an own property called
\f[V]name\f[R].
However, classes\[cq] static members will be set as own properties of
the class constructor function, and thus prevent the built-in
\f[V]name\f[R] from being applied.
See an example below.
.RE
.SS Symbol as function name
.PP
If a \f[V]Symbol\f[R] is used a function name and the symbol has a
description, the method\[cq]s name is the description in square
brackets.
.IP
.nf
\f[C]
const sym1 = Symbol(\[dq]foo\[dq]);
const sym2 = Symbol();

const o = {
  [sym1]() {},
  [sym2]() {},
};

o[sym1].name; // \[dq][foo]\[dq]
o[sym2].name; // \[dq][]\[dq]
\f[R]
.fi
.SS Private property
.PP
Private fields and private methods have the hash (\f[V]#\f[R]) as part
of their names.
.IP
.nf
\f[C]
class Foo {
  #field = () => {};
  #method() {}
  getNames() {
    console.log(this.#field.name);
    console.log(this.#method.name);
  }
}

new Foo().getNames();
// \[dq]#field\[dq]
// \[dq]#method\[dq]
\f[R]
.fi
.SH Examples
.SS Telling the constructor name of an object
.PP
You can use \f[V]obj.constructor.name\f[R] to check the \[lq]class\[rq]
of an object.
.IP
.nf
\f[C]
function Foo() {} // Or: class Foo {}

const fooInstance = new Foo();
console.log(fooInstance.constructor.name); // \[dq]Foo\[dq]
\f[R]
.fi
.PP
However, because static members will become own properties of the class,
we can\[cq]t obtain the class name for virtually any class with a static
method property \f[V]name()\f[R]:
.IP
.nf
\f[C]
class Foo {
  constructor() {}
  static name() {}
}
\f[R]
.fi
.PP
With a \f[V]static name()\f[R] method \f[V]Foo.name\f[R] no longer holds
the actual class name but a reference to the \f[V]name()\f[R] function
object.
Trying to obtain the class of \f[V]fooInstance\f[R] via
\f[V]fooInstance.constructor.name\f[R] won\[cq]t give us the class name
at all, but instead a reference to the static class method.
Example:
.IP
.nf
\f[C]
const fooInstance = new Foo();
console.log(fooInstance.constructor.name); // Æ’ name() {}
\f[R]
.fi
.PP
Due to the existence of static fields, \f[V]name\f[R] may not be a
function either.
.IP
.nf
\f[C]
class Foo {
  static name = 123;
}
console.log(new Foo().constructor.name); // 123
\f[R]
.fi
.PP
If a class has a static property called \f[V]name\f[R], it will also
become \f[I]writable\f[R].
The built-in definition in the absence of a custom static definition is
\f[I]read-only\f[R]:
.IP
.nf
\f[C]
Foo.name = \[dq]Hello\[dq];
console.log(Foo.name); // \[dq]Hello\[dq] if class Foo has a static \[dq]name\[dq] property, but \[dq]Foo\[dq] if not.
\f[R]
.fi
.PP
Therefore you may not rely on the built-in \f[V]name\f[R] property to
always hold a class\[cq]s name.
.SS JavaScript compressors and minifiers
.RS
.PP
\f[B]Warning:\f[R] Be careful when using the \f[V]name\f[R] property
with source-code transformations, such as those carried out by
JavaScript compressors (minifiers) or obfuscators.
These tools are often used as part of a JavaScript build pipeline to
reduce the size of a program prior to deploying it to production.
Such transformations often change a function\[cq]s name at build time.
.RE
.PP
Source code such as:
.IP
.nf
\f[C]
function Foo() {}
const foo = new Foo();

if (foo.constructor.name === \[dq]Foo\[dq]) {
  console.log(\[dq]\[aq]foo\[aq] is an instance of \[aq]Foo\[aq]\[dq]);
} else {
  console.log(\[dq]Oops!\[dq]);
}
\f[R]
.fi
.PP
may be compressed to:
.IP
.nf
\f[C]
function a() {}
const b = new a();
if (b.constructor.name === \[dq]Foo\[dq]) {
  console.log(\[dq]\[aq]foo\[aq] is an instance of \[aq]Foo\[aq]\[dq]);
} else {
  console.log(\[dq]Oops!\[dq]);
}
\f[R]
.fi
.PP
In the uncompressed version, the program runs into the truthy branch and
logs \[lq]`foo' is an instance of `Foo'\[rq] \[em] whereas, in the
compressed version it behaves differently, and runs into the else
branch.
If you rely on the \f[V]name\f[R] property, like in the example above,
make sure your build pipeline doesn\[cq]t change function names, or
don\[cq]t assume a function has a particular name.
.SH See also
.IP \[bu] 2
A polyfill for functions\[cq] \f[V].name\f[R] property is available in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-function)
.IP \[bu] 2
\f[V]Function\f[R]
