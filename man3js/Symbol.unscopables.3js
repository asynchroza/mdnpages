'\" t
.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Symbol.unscopables" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Symbol.unscopables - Symbol.unscopables
.SH SYNOPSIS
.PP
The \f[B]\f[VB]Symbol.unscopables\f[B]\f[R] static data property
represents the well-known symbol \f[V]\[at]\[at]unscopables\f[R].
The \f[V]with\f[R] statement looks up this symbol on the scope object
for a property containing a collection of properties that should not
become bindings within the \f[V]with\f[R] environment.
.SH VALUE
.PP
The well-known symbol \f[V]\[at]\[at]unscopables\f[R].
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
no
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
no
T}
.TE
.SH DESCRIPTION
.PP
The \f[V]\[at]\[at]unscopables\f[R] symbol (accessed via
\f[V]Symbol.unscopables\f[R]) can be defined on any object to exclude
property names from being exposed as lexical variables in \f[V]with\f[R]
environment bindings.
Note that when using strict mode, \f[V]with\f[R] statements are not
available, and this symbol is likely not needed.
.PP
Setting a property of the \f[V]\[at]\[at]unscopables\f[R] object to
\f[V]true\f[R] (or any truthy value) will make the corresponding
property of the \f[V]with\f[R] scope object \f[I]unscopable\f[R] and
therefore won\[cq]t be introduced to the \f[V]with\f[R] body scope.
Setting a property to \f[V]false\f[R] (or any falsy value) will make it
\f[I]scopable\f[R] and thus appear as lexical scope variables.
.PP
When deciding whether \f[V]x\f[R] is unscopable, the entire prototype
chain of the \f[V]\[at]\[at]unscopables\f[R] property is looked up for a
property called \f[V]x\f[R].
This means if you declared \f[V]\[at]\[at]unscopables\f[R] as a plain
object, \f[V]Object.prototype\f[R] properties like \f[V]toString\f[R]
would become unscopable as well, which may cause backward
incompatibility for legacy code assuming those properties are normally
scoped (see an example below).
You are advised to make your custom \f[V]\[at]\[at]unscopables\f[R]
property have \f[V]null\f[R] as its prototype, like
\f[V]Array.prototype[\[at]\[at]unscopables]\f[R] does.
.PP
This protocol is also utilized by DOM APIs, such as
\f[V]Element.prototype.append()\f[R].
.SH EXAMPLES
.SS Scoping in with statements
.PP
The following code works fine in ES5 and below.
However, in ECMAScript 2015 and later, the
\f[V]Array.prototype.keys()\f[R] method was introduced.
That means that inside a \f[V]with\f[R] environment, \[lq]keys\[rq]
would now be the method and not the variable.
That\[cq]s why the \f[V]\[at]\[at]unscopables\f[R] symbol was
introduced.
A built-in \f[V]\[at]\[at]unscopables\f[R] setting is implemented as
\f[V]Array.prototype[\[at]\[at]unscopables]\f[R] to prevent some of the
Array methods being scoped into the \f[V]with\f[R] statement.
.IP
.nf
\f[C]
var keys = [];

with (Array.prototype) {
  keys.push(\[dq]something\[dq]);
}
\f[R]
.fi
.SS Unscopables in objects
.PP
You can also set \f[V]\[at]\[at]unscopables\f[R] for your own objects.
.IP
.nf
\f[C]
const obj = {
  foo: 1,
  bar: 2,
  baz: 3,
};

obj[Symbol.unscopables] = {
  // Make the object have \[ga]null\[ga] prototype to prevent
  // \[ga]Object.prototype\[ga] methods from being unscopable
  __proto__: null,
  // \[ga]foo\[ga] will be scopable
  foo: false,
  // \[ga]bar\[ga] will be unscopable
  bar: true,
  // \[ga]baz\[ga] is omitted; because \[ga]undefined\[ga] is falsy, it is also scopable (default)
};

with (obj) {
  console.log(foo); // 1
  console.log(bar); // ReferenceError: bar is not defined
  console.log(baz); // 3
}
\f[R]
.fi
.SS Avoid using a non-null-prototype object as \[at]\[at]unscopables
.PP
Declaring \f[V]\[at]\[at]unscopables\f[R] as a plain object without
eliminating its prototype may cause subtle bugs.
Consider the following code working before
\f[V]\[at]\[at]unscopables\f[R]:
.IP
.nf
\f[C]
const character = {
  name: \[dq]Yoda\[dq],
  toString: function () {
    return \[dq]Use with statements, you must not\[dq];
  },
};

with (character) {
  console.log(name + \[aq] says: \[dq]\[aq] + toString() + \[aq]\[dq]\[aq]); // Yoda says: \[dq]Use with statements, you must not\[dq]
}
\f[R]
.fi
.PP
To preserve backward compatibility, you decided to add an
\f[V]\[at]\[at]unscopables\f[R] property when adding more properties to
\f[V]character\f[R].
You may na√Øvely do it like:
.PP
\f[B]Bad\f[R]
.IP
.nf
\f[C]
const character = {
  name: \[dq]Yoda\[dq],
  toString: function () {
    return \[dq]Use with statements, you must not\[dq];
  },
  student: \[dq]Luke\[dq],
  [Symbol.unscopables]: {
    // Make \[ga]student\[ga] unscopable
    student: true,
  },
};
\f[R]
.fi
.PP
However, the code above now breaks:
.IP
.nf
\f[C]
with (character) {
  console.log(name + \[aq] says: \[dq]\[aq] + toString() + \[aq]\[dq]\[aq]); // Yoda says: \[dq][object Undefined]\[dq]
}
\f[R]
.fi
.PP
This is because when looking up
\f[V]character[Symbol.unscopables].toString\f[R], it returns
\f[V]Object.prototype.toString()\f[R], which is a truthy value, thus
making the \f[V]toString()\f[R] call in the \f[V]with()\f[R] statement
reference \f[V]globalThis.toString()\f[R] instead \[em] and because
it\[cq]s called without a \f[V]this\f[R], \f[V]this\f[R] is
\f[V]undefined\f[R], making it return \f[V][object Undefined]\f[R].
.PP
Even when the method is not overridden by \f[V]character\f[R], making it
unscopable will change the value of \f[V]this\f[R].
.IP
.nf
\f[C]
const proto = {};
const obj = { __proto__: proto };

with (proto) {
  console.log(isPrototypeOf(obj)); // true; \[ga]isPrototypeOf\[ga] is scoped and \[ga]this\[ga] is \[ga]proto\[ga]
}

proto[Symbol.unscopables] = {};

with (proto) {
  console.log(isPrototypeOf(obj)); // TypeError: Cannot convert undefined or null to object
  // \[ga]isPrototypeOf\[ga] is unscoped and \[ga]this\[ga] is undefined
}
\f[R]
.fi
.PP
To fix this, always make sure \f[V]\[at]\[at]unscopables\f[R] only
contains properties you wish to be unscopable, without
\f[V]Object.prototype\f[R] properties.
.PP
\f[B]Good\f[R]
.IP
.nf
\f[C]
const character = {
  name: \[dq]Yoda\[dq],
  toString: function () {
    return \[dq]Use with statements, you must not\[dq];
  },
  student: \[dq]Luke\[dq],
  [Symbol.unscopables]: {
    // Make the object have \[ga]null\[ga] prototype to prevent
    // \[ga]Object.prototype\[ga] methods from being unscopable
    __proto__: null,
    // Make \[ga]student\[ga] unscopable
    student: true,
  },
};
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
\f[V]Array.prototype[\[at]\[at]unscopables]\f[R]
.IP \[bu] 2
\f[V]with\f[R] statement (not available in Strict mode)
.IP \[bu] 2
\f[V]Element.prototype.append()\f[R]
