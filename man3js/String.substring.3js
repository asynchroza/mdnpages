.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "String.substring" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
String.substring - String.prototype.substring()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]substring()\f[B]\f[R] method returns the part of the
\f[V]string\f[R] from the start index up to and excluding the end index,
or to the end of the string if no end index is supplied.
.SH SYNTAX
.IP
.nf
\f[C]
substring(indexStart)
substring(indexStart, indexEnd)
\f[R]
.fi
.SS Parameters
.TP
\f[B]indexStart\f[R]
The index of the first character to include in the returned substring.
.TP
\f[B]indexEnd\f[R] \f[I](optional)\f[R]
The index of the first character to exclude from the returned substring.
.SS Return value
.PP
A new string containing the specified part of the given string.
.SH DESCRIPTION
.PP
\f[V]substring()\f[R] extracts characters from \f[V]indexStart\f[R] up
to \f[I]but not including\f[R] \f[V]indexEnd\f[R].
In particular:
.IP \[bu] 2
If \f[V]indexEnd\f[R] is omitted, \f[V]substring()\f[R] extracts
characters to the end of the string.
.IP \[bu] 2
If \f[V]indexStart\f[R] is equal to \f[V]indexEnd\f[R],
\f[V]substring()\f[R] returns an empty string.
.IP \[bu] 2
If \f[V]indexStart\f[R] is greater than \f[V]indexEnd\f[R], then the
effect of \f[V]substring()\f[R] is as if the two arguments were swapped;
see example below.
.PP
Any argument value that is less than \f[V]0\f[R] or greater than
\f[V]str.length\f[R] is treated as if it were \f[V]0\f[R] and
\f[V]str.length\f[R], respectively.
.PP
Any argument value that is \f[V]NaN\f[R] is treated as if it were
\f[V]0\f[R].
.SH EXAMPLES
.SS Using substring()
.PP
The following example uses \f[V]substring()\f[R] to display characters
from the string \f[V]\[aq]Mozilla\[aq]\f[R]:
.IP
.nf
\f[C]
const anyString = \[dq]Mozilla\[dq];

console.log(anyString.substring(0, 1)); // \[aq]M\[aq]
console.log(anyString.substring(1, 0)); // \[aq]M\[aq]

console.log(anyString.substring(0, 6)); // \[aq]Mozill\[aq]

console.log(anyString.substring(4)); // \[aq]lla\[aq]
console.log(anyString.substring(4, 7)); // \[aq]lla\[aq]
console.log(anyString.substring(7, 4)); // \[aq]lla\[aq]

console.log(anyString.substring(0, 7)); // \[aq]Mozilla\[aq]
console.log(anyString.substring(0, 10)); // \[aq]Mozilla\[aq]
\f[R]
.fi
.SS Using substring() with length property
.PP
The following example uses the \f[V]substring()\f[R] method and
\f[V]length\f[R] property to extract the last characters of a particular
string.
This method may be easier to remember, given that you don\[cq]t need to
know the starting and ending indices as you would in the above examples.
.IP
.nf
\f[C]
const text = \[dq]Mozilla\[dq];

// Takes 4 last characters of string
console.log(text.substring(text.length - 4)); // prints \[dq]illa\[dq]

// Takes 5 last characters of string
console.log(text.substring(text.length - 5)); // prints \[dq]zilla\[dq]
\f[R]
.fi
.SS The difference between substring() and substr()
.PP
There are subtle differences between the \f[V]substring()\f[R] and
\f[V]substr()\f[R] methods, so you should be careful not to get them
confused.
.IP \[bu] 2
The two parameters of \f[V]substr()\f[R] are \f[V]start\f[R] and
\f[V]length\f[R], while for \f[V]substring()\f[R], they are
\f[V]start\f[R] and \f[V]end\f[R].
.IP \[bu] 2
\f[V]substr()\f[R]\[cq]s \f[V]start\f[R] index will wrap to the end of
the string if it is negative, while \f[V]substring()\f[R] will clamp it
to \f[V]0\f[R].
.IP \[bu] 2
Negative lengths in \f[V]substr()\f[R] are treated as zero, while
\f[V]substring()\f[R] will swap the two indexes if \f[V]end\f[R] is less
than \f[V]start\f[R].
.PP
Furthermore, \f[V]substr()\f[R] is considered a \f[I]legacy feature in
ECMAScript\f[R], so it is best to avoid using it if possible.
.IP
.nf
\f[C]
const text = \[dq]Mozilla\[dq];
console.log(text.substring(2, 5)); // \[dq]zil\[dq]
console.log(text.substr(2, 3)); // \[dq]zil\[dq]
\f[R]
.fi
.SS Differences between substring() and slice()
.PP
The \f[V]substring()\f[R] and \f[V]slice()\f[R] methods are almost
identical, but there are a couple of subtle differences between the two,
especially in the way negative arguments are dealt with.
.PP
The \f[V]substring()\f[R] method swaps its two arguments if
\f[V]indexStart\f[R] is greater than \f[V]indexEnd\f[R], meaning that a
string is still returned.
The \f[V]slice()\f[R] method returns an empty string if this is the
case.
.IP
.nf
\f[C]
const text = \[dq]Mozilla\[dq];
console.log(text.substring(5, 2)); // \[dq]zil\[dq]
console.log(text.slice(5, 2)); // \[dq]\[dq]
\f[R]
.fi
.PP
If either or both of the arguments are negative or \f[V]NaN\f[R], the
\f[V]substring()\f[R] method treats them as if they were \f[V]0\f[R].
.IP
.nf
\f[C]
console.log(text.substring(-5, 2)); // \[dq]Mo\[dq]
console.log(text.substring(-5, -2)); // \[dq]\[dq]
\f[R]
.fi
.PP
\f[V]slice()\f[R] also treats \f[V]NaN\f[R] arguments as \f[V]0\f[R],
but when it is given negative values it counts backwards from the end of
the string to find the indexes.
.IP
.nf
\f[C]
console.log(text.slice(-5, 2)); // \[dq]\[dq]
console.log(text.slice(-5, -2)); // \[dq]zil\[dq]
\f[R]
.fi
.PP
See the \f[V]slice()\f[R] page for more examples with negative numbers.
.SS Replacing a substring within a string
.PP
The following example replaces a substring within a string.
It will replace both individual characters and substrings.
The function call at the end of the example changes the string
\f[V]Brave New World\f[R] to \f[V]Brave New Web\f[R].
.IP
.nf
\f[C]
// Replaces oldS with newS in the string fullS
function replaceString(oldS, newS, fullS) {
  for (let i = 0; i < fullS.length; ++i) {
    if (fullS.substring(i, i + oldS.length) === oldS) {
      fullS =
        fullS.substring(0, i) +
        newS +
        fullS.substring(i + oldS.length, fullS.length);
    }
  }
  return fullS;
}

replaceString(\[dq]World\[dq], \[dq]Web\[dq], \[dq]Brave New World\[dq]);
\f[R]
.fi
.PP
Note that this can result in an infinite loop if \f[V]oldS\f[R] is
itself a substring of \f[V]newS\f[R] \[em] for example, if you attempted
to replace `\f[V]World\f[R]' with `\f[V]OtherWorld\f[R]' here.
.PP
A better method for replacing strings is as follows:
.IP
.nf
\f[C]
function replaceString(oldS, newS, fullS) {
  return fullS.split(oldS).join(newS);
}
\f[R]
.fi
.PP
The code above serves as an example for substring operations.
If you need to replace substrings, most of the time you will want to use
\f[V]String.prototype.replace()\f[R].
.SH SEE ALSO
.IP \[bu] 2
\f[V]String.prototype.substr()\f[R]
.IP \[bu] 2
\f[V]String.prototype.slice()\f[R]
