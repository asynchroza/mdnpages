.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "encodeURI" "JS" "May 4, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
encodeURI - encodeURI()
.SH SYNOPSIS
The \f[B]\f[CB]encodeURI()\f[B]\f[R] function encodes a URI by replacing
each instance of certain characters by one, two, three, or four escape
sequences representing the UTF-8 encoding of the character (will only be
four escape sequences for characters composed of two surrogate
characters).
Compared to \f[CR]encodeURIComponent()\f[R], this function encodes fewer
characters, preserving those that are part of the URI syntax.
.SH SYNTAX
.IP
.EX
encodeURI(uri)
.EE
.SS Parameters
.TP
\f[B]uri\f[R]
A string to be encoded as a URI.
.SS Return value
A new string representing the provided string encoded as a URI.
.SS Exceptions
.TP
\f[B]URIError\f[R]
Thrown if \f[CR]uri\f[R] contains a lone surrogate.
.SH DESCRIPTION
\f[CR]encodeURI()\f[R] is a function property of the global object.
.PP
The \f[CR]encodeURI()\f[R] function escapes characters by UTF-8 code
units, with each octet encoded in the format \f[CR]%XX\f[R], left-padded
with 0 if necessary.
Because lone surrogates in UTF-16 do not encode any valid Unicode
character, they cause \f[CR]encodeURI()\f[R] to throw a
\f[CR]URIError\f[R].
.PP
\f[CR]encodeURI()\f[R] escapes all characters \f[B]except\f[R]:
.IP
.EX
A\[en]Z a\[en]z 0\[en]9 - _ . ! \[ti] * \[aq] ( )

; / ? : \[at] & = + $ , #
.EE
.PP
The characters on the second line are characters that may be part of the
URI syntax, and are only escaped by \f[CR]encodeURIComponent()\f[R].
Both \f[CR]encodeURI()\f[R] and \f[CR]encodeURIComponent()\f[R] do not
encode the characters \f[CR]-.!\[ti]*\[aq]()\f[R], known as
\[lq]unreserved marks\[rq], which do not have a reserved purpose but are
allowed in a URI \[lq]as is\[rq].
(See RFC2396 (https://www.ietf.org/rfc/rfc2396.txt))
.PP
The \f[CR]encodeURI()\f[R] function does not encode characters that have
special meaning (reserved characters) for a URI.
The following example shows all the parts that a URI can possibly
contain.
Note how certain characters are used to signify special meaning:
.IP
.EX
http://username:password\[at]www.example.com:80/path/to/file.php?foo=316&bar=this+has+spaces#anchor
.EE
.SH EXAMPLES
.SS encodeURI() vs.\ encodeURIComponent()
\f[CR]encodeURI()\f[R] differs from \f[CR]encodeURIComponent()\f[R] as
follows:
.IP
.EX
const set1 = \[dq];/?:\[at]&=+$,#\[dq]; // Reserved Characters
const set2 = \[dq]-.!\[ti]*\[aq]()\[dq]; // Unreserved Marks
const set3 = \[dq]ABC abc 123\[dq]; // Alphanumeric Characters + Space

console.log(encodeURI(set1)); // ;/?:\[at]&=+$,#
console.log(encodeURI(set2)); // -.!\[ti]*\[aq]()
console.log(encodeURI(set3)); // ABC%20abc%20123 (the space gets encoded as %20)

console.log(encodeURIComponent(set1)); // %3B%2C%2F%3F%3A%40%26%3D%2B%24%23
console.log(encodeURIComponent(set2)); // -.!\[ti]*\[aq]()
console.log(encodeURIComponent(set3)); // ABC%20abc%20123 (the space gets encoded as %20)
.EE
.PP
Note that \f[CR]encodeURI()\f[R] by itself \f[I]cannot\f[R] form proper
HTTP \f[CR]GET\f[R] and \f[CR]POST\f[R] requests, such as for
\f[CR]XMLHttpRequest\f[R], because \f[CR]&\f[R], \f[CR]+\f[R], and
\f[CR]=\f[R] are not encoded, which are treated as special characters in
\f[CR]GET\f[R] and \f[CR]POST\f[R] requests.
\f[CR]encodeURIComponent()\f[R], however, does encode these characters.
.SS Encoding a lone high surrogate throws
A \f[CR]URIError\f[R] will be thrown if one attempts to encode a
surrogate which is not part of a high-low pair.
For example:
.IP
.EX
// High-low pair OK
encodeURI(\[dq]\[rs]uD800\[rs]uDFFF\[dq]); // \[dq]%F0%90%8F%BF\[dq]

// Lone high surrogate throws \[dq]URIError: malformed URI sequence\[dq]
encodeURI(\[dq]\[rs]uD800\[dq]);

// Lone low surrogate throws \[dq]URIError: malformed URI sequence\[dq]
encodeURI(\[dq]\[rs]uDFFF\[dq]);
.EE
.PP
You can use \f[CR]String.prototype.toWellFormed()\f[R], which replaces
lone surrogates with the Unicode replacement character (U+FFFD), to
avoid this error.
You can also use \f[CR]String.prototype.isWellFormed()\f[R] to check if
a string contains lone surrogates before passing it to
\f[CR]encodeURI()\f[R].
.SS Encoding for RFC3986
The more recent RFC3986 (https://datatracker.ietf.org/doc/html/rfc3986)
makes square brackets reserved (for IPv6) and thus not encoded when
forming something which could be part of a URL (such as a host).
It also reserves !, \[cq], (, ), and *, even though these characters
have no formalized URI delimiting uses.
The following function encodes a string for RFC3986-compliant URL
format.
.IP
.EX
function encodeRFC3986URI(str) {
  return encodeURI(str)
    .replace(/%5B/g, \[dq][\[dq])
    .replace(/%5D/g, \[dq]]\[dq])
    .replace(
      /[!\[aq]()*]/g,
      (c) => \[ga]%${c.charCodeAt(0).toString(16).toUpperCase()}\[ga],
    );
}
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]decodeURI()\f[R]
.IP \[bu] 2
\f[CR]encodeURIComponent()\f[R]
.IP \[bu] 2
\f[CR]decodeURIComponent()\f[R]
