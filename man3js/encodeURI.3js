.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "encodeURI" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]encodeURI()\f[B]\f[R] function encodes a URI by replacing
each instance of certain characters by one, two, three, or four escape
sequences representing the UTF-8 encoding of the character (will only be
four escape sequences for characters composed of two surrogate
characters).
Compared to \f[V]encodeURIComponent()\f[R], this function encodes fewer
characters, preserving those that are part of the URI syntax.
.SH Syntax
.IP
.nf
\f[C]
encodeURI(uri)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]uri\f[R]
.RS 2
.IP \[bu] 2
A string to be encoded as a URI.
.RE
.SS Return value
.PP
A new string representing the provided string encoded as a URI.
.SS Exceptions
.IP \[bu] 2
\f[V]URIError\f[R]
.RS 2
.IP \[bu] 2
Thrown if \f[V]uri\f[R] contains a lone surrogate.
.RE
.SH Description
.PP
\f[V]encodeURI()\f[R] is a function property of the global object.
.PP
The \f[V]encodeURI()\f[R] function escapes characters by UTF-8 code
units, with each octet encoded in the format \f[V]%XX\f[R], left-padded
with 0 if necessary.
Because lone surrogates in UTF-16 do not encode any valid Unicode
character, they cause \f[V]encodeURI()\f[R] to throw a
\f[V]URIError\f[R].
.PP
\f[V]encodeURI()\f[R] escapes all characters \f[B]except\f[R]:
.IP
.nf
\f[C]
A\[en]Z a\[en]z 0\[en]9 - _ . ! \[ti] * \[aq] ( )

; / ? : \[at] & = + $ , #
\f[R]
.fi
.PP
The characters on the second line are characters that may be part of the
URI syntax, and are only escaped by \f[V]encodeURIComponent()\f[R].
Both \f[V]encodeURI()\f[R] and \f[V]encodeURIComponent()\f[R] do not
encode the characters \f[V]-.!\[ti]*\[aq]()\f[R], known as
\[lq]unreserved marks\[rq], which do not have a reserved purpose but are
allowed in a URI \[lq]as is\[rq].
(See RFC2396 (https://www.ietf.org/rfc/rfc2396.txt))
.PP
The \f[V]encodeURI()\f[R] function does not encode characters that have
special meaning (reserved characters) for a URI.
The following example shows all the parts that a URI can possibly
contain.
Note how certain characters are used to signify special meaning:
.IP
.nf
\f[C]
http://username:password\[at]www.example.com:80/path/to/file.php?foo=316&bar=this+has+spaces#anchor
\f[R]
.fi
.SH Examples
.SS encodeURI() vs.\ encodeURIComponent()
.PP
\f[V]encodeURI()\f[R] differs from \f[V]encodeURIComponent()\f[R] as
follows:
.IP
.nf
\f[C]
const set1 = \[dq];/?:\[at]&=+$,#\[dq]; // Reserved Characters
const set2 = \[dq]-.!\[ti]*\[aq]()\[dq]; // Unreserved Marks
const set3 = \[dq]ABC abc 123\[dq]; // Alphanumeric Characters + Space

console.log(encodeURI(set1)); // ;/?:\[at]&=+$,#
console.log(encodeURI(set2)); // -.!\[ti]*\[aq]()
console.log(encodeURI(set3)); // ABC%20abc%20123 (the space gets encoded as %20)

console.log(encodeURIComponent(set1)); // %3B%2C%2F%3F%3A%40%26%3D%2B%24%23
console.log(encodeURIComponent(set2)); // -.!\[ti]*\[aq]()
console.log(encodeURIComponent(set3)); // ABC%20abc%20123 (the space gets encoded as %20)
\f[R]
.fi
.PP
Note that \f[V]encodeURI()\f[R] by itself \f[I]cannot\f[R] form proper
HTTP \f[V]GET\f[R] and \f[V]POST\f[R] requests, such as for
\f[V]XMLHttpRequest\f[R], because \f[V]&\f[R], \f[V]+\f[R], and
\f[V]=\f[R] are not encoded, which are treated as special characters in
\f[V]GET\f[R] and \f[V]POST\f[R] requests.
\f[V]encodeURIComponent()\f[R], however, does encode these characters.
.SS Encoding a lone high surrogate throws
.PP
A \f[V]URIError\f[R] will be thrown if one attempts to encode a
surrogate which is not part of a high-low pair.
For example:
.IP
.nf
\f[C]
// High-low pair OK
encodeURI(\[dq]\[rs]uD800\[rs]uDFFF\[dq]); // \[dq]%F0%90%8F%BF\[dq]

// Lone high surrogate throws \[dq]URIError: malformed URI sequence\[dq]
encodeURI(\[dq]\[rs]uD800\[dq]);

// Lone low surrogate throws \[dq]URIError: malformed URI sequence\[dq]
encodeURI(\[dq]\[rs]uDFFF\[dq]);
\f[R]
.fi
.PP
You can use \f[V]String.prototype.toWellFormed()\f[R], which replaces
lone surrogates with the Unicode replacement character (U+FFFD), to
avoid this error.
You can also use \f[V]String.prototype.isWellFormed()\f[R] to check if a
string contains lone surrogates before passing it to
\f[V]encodeURI()\f[R].
.SS Encoding for RFC3986
.PP
The more recent RFC3986 (https://datatracker.ietf.org/doc/html/rfc3986)
makes square brackets reserved (for IPv6) and thus not encoded when
forming something which could be part of a URL (such as a host).
It also reserves !, \[cq], (, ), and *, even though these characters
have no formalized URI delimiting uses.
The following function encodes a string for RFC3986-compliant URL
format.
.IP
.nf
\f[C]
function encodeRFC3986URI(str) {
  return encodeURI(str)
    .replace(/%5B/g, \[dq][\[dq])
    .replace(/%5D/g, \[dq]]\[dq])
    .replace(
      /[!\[aq]()*]/g,
      (c) => \[ga]%${c.charCodeAt(0).toString(16).toUpperCase()}\[ga],
    );
}
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]decodeURI()\f[R]
.IP \[bu] 2
\f[V]encodeURIComponent()\f[R]
.IP \[bu] 2
\f[V]decodeURIComponent()\f[R]
