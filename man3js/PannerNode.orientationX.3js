.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "PannerNode.orientationX" "JS" "April 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
PannerNode.orientationX \- PannerNode: orientationX property
.SH SYNOPSIS
The \f[B]\f[CB]orientationX\f[B]\f[R] property of the
\f[CR]PannerNode\f[R] interface indicates the X (horizontal) component
of the direction in which the audio source is facing, in a 3D Cartesian
coordinate space.
.PP
The complete vector is defined by the position of the audio source,
given as (\f[CR]positionX\f[R], \f[CR]positionY\f[R],
\f[CR]positionZ\f[R]), and the orientation of the audio source (that is,
the direction in which it\[cq]s facing), given as
(\f[CR]orientationX\f[R], \f[CR]orientationY\f[R],
\f[CR]orientationZ\f[R]).
.PP
Depending on the directionality of the sound (as specified using the
attributes \f[CR]coneInnerAngle\f[R], \f[CR]coneOuterAngle\f[R], and
\f[CR]coneOuterGain\f[R]), the orientation of the sound may alter the
perceived volume of the sound as it\[cq]s being played.
If the sound is pointing toward the listener, it will be louder than if
the sound is pointed away from the listener.
.PP
The \f[CR]AudioParam\f[R] contained by this property is read only;
however, you can still change the value of the parameter by assigning a
new value to its \f[CR]AudioParam.value\f[R] property.
.SH VALUE
An \f[CR]AudioParam\f[R] whose \f[CR]value\f[R] is the X component of
the direction in which the audio source is facing, in 3D Cartesian
coordinate space.
.SH EXAMPLE
In this example, we\[cq]ll demonstrate how changing the orientation
parameters of a \f[CR]PannerNode\f[R] in combination with
\f[CR]coneInnerAngle\f[R] and \f[CR]coneOuterAngle\f[R] affects volume.
To help us visualize how the orientation vector affects, we can use the
\c
.UR https://en.wikipedia.org/wiki/Right-hand_rule
Right\-hand rule
.UE \c
:
[IMAGE: This chart visualizes how the PannerNode orientation vectors
affect the direction of the sound cone.]
This chart visualizes how the PannerNode orientation vectors affect the
direction of the sound cone.
.PP
First, let\[cq]s start by writing a utility function to figure out our
\f[I]orientation vector.\f[R] The X and Z components are always at a 90째
to each other, so we can use the sine and cosine functions, which are
offset by the same amount in radians.
However, normally this would mean the \f[CR]PannerNode\f[R] points to
the \f[B]left\f[R] of the listener at 0째 rotation \[en] since
\f[CR]x = cos(0) = 1\f[R] and \f[CR]z = sin(0) = 0\f[R].
It\[cq]s more useful to offset the angle by \-90째, which means the
\f[CR]PannerNode\f[R] will point \f[B]directly at the listener\f[R] at
0째 rotation.
.IP
.EX
// this utility converts amount of rotation around the Y axis
// (i.e. rotation in the \[aq]horizontal plane\[aq]) to an orientation vector
const yRotationToVector = (degrees) => {
  // convert degrees to radians and offset the angle so 0 points towards the listener
  const radians = (degrees \- 90) * (Math.PI / 180);
  // using cosine and sine here ensures the output values are always normalized
  // i.e. they range between \-1 and 1
  const x = Math.cos(radians);
  const z = Math.sin(radians);

  // we hard\-code the Y component to 0, as Y is the axis of rotation
  return [x, 0, z];
};
.EE
.PP
Now we can create our \f[CR]AudioContext\f[R], an oscillator and a
\f[CR]PannerNode\f[R]:
.IP
.EX
const context = new AudioContext();

const osc = new OscillatorNode(context);
osc.type = \[dq]sawtooth\[dq];

const panner = new PannerNode(context);
panner.panningModel = \[dq]HRTF\[dq];
.EE
.PP
Next, we set up the \f[I]cone\f[R] of our spatialized sound, determining
the area in which it can be heard:
.IP
.EX
// this value determines the size of the area in which the sound volume is constant
// if coneInnerAngle === 30, it means that when the sound is rotated
// by at most 15 (30/2) degrees either direction, the volume won\[aq]t change
panner.coneInnerAngle = 30;
// this value determines the size of the area in which the sound volume decreases gradually
// if coneOuterAngle === 45 and coneInnerAngle === 30, it means that when the sound is rotated
// by between 15 (30/2) and 22.5 (45/2) degrees either direction,
// the volume will decrease gradually
panner.coneOuterAngle = 45;
// this value determines the volume of the sound outside of both inner and outer cone
// setting it to 0 means there is no sound, so we can clearly hear when we leave the cone
// 0 is also the default
panner.coneOuterGain = 0;
// increase the Z position to ensure the cone has an effect
// (otherwise the sound is located at the same position as the listener)
panner.positionZ.setValueAtTime(1, context.currentTime);
.EE
.PP
Having set up the \f[CR]PannerNode\f[R], we can now schedule some
updates to its Y\-axis rotation:
.IP
.EX
// calculate the vector for no rotation
// this means the sound will play at full volume
const [x1, y1, z1] = yRotationToVector(0);
// schedule the no\-rotation vector immediately
panner.orientationX.setValueAtTime(x1, context.currentTime);
panner.orientationY.setValueAtTime(y1, context.currentTime);
panner.orientationZ.setValueAtTime(z1, context.currentTime);

// calculate the vector for \-22.4 degrees
// since our coneOuterAngle is 45, this will just about make the sound audible
// if we set it to +/\-22.5, the sound volume will be 0, as the threshold is exclusive
const [x2, y2, z2] = yRotationToVector(\-22.4);
panner.orientationX.setValueAtTime(x2, context.currentTime + 2);
panner.orientationY.setValueAtTime(y2, context.currentTime + 2);
panner.orientationZ.setValueAtTime(z2, context.currentTime + 2);
.EE
.PP
Finally, let\[cq]s connect all our nodes and start the oscillator!
.IP
.EX
osc.connect(panner).connect(context.destination);

osc.start(0);
.EE
.SH SEE ALSO
.IP \[bu] 2
Using the Web Audio API
.IP \[bu] 2
Web Audio spatialization basics
.IP \[bu] 2
\f[CR]PannerNode\f[R]
