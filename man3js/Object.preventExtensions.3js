.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Object.preventExtensions" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]Object.preventExtensions()\f[B]\f[R] static method
prevents new properties from ever being added to an object
(i.e.\ prevents future extensions to the object).
It also prevents the object\[cq]s prototype from being re-assigned.
.SH Syntax
.IP
.nf
\f[C]
Object.preventExtensions(obj)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]obj\f[R]
.RS 2
.IP \[bu] 2
The object which should be made non-extensible.
.RE
.SS Return value
.PP
The object being made non-extensible.
.SH Description
.PP
An object is extensible if new properties can be added to it.
\f[V]Object.preventExtensions()\f[R] marks an object as no longer
extensible, so that it will never have properties beyond the ones it had
at the time it was marked as non-extensible.
Note that the properties of a non-extensible object, in general, may
still be \f[I]deleted\f[R].
Attempting to add new properties to a non-extensible object will fail,
either silently or, in strict mode, throwing a \f[V]TypeError\f[R].
.PP
Unlike \f[V]Object.seal()\f[R] and \f[V]Object.freeze()\f[R],
\f[V]Object.preventExtensions()\f[R] invokes an intrinsic JavaScript
behavior and cannot be replaced with a composition of several other
operations.
It also has its \f[V]Reflect\f[R] counterpart (which only exists for
intrinsic operations), \f[V]Reflect.preventExtensions()\f[R].
.PP
\f[V]Object.preventExtensions()\f[R] only prevents addition of own
properties.
Properties can still be added to the object prototype.
.PP
This method makes the \f[V][[Prototype]]\f[R] of the target immutable;
any \f[V][[Prototype]]\f[R] re-assignment will throw a
\f[V]TypeError\f[R].
This behavior is specific to the internal \f[V][[Prototype]]\f[R]
property; other properties of the target object will remain mutable.
.PP
There is no way to make an object extensible again once it has been made
non-extensible.
.SH Examples
.SS Using Object.preventExtensions
.IP
.nf
\f[C]
// Object.preventExtensions returns the object
// being made non-extensible.
const obj = {};
const obj2 = Object.preventExtensions(obj);
obj === obj2; // true

// Objects are extensible by default.
const empty = {};
Object.isExtensible(empty); // true

// They can be made un-extensible
Object.preventExtensions(empty);
Object.isExtensible(empty); // false

// Object.defineProperty throws when adding
// a new property to a non-extensible object.
const nonExtensible = { removable: true };
Object.preventExtensions(nonExtensible);
Object.defineProperty(nonExtensible, \[dq]new\[dq], {
  value: 8675309,
}); // throws a TypeError

// In strict mode, attempting to add new properties
// to a non-extensible object throws a TypeError.
function fail() {
  \[dq]use strict\[dq];
  // throws a TypeError
  nonExtensible.newProperty = \[dq]FAIL\[dq];
}
fail();
\f[R]
.fi
.PP
A non-extensible object\[cq]s prototype is immutable:
.IP
.nf
\f[C]
const fixed = Object.preventExtensions({});
// throws a \[aq]TypeError\[aq].
fixed.__proto__ = { oh: \[dq]hai\[dq] };
\f[R]
.fi
.SS Non-object argument
.PP
In ES5, if the argument to this method is not an object (a primitive),
then it will cause a \f[V]TypeError\f[R].
In ES2015, a non-object argument will be returned as-is without any
errors, since primitives are already, by definition, immutable.
.IP
.nf
\f[C]
Object.preventExtensions(1);
// TypeError: 1 is not an object (ES5 code)

Object.preventExtensions(1);
// 1                             (ES2015 code)
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]Object.isExtensible()\f[R]
.IP \[bu] 2
\f[V]Object.seal()\f[R]
.IP \[bu] 2
\f[V]Object.isSealed()\f[R]
.IP \[bu] 2
\f[V]Object.freeze()\f[R]
.IP \[bu] 2
\f[V]Object.isFrozen()\f[R]
.IP \[bu] 2
\f[V]Reflect.preventExtensions()\f[R]
