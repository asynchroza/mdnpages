.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Iterator.drop" "JS" "August 26, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Iterator.drop - Iterator.prototype.drop()
.SH SYNOPSIS
The \f[B]\f[CB]drop()\f[B]\f[R] method of \f[CR]Iterator\f[R] instances
returns a new iterator helper that skips the given number of elements at
the start of this iterator.
.SH SYNTAX
.IP
.EX
drop(limit)
.EE
.SS Parameters
.TP
\f[B]limit\f[R]
The number of elements to drop from the start of the iteration.
.SS Return value
A new iterator helper.
The first time the returned iterator helper\[cq]s \f[CR]next()\f[R]
method is called, the current iterator is immediately advanced by
\f[CR]limit\f[R] elements, and then the next element (the
\f[CR]limit+1\f[R]-th element) is yielded.
The iterator helper then yields the remaining elements one-by-one.
If the current iterator has fewer than \f[CR]limit\f[R] elements, the
new iterator helper will be immediately completed the first time
\f[CR]next()\f[R] is called.
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]limit\f[R] becomes \f[CR]NaN\f[R] or negative when
converted to an integer.
.SH EXAMPLES
.SS Using drop()
The following example creates an iterator that yields terms in the
Fibonacci sequence, starting from the 3rd term by dropping the first two
terms:
.IP
.EX
function* fibonacci() {
  let current = 1;
  let next = 1;
  while (true) {
    yield current;
    [current, next] = [next, current + next];
  }
}

const seq = fibonacci().drop(2);
console.log(seq.next().value); // 2
console.log(seq.next().value); // 3
.EE
.PP
This is equivalent to:
.IP
.EX
const seq = fibonacci();
seq.next();
seq.next();
.EE
.SS Using drop() with a for\&...of loop
\f[CR]drop()\f[R] is most convenient when you are not hand-rolling the
iterator.
Because iterators are also iterable, you can iterate the returned helper
with a \f[CR]for...of\f[R] loop:
.IP
.EX
for (const n of fibonacci().drop(2)) {
  console.log(n);
  if (n > 30) {
    break;
  }
}

// Logs:
// 2
// 3
// 5
// 8
// 13
// 21
// 34
.EE
.SS Combining drop() with take()
You can combine \f[CR]drop()\f[R] with
\f[CR]Iterator.prototype.take()\f[R] to get a slice of an iterator:
.IP
.EX
for (const n of fibonacci().drop(2).take(5)) {
  // Drops the first two elements, then takes the next five
  console.log(n);
}
// Logs:
// 2
// 3
// 5
// 8
// 13

for (const n of fibonacci().take(5).drop(2)) {
  // Takes the first five elements, then drops the first two
  console.log(n);
}
// Logs:
// 2
// 3
// 5
.EE
.SS Lower and upper bounds of drop count
When the \f[CR]limit\f[R] is negative or \f[CR]NaN\f[R], a
\f[CR]RangeError\f[R] is thrown:
.IP
.EX
fibonacci().drop(-1); // RangeError: -1 must be positive
fibonacci().drop(undefined); // RangeError: undefined must be positive
.EE
.PP
When the \f[CR]limit\f[R] is larger than the total number of elements
the iterator can produce (such as \f[CR]Infinity\f[R]), the returned
iterator helper will instantly drop all elements and then be completed
the first time \f[CR]next()\f[R] is called.
If the current iterator is infinite, the returned iterator helper will
never complete.
.IP
.EX
fibonacci().drop(Infinity).next(); // Never ends
new Set([1, 2, 3]).values().drop(Infinity).next(); // { value: undefined, done: true }
new Set([1, 2, 3]).values().drop(4).next(); // { value: undefined, done: true }
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]Iterator.prototype.drop\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#iterator-helpers)
.IP \[bu] 2
\f[CR]Iterator\f[R]
.IP \[bu] 2
\f[CR]Iterator.prototype.take()\f[R]
