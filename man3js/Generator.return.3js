.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Generator.return" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]return()\f[B]\f[R] method of \f[V]Generator\f[R]
instances acts as if a \f[V]return\f[R] statement is inserted in the
generator\[cq]s body at the current suspended position, which finishes
the generator and allows the generator to perform any cleanup tasks when
combined with a \f[V]try...finally\f[R] block.
.SH Syntax
.IP
.nf
\f[C]
generatorObject.return(value)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]value\f[R]
.RS 2
.IP \[bu] 2
The value to return.
.RE
.SS Return value
.PP
An \f[V]Object\f[R] with two properties:
.IP \[bu] 2
\f[V]done\f[R]
.RS 2
.IP \[bu] 2
A boolean value:
.RS 2
.IP \[bu] 2
\f[V]true\f[R] if the generator function\[cq]s control flow has reached
the end.
.IP \[bu] 2
\f[V]false\f[R] if the generator function\[cq]s control flow hasn\[cq]t
reached the end and can produce more values.
This can only happen if the \f[V]return\f[R] is captured in a
\f[V]try...finally\f[R] and there are more \f[V]yield\f[R] expressions
in the \f[V]finally\f[R] block.
.RE
.RE
.IP \[bu] 2
\f[V]value\f[R]
.RS 2
.IP \[bu] 2
The value that is given as an argument, or, if the \f[V]yield\f[R]
expression is wrapped in a \f[V]try...finally\f[R], the value
yielded/returned from the \f[V]finally\f[R] block.
.RE
.SH Description
.PP
The \f[V]return()\f[R] method, when called, can be seen as if a
\f[V]return value;\f[R] statement is inserted in the generator\[cq]s
body at the current suspended position, where \f[V]value\f[R] is the
value passed to the \f[V]return()\f[R] method.
Therefore, in a typical flow, calling \f[V]return(value)\f[R] will
return \f[V]{ done: true, value: value }\f[R].
However, if the \f[V]yield\f[R] expression is wrapped in a
\f[V]try...finally\f[R] block, the control flow doesn\[cq]t exit the
function body, but proceeds to the \f[V]finally\f[R] block instead.
In this case, the value returned may be different, and \f[V]done\f[R]
may even be \f[V]false\f[R], if there are more \f[V]yield\f[R]
expressions within the \f[V]finally\f[R] block.
.SH Examples
.SS Using return()
.PP
The following example shows a simple generator and the \f[V]return\f[R]
method.
.IP
.nf
\f[C]
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const g = gen();

g.next(); // { value: 1, done: false }
g.return(\[dq]foo\[dq]); // { value: \[dq]foo\[dq], done: true }
g.next(); // { value: undefined, done: true }
\f[R]
.fi
.PP
If \f[V]return(value)\f[R] is called on a generator that is already in
\[lq]completed\[rq] state, the generator will remain in
\[lq]completed\[rq] state.
.PP
If no argument is provided, the \f[V]value\f[R] property of the returned
object will be \f[V]undefined\f[R].
If an argument is provided, it will become the value of the
\f[V]value\f[R] property of the returned object, unless the
\f[V]yield\f[R] expression is wrapped in a \f[V]try...finally\f[R].
.IP
.nf
\f[C]
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const g = gen();
g.next(); // { value: 1, done: false }
g.next(); // { value: 2, done: false }
g.next(); // { value: 3, done: false }
g.next(); // { value: undefined, done: true }
g.return(); // { value: undefined, done: true }
g.return(1); // { value: 1, done: true }
\f[R]
.fi
.SS Using return() with try\&...finally
.PP
The fact that the \f[V]return\f[R] method has been called can only be
made known to the generator itself if the \f[V]yield\f[R] expression is
wrapped in a \f[V]try...finally\f[R] block.
.PP
When the \f[V]return\f[R] method is called on a generator that is
suspended within a \f[V]try\f[R] block, execution in the generator
proceeds to the \f[V]finally\f[R] block \[em] since the
\f[V]finally\f[R] block of \f[V]try...finally\f[R] statements always
executes.
.IP
.nf
\f[C]
function* gen() {
  yield 1;
  try {
    yield 2;
    yield 3;
  } finally {
    yield \[dq]cleanup\[dq];
  }
}

const g1 = gen();
g1.next(); // { value: 1, done: false }

// Execution is suspended before the try...finally.
g1.return(\[dq]early return\[dq]); // { value: \[aq]early return\[aq], done: true }

const g2 = gen();
g2.next(); // { value: 1, done: false }
g2.next(); // { value: 2, done: false }

// Execution is suspended within the try...finally.
g2.return(\[dq]early return\[dq]); // { value: \[aq]cleanup\[aq], done: false }

// The completion value is preserved
g2.next(); // { value: \[aq]early return\[aq], done: true }

// Generator is in the completed state
g2.return(\[dq]not so early return\[dq]); // { value: \[aq]not so early return\[aq], done: true }
\f[R]
.fi
.PP
The return value of the finally block can also become the
\f[V]value\f[R] of the result returned from the \f[V]return\f[R] call.
.IP
.nf
\f[C]
function* gen() {
  try {
    yield 1;
  } finally {
    return \[dq]cleanup\[dq];
  }
}

const g1 = gen();
g1.next(); // { value: 1, done: false }
g1.return(\[dq]early return\[dq]); // { value: \[aq]cleanup\[aq], done: true }
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]function*\f[R]
