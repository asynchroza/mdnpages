.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "AnalyserNode.getFloatFrequencyData" "JS" "July 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
AnalyserNode.getFloatFrequencyData \- AnalyserNode:
getFloatFrequencyData() method
.SH SYNOPSIS
The \f[B]\f[CB]getFloatFrequencyData()\f[B]\f[R] method of the
\f[CR]AnalyserNode\f[R] Interface copies the current frequency data into
a \f[CR]Float32Array\f[R] array passed into it.
Each array value is a \f[I]sample\f[R], the magnitude of the signal at a
particular time.
.PP
Each item in the array represents the decibel value for a specific
frequency.
The frequencies are spread linearly from 0 to 1/2 of the sample rate.
For example, for a \f[CR]48000\f[R] Hz sample rate, the last item of the
array will represent the decibel value for \f[CR]24000\f[R] Hz.
.PP
If you need higher performance and don\[cq]t care about precision, you
can use \f[CR]AnalyserNode.getByteFrequencyData()\f[R] instead, which
works on a \f[CR]Uint8Array\f[R].
.SH SYNTAX
.IP
.EX
getFloatFrequencyData(array)
.EE
.SS Parameters
.TP
\f[B]array\f[R]
The \f[CR]Float32Array\f[R] that the frequency domain data will be
copied to.
For any sample which is silent, the value is \f[CR]\-Infinity\f[R].
If the array has fewer elements than the
\f[CR]AnalyserNode.frequencyBinCount\f[R], excess elements are dropped.
If it has more elements than needed, excess elements are ignored.
.SS Return value
None (\f[CR]undefined\f[R]).
.SH EXAMPLES
.IP
.EX
const audioCtx = new AudioContext();
const analyser = audioCtx.createAnalyser();
// Float32Array should be the same length as the frequencyBinCount
const myDataArray = new Float32Array(analyser.frequencyBinCount);
// fill the Float32Array with data returned from getFloatFrequencyData()
analyser.getFloatFrequencyData(myDataArray);
.EE
.SS Drawing a spectrum
The following example shows basic usage of an \f[CR]AudioContext\f[R] to
connect a \f[CR]MediaElementAudioSourceNode\f[R] to an
\f[CR]AnalyserNode\f[R].
While the audio is playing, we collect the frequency data repeatedly
with \f[CR]requestAnimationFrame()\f[R] and draw a \[lq]winamp bar graph
style\[rq] to a \f[CR]<canvas>\f[R] element.
.PP
For more complete applied examples/information, check out our \c
.UR
https://github.com/mdn/webaudio-examples/tree/main/voice-change-o-matic
Voice\-change\-O\-matic
.UE \c
\ demo (see \c
.UR
https://github.com/mdn/webaudio-examples/blob/main/voice-change-o-matic/scripts/app.js#L108-L193
app.js lines 108\[en]193
.UE \c
\ for relevant code).
.IP
.EX
<!doctype html>
<body>
  <script>
    const audioCtx = new AudioContext();

    //Create audio source
    //Here, we use an audio file, but this could also be e.g. microphone input
    const audioEle = new Audio();
    audioEle.src = \[dq]my\-audio.mp3\[dq]; //insert file name here
    audioEle.autoplay = true;
    audioEle.preload = \[dq]auto\[dq];
    const audioSourceNode = audioCtx.createMediaElementSource(audioEle);

    //Create analyser node
    const analyserNode = audioCtx.createAnalyser();
    analyserNode.fftSize = 256;
    const bufferLength = analyserNode.frequencyBinCount;
    const dataArray = new Float32Array(bufferLength);

    //Set up audio node network
    audioSourceNode.connect(analyserNode);
    analyserNode.connect(audioCtx.destination);

    //Create 2D canvas
    const canvas = document.createElement(\[dq]canvas\[dq]);
    canvas.style.position = \[dq]absolute\[dq];
    canvas.style.top = \[dq]0\[dq];
    canvas.style.left = \[dq]0\[dq];
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    document.body.appendChild(canvas);
    const canvasCtx = canvas.getContext(\[dq]2d\[dq]);
    canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

    function draw() {
      //Schedule next redraw
      requestAnimationFrame(draw);

      //Get spectrum data
      analyserNode.getFloatFrequencyData(dataArray);

      //Draw black background
      canvasCtx.fillStyle = \[dq]rgb(0, 0, 0)\[dq];
      canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

      //Draw spectrum
      const barWidth = (canvas.width / bufferLength) * 2.5;
      let posX = 0;
      for (let i = 0; i < bufferLength; i++) {
        const barHeight = (dataArray[i] + 140) * 2;
        canvasCtx.fillStyle =
          \[dq]rgb(\[dq] + Math.floor(barHeight + 100) + \[dq], 50, 50)\[dq];
        canvasCtx.fillRect(
          posX,
          canvas.height \- barHeight / 2,
          barWidth,
          barHeight / 2,
        );
        posX += barWidth + 1;
      }
    }

    draw();
  </script>
</body>
.EE
.SH SEE ALSO
.IP \[bu] 2
Using the Web Audio API
