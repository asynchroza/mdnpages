'\" t
.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Symbol.toPrimitive" "JS" "April 10, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Symbol.toPrimitive - Symbol.toPrimitive
.SH SYNOPSIS
The \f[B]\f[CB]Symbol.toPrimitive\f[B]\f[R] static data property
represents the well-known symbol \f[CR]\[at]\[at]toPrimitive\f[R].
All type coercion algorithms look up this symbol on objects for the
method that accepts a preferred type and returns a primitive
representation of the object, before falling back to using the
object\[cq]s \f[CR]valueOf()\f[R] and \f[CR]toString()\f[R] methods.
.SH VALUE
The well-known symbol \f[CR]\[at]\[at]toPrimitive\f[R].
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
no
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
no
T}
.TE
.SH DESCRIPTION
With the help of the \f[CR]Symbol.toPrimitive\f[R] property (used as a
function value), an object can be converted to a primitive value.
The function is called with a string argument \f[CR]hint\f[R], which
specifies the preferred type of the result primitive value.
The \f[CR]hint\f[R] argument can be one of \f[CR]\[dq]number\[dq]\f[R],
\f[CR]\[dq]string\[dq]\f[R], and \f[CR]\[dq]default\[dq]\f[R].
.PP
The \f[CR]\[dq]number\[dq]\f[R] hint is used by numeric coercion
algorithms.
The \f[CR]\[dq]string\[dq]\f[R] hint is used by the string coercion
algorithm.
The \f[CR]\[dq]default\[dq]\f[R] hint is used by the primitive coercion
algorithm.
The \f[CR]hint\f[R] only acts as a weak signal of preference, and the
implementation is free to ignore it (as
\f[CR]Symbol.prototype[\[at]\[at]toPrimitive]()\f[R] does).
The language does not enforce alignment between the \f[CR]hint\f[R] and
the result type, although \f[CR][\[at]\[at]toPrimitive]()\f[R] must
return a primitive, or a \f[CR]TypeError\f[R] is thrown.
.PP
Objects without the \f[CR]\[at]\[at]toPrimitive\f[R] property are
converted to primitives by calling the \f[CR]valueOf()\f[R] and
\f[CR]toString()\f[R] methods in different orders, which is explained in
more detail in the type coercion section.
\f[CR]\[at]\[at]toPrimitive\f[R] allows full control over the primitive
conversion process.
For example, \f[CR]Date.prototype[\[at]\[at]toPrimitive]\f[R] treats
\f[CR]\[dq]default\[dq]\f[R] as if it\[cq]s \f[CR]\[dq]string\[dq]\f[R]
and calls \f[CR]toString()\f[R] instead of \f[CR]valueOf()\f[R].
\f[CR]Symbol.prototype[\[at]\[at]toPrimitive]\f[R] ignores the hint and
always returns a symbol, which means even in string contexts,
\f[CR]Symbol.prototype.toString()\f[R] won\[cq]t be called, and
\f[CR]Symbol\f[R] objects must always be explicitly converted to strings
through \f[CR]String()\f[R].
.SH EXAMPLES
.SS Modifying primitive values converted from an object
Following example describes how \f[CR]Symbol.toPrimitive\f[R] property
can modify the primitive value converted from an object.
.IP
.EX
// An object without Symbol.toPrimitive property.
const obj1 = {};
console.log(+obj1); // NaN
console.log(\[ga]${obj1}\[ga]); // \[dq][object Object]\[dq]
console.log(obj1 + \[dq]\[dq]); // \[dq][object Object]\[dq]

// An object with Symbol.toPrimitive property.
const obj2 = {
  [Symbol.toPrimitive](hint) {
    if (hint === \[dq]number\[dq]) {
      return 10;
    }
    if (hint === \[dq]string\[dq]) {
      return \[dq]hello\[dq];
    }
    return true;
  },
};
console.log(+obj2); // 10        \[em] hint is \[dq]number\[dq]
console.log(\[ga]${obj2}\[ga]); // \[dq]hello\[dq]   \[em] hint is \[dq]string\[dq]
console.log(obj2 + \[dq]\[dq]); // \[dq]true\[dq]    \[em] hint is \[dq]default\[dq]
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]Symbol.toPrimitive\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-symbol)
.IP \[bu] 2
\f[CR]Date.prototype[\[at]\[at]toPrimitive]()\f[R]
.IP \[bu] 2
\f[CR]Symbol.prototype[\[at]\[at]toPrimitive]()\f[R]
.IP \[bu] 2
\f[CR]Object.prototype.toString()\f[R]
.IP \[bu] 2
\f[CR]Object.prototype.valueOf()\f[R]
