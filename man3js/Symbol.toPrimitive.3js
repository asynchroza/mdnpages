'\" t
.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Symbol.toPrimitive" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]Symbol.toPrimitive\f[B]\f[R] static data property
represents the well-known symbol \f[V]\[at]\[at]toPrimitive\f[R].
All type coercion algorithms look up this symbol on objects for the
method that accepts a preferred type and returns a primitive
representation of the object, before falling back to using the
object\[cq]s \f[V]valueOf()\f[R] and \f[V]toString()\f[R] methods.
.SH Value
.PP
The well-known symbol \f[V]\[at]\[at]toPrimitive\f[R].
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
no
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
no
T}
.TE
.SH Description
.PP
With the help of the \f[V]Symbol.toPrimitive\f[R] property (used as a
function value), an object can be converted to a primitive value.
The function is called with a string argument \f[V]hint\f[R], which
specifies the preferred type of the result primitive value.
The \f[V]hint\f[R] argument can be one of \f[V]\[dq]number\[dq]\f[R],
\f[V]\[dq]string\[dq]\f[R], and \f[V]\[dq]default\[dq]\f[R].
.PP
The \f[V]\[dq]number\[dq]\f[R] hint is used by numeric coercion
algorithms.
The \f[V]\[dq]string\[dq]\f[R] hint is used by the string coercion
algorithm.
The \f[V]\[dq]default\[dq]\f[R] hint is used by the primitive coercion
algorithm.
The \f[V]hint\f[R] only acts as a weak signal of preference, and the
implementation is free to ignore it (as
\f[V]Symbol.prototype[\[at]\[at]toPrimitive]()\f[R] does).
The language does not enforce alignment between the \f[V]hint\f[R] and
the result type, although \f[V][\[at]\[at]toPrimitive]()\f[R] must
return a primitive, or a \f[V]TypeError\f[R] is thrown.
.PP
Objects without the \f[V]\[at]\[at]toPrimitive\f[R] property are
converted to primitives by calling the \f[V]valueOf()\f[R] and
\f[V]toString()\f[R] methods in different orders, which is explained in
more detail in the type coercion section.
\f[V]\[at]\[at]toPrimitive\f[R] allows full control over the primitive
conversion process.
For example, \f[V]Date.prototype[\[at]\[at]toPrimitive]\f[R] treats
\f[V]\[dq]default\[dq]\f[R] as if it\[cq]s \f[V]\[dq]string\[dq]\f[R]
and calls \f[V]toString()\f[R] instead of \f[V]valueOf()\f[R].
\f[V]Symbol.prototype[\[at]\[at]toPrimitive]\f[R] ignores the hint and
always returns a symbol, which means even in string contexts,
\f[V]Symbol.prototype.toString()\f[R] won\[cq]t be called, and
\f[V]Symbol\f[R] objects must always be explicitly converted to strings
through \f[V]String()\f[R].
.SH Examples
.SS Modifying primitive values converted from an object
.PP
Following example describes how \f[V]Symbol.toPrimitive\f[R] property
can modify the primitive value converted from an object.
.IP
.nf
\f[C]
// An object without Symbol.toPrimitive property.
const obj1 = {};
console.log(+obj1); // NaN
console.log(\[ga]${obj1}\[ga]); // \[dq][object Object]\[dq]
console.log(obj1 + \[dq]\[dq]); // \[dq][object Object]\[dq]

// An object with Symbol.toPrimitive property.
const obj2 = {
  [Symbol.toPrimitive](hint) {
    if (hint === \[dq]number\[dq]) {
      return 10;
    }
    if (hint === \[dq]string\[dq]) {
      return \[dq]hello\[dq];
    }
    return true;
  },
};
console.log(+obj2); // 10        \[em] hint is \[dq]number\[dq]
console.log(\[ga]${obj2}\[ga]); // \[dq]hello\[dq]   \[em] hint is \[dq]string\[dq]
console.log(obj2 + \[dq]\[dq]); // \[dq]true\[dq]    \[em] hint is \[dq]default\[dq]
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]Symbol.toPrimitive\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-symbol)
.IP \[bu] 2
\f[V]Date.prototype[\[at]\[at]toPrimitive]()\f[R]
.IP \[bu] 2
\f[V]Symbol.prototype[\[at]\[at]toPrimitive]()\f[R]
.IP \[bu] 2
\f[V]Object.prototype.toString()\f[R]
.IP \[bu] 2
\f[V]Object.prototype.valueOf()\f[R]
