.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.pop" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Array.pop - Array.prototype.pop()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]pop()\f[B]\f[R] method removes the \f[B]last\f[R] element
from an array and returns that element.
This method changes the length of the array.
.SH SYNTAX
.IP
.nf
\f[C]
pop()
\f[R]
.fi
.SS Return value
.PP
The removed element from the array; \f[V]undefined\f[R] if the array is
empty.
.SH DESCRIPTION
.PP
The \f[V]pop()\f[R] method removes the last element from an array and
returns that value to the caller.
If you call \f[V]pop()\f[R] on an empty array, it returns
\f[V]undefined\f[R].
.PP
\f[V]Array.prototype.shift()\f[R] has similar behavior to
\f[V]pop()\f[R], but applied to the first element in an array.
.PP
The \f[V]pop()\f[R] method is a mutating method.
It changes the length and the content of \f[V]this\f[R].
In case you want the value of \f[V]this\f[R] to be the same, but return
a new array with the last element removed, you can use
\f[V]arr.slice(0, -1)\f[R] instead.
.PP
The \f[V]pop()\f[R] method is generic.
It only expects the \f[V]this\f[R] value to have a \f[V]length\f[R]
property and integer-keyed properties.
Although strings are also array-like, this method is not suitable to be
applied on them, as strings are immutable.
.SH EXAMPLES
.SS Removing the last element of an array
.PP
The following code creates the \f[V]myFish\f[R] array containing four
elements, then removes its last element.
.IP
.nf
\f[C]
const myFish = [\[dq]angel\[dq], \[dq]clown\[dq], \[dq]mandarin\[dq], \[dq]sturgeon\[dq]];

const popped = myFish.pop();

console.log(myFish); // [\[aq]angel\[aq], \[aq]clown\[aq], \[aq]mandarin\[aq] ]

console.log(popped); // \[aq]sturgeon\[aq]
\f[R]
.fi
.SS Calling pop() on non-array objects
.PP
The \f[V]pop()\f[R] method reads the \f[V]length\f[R] property of
\f[V]this\f[R].
If the normalized length is 0, \f[V]length\f[R] is set to \f[V]0\f[R]
again (whereas it may be negative or \f[V]undefined\f[R] before).
Otherwise, the property at \f[V]length - 1\f[R] is returned and deleted.
.IP
.nf
\f[C]
const arrayLike = {
  length: 3,
  unrelated: \[dq]foo\[dq],
  2: 4,
};
console.log(Array.prototype.pop.call(arrayLike));
// 4
console.log(arrayLike);
// { length: 2, unrelated: \[aq]foo\[aq] }

const plainObj = {};
// There\[aq]s no length property, so the length is 0
Array.prototype.pop.call(plainObj);
console.log(plainObj);
// { length: 0 }
\f[R]
.fi
.SS Using an object in an array-like fashion
.PP
\f[V]push\f[R] and \f[V]pop\f[R] are intentionally generic, and we can
use that to our advantage \[em] as the following example shows.
.PP
Note that in this example, we don\[cq]t create an array to store a
collection of objects.
Instead, we store the collection on the object itself and use
\f[V]call\f[R] on \f[V]Array.prototype.push\f[R] and
\f[V]Array.prototype.pop\f[R] to trick those methods into thinking
we\[cq]re dealing with an array.
.IP
.nf
\f[C]
const collection = {
  length: 0,
  addElements(...elements) {
    // obj.length will be incremented automatically
    // every time an element is added.

    // Returning what push returns; that is
    // the new value of length property.
    return [].push.call(this, ...elements);
  },
  removeElement() {
    // obj.length will be decremented automatically
    // every time an element is removed.

    // Returning what pop returns; that is
    // the removed element.
    return [].pop.call(this);
  },
};

collection.addElements(10, 20, 30);
console.log(collection.length); // 3
collection.removeElement();
console.log(collection.length); // 2
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[V]Array\f[R]
.IP \[bu] 2
\f[V]Array.prototype.push()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.shift()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.unshift()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.concat()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.splice()\f[R]
