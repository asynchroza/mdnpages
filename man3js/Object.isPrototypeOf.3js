.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Object.isPrototypeOf" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]isPrototypeOf()\f[B]\f[R] method checks if an object
exists in another object\[cq]s prototype chain.
.RS
.PP
\f[B]Note:\f[R] \f[V]isPrototypeOf()\f[R] differs from the
\f[V]instanceof\f[R] operator.
In the expression \f[V]object instanceof AFunction\f[R],
\f[V]object\f[R]\[cq]s prototype chain is checked against
\f[V]AFunction.prototype\f[R], not against \f[V]AFunction\f[R] itself.
.RE
.SH Syntax
.IP
.nf
\f[C]
isPrototypeOf(object)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]object\f[R]
.RS 2
.IP \[bu] 2
The object whose prototype chain will be searched.
.RE
.SS Return value
.PP
A boolean indicating whether the calling object (\f[V]this\f[R]) lies in
the prototype chain of \f[V]object\f[R].
Directly returns \f[V]false\f[R] when \f[V]object\f[R] is not an object
(i.e.\ a primitive).
.SS Errors thrown
.IP \[bu] 2
\f[V]TypeError\f[R]
.RS 2
.IP \[bu] 2
Thrown if \f[V]this\f[R] is \f[V]null\f[R] or \f[V]undefined\f[R]
(because it can\[cq]t be converted to an object).
.RE
.SH Description
.PP
All objects that inherit from \f[V]Object.prototype\f[R] (that is, all
except \f[V]null\f[R]-prototype objects) inherit the
\f[V]isPrototypeOf()\f[R] method.
This method allows you to check whether or not the object exists within
another object\[cq]s prototype chain.
If the \f[V]object\f[R] passed as the parameter is not an object
(i.e.\ a primitive), the method directly returns \f[V]false\f[R].
Otherwise, the \f[V]this\f[R] value is converted to an object, and the
prototype chain of \f[V]object\f[R] is searched for the \f[V]this\f[R]
value, until the end of the chain is reached or the \f[V]this\f[R] value
is found.
.SH Examples
.SS Using isPrototypeOf()
.PP
This example demonstrates that \f[V]Baz.prototype\f[R],
\f[V]Bar.prototype\f[R], \f[V]Foo.prototype\f[R] and
\f[V]Object.prototype\f[R] exist in the prototype chain for object
\f[V]baz\f[R]:
.IP
.nf
\f[C]
class Foo {}
class Bar extends Foo {}
class Baz extends Bar {}

const foo = new Foo();
const bar = new Bar();
const baz = new Baz();

// prototype chains:
// foo: Foo --> Object
// bar: Bar --> Foo --> Object
// baz: Baz --> Bar --> Foo --> Object
console.log(Baz.prototype.isPrototypeOf(baz)); // true
console.log(Baz.prototype.isPrototypeOf(bar)); // false
console.log(Baz.prototype.isPrototypeOf(foo)); // false
console.log(Bar.prototype.isPrototypeOf(baz)); // true
console.log(Bar.prototype.isPrototypeOf(foo)); // false
console.log(Foo.prototype.isPrototypeOf(baz)); // true
console.log(Foo.prototype.isPrototypeOf(bar)); // true
console.log(Object.prototype.isPrototypeOf(baz)); // true
\f[R]
.fi
.PP
The \f[V]isPrototypeOf()\f[R] method \[em] along with the
\f[V]instanceof\f[R] operator \[em] comes in particularly handy if you
have code that can only function when dealing with objects descended
from a specific prototype chain; e.g., to guarantee that certain methods
or properties will be present on that object.
.PP
For example, to execute some code that\[cq]s only safe to run if a
\f[V]baz\f[R] object has \f[V]Foo.prototype\f[R] in its prototype chain,
you can do this:
.IP
.nf
\f[C]
if (Foo.prototype.isPrototypeOf(baz)) {
  // do something safe
}
\f[R]
.fi
.PP
However, \f[V]Foo.prototype\f[R] existing in \f[V]baz\f[R]\[cq]s
prototype chain doesn\[cq]t imply \f[V]baz\f[R] was created using
\f[V]Foo\f[R] as its constructor.
For example, \f[V]baz\f[R] could be directly assigned with
\f[V]Foo.prototype\f[R] as its prototype.
In this case, if your code reads private fields of \f[V]Foo\f[R] from
\f[V]baz\f[R], it would still fail:
.IP
.nf
\f[C]
class Foo {
  #value = \[dq]foo\[dq];
  static getValue(x) {
    return x.#value;
  }
}

const baz = { __proto__: Foo.prototype };

if (Foo.prototype.isPrototypeOf(baz)) {
  console.log(Foo.getValue(baz)); // TypeError: Cannot read private member #value from an object whose class did not declare it
}
\f[R]
.fi
.PP
The same applies to \f[V]instanceof\f[R].
If you need to read private fields in a secure way, offer a branded
check method using \f[V]in\f[R] instead.
.IP
.nf
\f[C]
class Foo {
  #value = \[dq]foo\[dq];
  static getValue(x) {
    return x.#value;
  }
  static isFoo(x) {
    return #value in x;
  }
}

const baz = { __proto__: Foo.prototype };

if (Foo.isFoo(baz)) {
  // Doesn\[aq]t run, because baz is not a Foo
  console.log(Foo.getValue(baz));
}
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]instanceof\f[R]
.IP \[bu] 2
\f[V]Object.getPrototypeOf()\f[R]
.IP \[bu] 2
\f[V]Object.setPrototypeOf()\f[R]
.IP \[bu] 2
Inheritance and the prototype chain
