'\" t
.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "globalThis" "JS" "April 28, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
globalThis - globalThis
.SH SYNOPSIS
The \f[B]\f[CB]globalThis\f[B]\f[R] global property contains the global
\f[CR]this\f[R] value, which is usually akin to the global object.
.SH VALUE
The global \f[CR]this\f[R] object.
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
yes
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
yes
T}
.TE
.RS
.PP
\f[B]Note:\f[R] The \f[CR]globalThis\f[R] property is configurable and
writable so that code authors can hide it when executing untrusted code
and prevent exposing the global object.
.RE
.SH DESCRIPTION
Historically, accessing the global object has required different syntax
in different JavaScript environments.
On the web you can use \f[CR]window\f[R], \f[CR]self\f[R], or
\f[CR]frames\f[R] - but in Web Workers only \f[CR]self\f[R] will work.
In Node.js none of these work, and you must instead use
\f[CR]global\f[R].
The \f[CR]this\f[R] keyword could be used inside functions running in
non\[en]strict mode, but \f[CR]this\f[R] will be \f[CR]undefined\f[R] in
modules and inside functions running in strict mode.
You can also use \f[CR]Function(\[aq]return this\[aq])()\f[R], but
environments that disable \f[CR]eval()\f[R], like CSP in browsers,
prevent use of \f[CR]Function\f[R] in this way.
.PP
The \f[CR]globalThis\f[R] property provides a standard way of accessing
the global \f[CR]this\f[R] value (and hence the global object itself)
across environments.
Unlike similar properties such as \f[CR]window\f[R] and \f[CR]self\f[R],
it\[cq]s guaranteed to work in window and non-window contexts.
In this way, you can access the global object in a consistent manner
without having to know which environment the code is being run in.
To help you remember the name, just remember that in global scope the
\f[CR]this\f[R] value is \f[CR]globalThis\f[R].
.RS
.PP
\f[B]Note:\f[R] \f[CR]globalThis\f[R] is generally the same concept as
the global object (i.e.\ adding properties to \f[CR]globalThis\f[R]
makes them global variables) \[em] this is the case for browsers and
Node \[em] but hosts are allowed to provide a different value for
\f[CR]globalThis\f[R] that\[cq]s unrelated to the global object.
.RE
.SS HTML and the WindowProxy
In many engines \f[CR]globalThis\f[R] will be a reference to the actual
global object, but in web browsers, due to iframe and cross-window
security considerations, it references a \f[CR]Proxy\f[R] around the
actual global object (which you can\[cq]t directly access).
This distinction is rarely relevant in common usage, but important to be
aware of.
.SS Naming
Several other popular name choices such as \f[CR]self\f[R] and
\f[CR]global\f[R] were removed from consideration because of their
potential to break compatibility with existing code.
See the language proposal\[cq]s \[lq]naming\[rq]
document (https://github.com/tc39/proposal-global/blob/master/NAMING.md)
for more details.
.PP
\f[CR]globalThis\f[R] is, quite literally, the global \f[CR]this\f[R]
value.
It\[cq]s the same value as the \f[CR]this\f[R] value in a non-strict
function called without an object.
It\[cq]s also the value of \f[CR]this\f[R] in the global scope of a
script.
.SH EXAMPLES
.SS Search for the global across environments
Usually, the global object does not need to be explicitly specified
\[em] its properties are automatically accessible as global variables.
.IP
.EX
console.log(window.Math === Math); // true
.EE
.PP
However, one case where one needs to explicitly access the global object
is when \f[I]writing\f[R] to it, usually for the purpose of polyfills.
.PP
Prior to \f[CR]globalThis\f[R], the only reliable cross-platform way to
get the global object for an environment was
\f[CR]Function(\[aq]return this\[aq])()\f[R].
However, this causes CSP violations in some settings, so authors would
use a piecewise definition like this (slightly adapted from the original
core-js
source (https://github.com/zloirock/core-js/blob/master/packages/core-js/internals/global.js)):
.IP
.EX
function check(it) {
  // Math is known to exist as a global in every environment.
  return it && it.Math === Math && it;
}

const globalObject =
  check(typeof window === \[dq]object\[dq] && window) ||
  check(typeof self === \[dq]object\[dq] && self) ||
  check(typeof global === \[dq]object\[dq] && global) ||
  // This returns undefined when running in strict mode
  (function () {
    return this;
  })() ||
  Function(\[dq]return this\[dq])();
.EE
.PP
After obtaining the global object, we can define new globals on it.
For example, adding an implementation for \f[CR]Intl\f[R]:
.IP
.EX
if (typeof globalObject.Intl === \[dq]undefined\[dq]) {
  // No Intl in this environment; define our own on the global scope
  Object.defineProperty(globalObject, \[dq]Intl\[dq], {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
.EE
.PP
With \f[CR]globalThis\f[R] available, the additional search for the
global across environments is not necessary anymore:
.IP
.EX
if (typeof globalThis.Intl === \[dq]undefined\[dq]) {
  Object.defineProperty(globalThis, \[dq]Intl\[dq], {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]globalThis\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-globalthis)
.IP \[bu] 2
\f[CR]this\f[R]
