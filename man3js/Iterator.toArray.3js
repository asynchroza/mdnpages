.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Iterator.toArray" "JS" "August 26, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Iterator.toArray - Iterator.prototype.toArray()
.SH SYNOPSIS
The \f[B]\f[CB]toArray()\f[B]\f[R] method of \f[CR]Iterator\f[R]
instances creates a new \f[CR]Array\f[R] instance populated with the
elements yielded from the iterator.
.SH SYNTAX
.IP
.EX
toArray()
.EE
.SS Parameters
None.
.SS Return value
A new \f[CR]Array\f[R] instance containing the elements from the
iterator in the order they were produced.
.SH EXAMPLES
.SS Using toArray()
\f[CR]iterator.toArray()\f[R] is equivalent to
\f[CR]Array.from(iterator)\f[R] and \f[CR][...iterator]\f[R], except
that it\[cq]s easier to chain when multiple iterator helper methods are
involved.
The following example creates an iterator that yields terms in the
Fibonacci sequence, takes the first 10 terms, filters out the odd
numbers, and converts the result to an array:
.IP
.EX
function* fibonacci() {
  let current = 1;
  let next = 1;
  while (true) {
    yield current;
    [current, next] = [next, current + next];
  }
}

const array = fibonacci()
  .take(10)
  .filter((x) => x % 2 === 0)
  .toArray();

console.log(array); // [2, 8, 34]
.EE
.PP
Note that it\[cq]s a good idea to call \f[CR]toArray()\f[R] as a last
step of your processing.
For example, \f[CR]fibonacci().take(10).toArray().filter(...)\f[R] is
less efficient, because iterator helpers are lazy and avoids creating a
temporary array.
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]Iterator.prototype.toArray\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#iterator-helpers)
.IP \[bu] 2
\f[CR]Iterator\f[R]
.IP \[bu] 2
\f[CR]Array.from()\f[R]
