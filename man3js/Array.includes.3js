.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.includes" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]includes()\f[B]\f[R] method determines whether an array
includes a certain value among its entries, returning \f[V]true\f[R] or
\f[V]false\f[R] as appropriate.
.SH Syntax
.IP
.nf
\f[C]
includes(searchElement)
includes(searchElement, fromIndex)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]searchElement\f[R]
.RS 2
.IP \[bu] 2
The value to search for.
.RE
.IP \[bu] 2
\f[V]fromIndex\f[R] \f[I](optional)\f[R]
.RS 2
.IP \[bu] 2
Zero-based index at which to start searching, converted to an integer.
.RS 2
.IP \[bu] 2
Negative index counts back from the end of the array \[em] if
\f[V]fromIndex < 0\f[R], \f[V]fromIndex + array.length\f[R] is used.
However, the array is still searched from front to back in this case.
.IP \[bu] 2
If \f[V]fromIndex < -array.length\f[R] or \f[V]fromIndex\f[R] is
omitted, \f[V]0\f[R] is used, causing the entire array to be searched.
.IP \[bu] 2
If \f[V]fromIndex >= array.length\f[R], the array is not searched and
\f[V]false\f[R] is returned.
.RE
.RE
.SS Return value
.PP
A boolean value which is \f[V]true\f[R] if the value
\f[V]searchElement\f[R] is found within the array (or the part of the
array indicated by the index \f[V]fromIndex\f[R], if specified).
.SH Description
.PP
The \f[V]includes()\f[R] method compares \f[V]searchElement\f[R] to
elements of the array using the SameValueZero algorithm.
Values of zero are all considered to be equal, regardless of sign.
(That is, \f[V]-0\f[R] is equal to \f[V]0\f[R]), but \f[V]false\f[R] is
\f[I]not\f[R] considered to be the same as \f[V]0\f[R].
\f[V]NaN\f[R] can be correctly searched for.
.PP
When used on sparse arrays, the \f[V]includes()\f[R] method iterates
empty slots as if they have the value \f[V]undefined\f[R].
.PP
The \f[V]includes()\f[R] method is generic.
It only expects the \f[V]this\f[R] value to have a \f[V]length\f[R]
property and integer-keyed properties.
.SH Examples
.SS Using includes()
.IP
.nf
\f[C]
[1, 2, 3].includes(2); // true
[1, 2, 3].includes(4); // false
[1, 2, 3].includes(3, 3); // false
[1, 2, 3].includes(3, -1); // true
[1, 2, NaN].includes(NaN); // true
[\[dq]1\[dq], \[dq]2\[dq], \[dq]3\[dq]].includes(3); // false
\f[R]
.fi
.SS fromIndex is greater than or equal to the array length
.PP
If \f[V]fromIndex\f[R] is greater than or equal to the length of the
array, \f[V]false\f[R] is returned.
The array will not be searched.
.IP
.nf
\f[C]
const arr = [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq]];

arr.includes(\[dq]c\[dq], 3); // false
arr.includes(\[dq]c\[dq], 100); // false
\f[R]
.fi
.SS Computed index is less than 0
.PP
If \f[V]fromIndex\f[R] is negative, the computed index is calculated to
be used as a position in the array at which to begin searching for
\f[V]searchElement\f[R].
If the computed index is less than or equal to \f[V]0\f[R], the entire
array will be searched.
.IP
.nf
\f[C]
// array length is 3
// fromIndex is -100
// computed index is 3 + (-100) = -97

const arr = [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq]];

arr.includes(\[dq]a\[dq], -100); // true
arr.includes(\[dq]b\[dq], -100); // true
arr.includes(\[dq]c\[dq], -100); // true
arr.includes(\[dq]a\[dq], -2); // false
\f[R]
.fi
.SS Using includes() on sparse arrays
.PP
You can search for \f[V]undefined\f[R] in a sparse array and get
\f[V]true\f[R].
.IP
.nf
\f[C]
console.log([1, , 3].includes(undefined)); // true
\f[R]
.fi
.SS Calling includes() on non-array objects
.PP
The \f[V]includes()\f[R] method reads the \f[V]length\f[R] property of
\f[V]this\f[R] and then accesses each integer index.
.IP
.nf
\f[C]
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.includes.call(arrayLike, 2));
// true
console.log(Array.prototype.includes.call(arrayLike, 1));
// false
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]Array.prototype.includes\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-array)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[V]Array\f[R]
.IP \[bu] 2
\f[V]Array.prototype.indexOf()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.find()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.findIndex()\f[R]
.IP \[bu] 2
\f[V]TypedArray.prototype.includes()\f[R]
.IP \[bu] 2
\f[V]String.prototype.includes()\f[R]
