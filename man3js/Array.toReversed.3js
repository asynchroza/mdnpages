.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.toReversed" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]toReversed()\f[B]\f[R] method of \f[V]Array\f[R]
instances is the copying counterpart of the \f[V]reverse()\f[R] method.
It returns a new array with the elements in reversed order.
.SH Syntax
.IP
.nf
\f[C]
toReversed()
\f[R]
.fi
.SS Return value
.PP
A new array containing the elements in reversed order.
.SH Description
.PP
The \f[V]toReversed()\f[R] method transposes the elements of the calling
array object in reverse order and returns a new array.
.PP
When used on sparse arrays, the \f[V]toReversed()\f[R] method iterates
empty slots as if they have the value \f[V]undefined\f[R].
.PP
The \f[V]toReversed()\f[R] method is generic.
It only expects the \f[V]this\f[R] value to have a \f[V]length\f[R]
property and integer-keyed properties.
.SH Examples
.SS Reversing the elements in an array
.PP
The following example creates an array \f[V]items\f[R], containing three
elements, then creates a new array that\[cq]s the reverse of
\f[V]items\f[R].
The \f[V]items\f[R] array remains unchanged.
.IP
.nf
\f[C]
const items = [1, 2, 3];
console.log(items); // [1, 2, 3]

const reversedItems = items.toReversed();
console.log(reversedItems); // [3, 2, 1]
console.log(items); // [1, 2, 3]
\f[R]
.fi
.SS Using toReversed() on sparse arrays
.PP
The return value of \f[V]toReversed()\f[R] is never sparse.
Empty slots become \f[V]undefined\f[R] in the returned array.
.IP
.nf
\f[C]
console.log([1, , 3].toReversed()); // [3, undefined, 1]
console.log([1, , 3, 4].toReversed()); // [4, 3, undefined, 1]
\f[R]
.fi
.SS Calling toReversed() on non-array objects
.PP
The \f[V]toReversed()\f[R] method reads the \f[V]length\f[R] property of
\f[V]this\f[R].
It then visits each index between \f[V]length - 1\f[R] and \f[V]0\f[R]
in descending order, and adds the value of that index in the original
array to the corresponding index in the new array.
.IP
.nf
\f[C]
const arrayLike = {
  length: 3,
  unrelated: \[dq]foo\[dq],
  2: 4,
};
console.log(Array.prototype.toReversed.call(arrayLike));
// [4, undefined, undefined]
// The \[aq]0\[aq] and \[aq]1\[aq] indices are not present so they become undefined
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]Array.prototype.toReversed\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#change-array-by-copy)
.IP \[bu] 2
\f[V]Array.prototype.reverse()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.toSorted()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.toSpliced()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.with()\f[R]
.IP \[bu] 2
\f[V]TypedArray.prototype.toReversed()\f[R]
