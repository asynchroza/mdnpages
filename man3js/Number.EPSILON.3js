'\" t
.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Number.EPSILON" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]Number.EPSILON\f[B]\f[R] static data property represents
the difference between 1 and the smallest floating point number greater
than 1.
.SH Value
.PP
2-52, or approximately \f[V]2.2204460492503130808472633361816E-16\f[R].
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
no
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
no
T}
.TE
.SH Description
.PP
\f[V]Number.EPSILON\f[R] is the difference between 1 and the next
greater number representable in the Number format, because double
precision floating point
format (https://en.wikipedia.org/wiki/Double_precision_floating-point_format)
only has 52 bits to represent the mantissa, and the lowest bit has a
significance of 2-52.
.PP
Note that the absolute accuracy of floating numbers decreases as the
number gets larger, because the exponent grows while the mantissa\[cq]s
accuracy stays the same.
\f[V]Number.MIN_VALUE\f[R] is the smallest representable positive
number, which is much smaller than \f[V]Number.EPSILON\f[R].
.PP
Because \f[V]EPSILON\f[R] is a static property of \f[V]Number\f[R], you
always use it as \f[V]Number.EPSILON\f[R], rather than as a property of
a number value.
.SH Examples
.SS Testing equality
.PP
Any number encoding system occupying a finite number of bits, of
whatever base you choose (e.g.\ decimal or binary), will
\f[I]necessarily\f[R] be unable to represent all numbers exactly,
because you are trying to represent an infinite number of points on the
number line using a finite amount of memory.
For example, a base-10 (decimal) system cannot represent 1/3 exactly,
and a base-2 (binary) system cannot represent \f[V]0.1\f[R] exactly.
Thus, for example, \f[V]0.1 + 0.2\f[R] is not exactly equal to
\f[V]0.3\f[R]:
.IP
.nf
\f[C]
console.log(0.1 + 0.2); // 0.30000000000000004
console.log(0.1 + 0.2 === 0.3); // false
\f[R]
.fi
.PP
For this reason, it is often advised that \f[B]floating point numbers
should never be compared with \f[VB]===\f[B]\f[R].
Instead, we can deem two numbers as equal if they are \f[I]close
enough\f[R] to each other.
The \f[V]Number.EPSILON\f[R] constant is usually a reasonable threshold
for errors if the arithmetic is around the magnitude of \f[V]1\f[R],
because \f[V]EPSILON\f[R], in essence, specifies how accurate the number
\[lq]1\[rq] is.
.IP
.nf
\f[C]
function equal(x, y) {
  return Math.abs(x - y) < Number.EPSILON;
}

const x = 0.2;
const y = 0.3;
const z = 0.1;
console.log(equal(x + z, y)); // true
\f[R]
.fi
.PP
However, \f[V]Number.EPSILON\f[R] is inappropriate for any arithmetic
operating on a larger magnitude.
If your data is on the 103 order of magnitude, the decimal part will
have a much smaller accuracy than \f[V]Number.EPSILON\f[R]:
.IP
.nf
\f[C]
function equal(x, y) {
  return Math.abs(x - y) < Number.EPSILON;
}

const x = 1000.1;
const y = 1000.2;
const z = 2000.3;
console.log(x + y); // 2000.3000000000002; error of 10\[ha]-13 instead of 10\[ha]-16
console.log(equal(x + y, z)); // false
\f[R]
.fi
.PP
In this case, a larger tolerance is required.
As the numbers compared have a magnitude of approximately
\f[V]2000\f[R], a multiplier such as \f[V]2000 * Number.EPSILON\f[R]
creates enough tolerance for this instance.
.IP
.nf
\f[C]
function equal(x, y, tolerance = Number.EPSILON) {
  return Math.abs(x - y) < tolerance;
}

const x = 1000.1;
const y = 1000.2;
const z = 2000.3;
console.log(equal(x + y, z, 2000 * Number.EPSILON)); // true
\f[R]
.fi
.PP
In addition to magnitude, it is important to consider the
\f[I]accuracy\f[R] of your input.
For example, if the numbers are collected from a form input and the
input value can only be adjusted by steps of \f[V]0.1\f[R]
(i.e.\ \f[V]<input type=\[dq]number\[dq] step=\[dq]0.1\[dq]>\f[R]), it
usually makes sense to allow a much larger tolerance, such as
\f[V]0.01\f[R], since the data only has a precision of \f[V]0.1\f[R].
.RS
.PP
\f[B]Note:\f[R] Important takeaway: do not simply use
\f[V]Number.EPSILON\f[R] as a threshold for equality testing.
Use a threshold that is appropriate for the magnitude and accuracy of
the numbers you are comparing.
.RE
.SH See also
.IP \[bu] 2
Polyfill of \f[V]Number.EPSILON\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-number)
.IP \[bu] 2
The \f[V]Number\f[R] object it belongs to
