'\" t
.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "Number.EPSILON" "JS" "August 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Number.EPSILON \- Number.EPSILON
.SH SYNOPSIS
The \f[B]\f[CB]Number.EPSILON\f[B]\f[R] static data property represents
the difference between 1 and the smallest floating point number greater
than 1.
.SH VALUE
2\-52, or approximately
\f[CR]2.2204460492503130808472633361816E\-16\f[R].
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
no
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
no
T}
.TE
.SH DESCRIPTION
\f[CR]Number.EPSILON\f[R] is the difference between 1 and the next
greater number representable in the Number format, because \c
.UR https://en.wikipedia.org/wiki/Double_precision_floating-point_format
double precision floating point format
.UE \c
\ only has 52 bits to represent the mantissa, and the lowest bit has a
significance of 2\-52.
.PP
Note that the absolute accuracy of floating numbers decreases as the
number gets larger, because the exponent grows while the mantissa\[cq]s
accuracy stays the same.
\f[CR]Number.MIN_VALUE\f[R] is the smallest representable positive
number, which is much smaller than \f[CR]Number.EPSILON\f[R].
.PP
Because \f[CR]EPSILON\f[R] is a static property of \f[CR]Number\f[R],
you always use it as \f[CR]Number.EPSILON\f[R], rather than as a
property of a number value.
.SH EXAMPLES
.SS Testing equality
Any number encoding system occupying a finite number of bits, of
whatever base you choose (e.g.\ decimal or binary), will
\f[I]necessarily\f[R] be unable to represent all numbers exactly,
because you are trying to represent an infinite number of points on the
number line using a finite amount of memory.
For example, a base\-10 (decimal) system cannot represent 1/3 exactly,
and a base\-2 (binary) system cannot represent \f[CR]0.1\f[R] exactly.
Thus, for example, \f[CR]0.1 + 0.2\f[R] is not exactly equal to
\f[CR]0.3\f[R]:
.IP
.EX
console.log(0.1 + 0.2); // 0.30000000000000004
console.log(0.1 + 0.2 === 0.3); // false
.EE
.PP
For this reason, it is often advised that \f[B]floating point numbers
should never be compared with \f[CB]===\f[B]\f[R].
Instead, we can deem two numbers as equal if they are \f[I]close
enough\f[R] to each other.
The \f[CR]Number.EPSILON\f[R] constant is usually a reasonable threshold
for errors if the arithmetic is around the magnitude of \f[CR]1\f[R],
because \f[CR]EPSILON\f[R], in essence, specifies how accurate the
number \[lq]1\[rq] is.
.IP
.EX
function equal(x, y) {
  return Math.abs(x \- y) < Number.EPSILON;
}

const x = 0.2;
const y = 0.3;
const z = 0.1;
console.log(equal(x + z, y)); // true
.EE
.PP
However, \f[CR]Number.EPSILON\f[R] is inappropriate for any arithmetic
operating on a larger magnitude.
If your data is on the 103 order of magnitude, the decimal part will
have a much smaller accuracy than \f[CR]Number.EPSILON\f[R]:
.IP
.EX
function equal(x, y) {
  return Math.abs(x \- y) < Number.EPSILON;
}

const x = 1000.1;
const y = 1000.2;
const z = 2000.3;
console.log(x + y); // 2000.3000000000002; error of 10\[ha]\-13 instead of 10\[ha]\-16
console.log(equal(x + y, z)); // false
.EE
.PP
In this case, a larger tolerance is required.
As the numbers compared have a magnitude of approximately
\f[CR]2000\f[R], a multiplier such as \f[CR]2000 * Number.EPSILON\f[R]
creates enough tolerance for this instance.
.IP
.EX
function equal(x, y, tolerance = Number.EPSILON) {
  return Math.abs(x \- y) < tolerance;
}

const x = 1000.1;
const y = 1000.2;
const z = 2000.3;
console.log(equal(x + y, z, 2000 * Number.EPSILON)); // true
.EE
.PP
In addition to magnitude, it is important to consider the
\f[I]accuracy\f[R] of your input.
For example, if the numbers are collected from a form input and the
input value can only be adjusted by steps of \f[CR]0.1\f[R]
(i.e.\ \f[CR]<input type=\[dq]number\[dq] step=\[dq]0.1\[dq]>\f[R]), it
usually makes sense to allow a much larger tolerance, such as
\f[CR]0.01\f[R], since the data only has a precision of \f[CR]0.1\f[R].
.RS
.PP
\f[B]Note:\f[R] Important takeaway: do not simply use
\f[CR]Number.EPSILON\f[R] as a threshold for equality testing.
Use a threshold that is appropriate for the magnitude and accuracy of
the numbers you are comparing.
.RE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-number
Polyfill of \f[CR]Number.EPSILON\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]Number\f[R]
