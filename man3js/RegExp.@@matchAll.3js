.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "RegExp.\[at]\[at]matchAll" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB][\[at]\[at]matchAll]()\f[B]\f[R] method of
\f[V]RegExp\f[R] instances specifies how
\f[V]String.prototype.matchAll\f[R] should behave.
.SH Syntax
.IP
.nf
\f[C]
regexp[Symbol.matchAll](str)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]str\f[R]
.RS 2
.IP \[bu] 2
A \f[V]String\f[R] that is a target of the match.
.RE
.SS Return value
.PP
An iterable iterator object (which is not restartable) of matches.
Each match is an array with the same shape as the return value of
\f[V]RegExp.prototype.exec()\f[R].
.SH Description
.PP
This method is called internally in
\f[V]String.prototype.matchAll()\f[R].
For example, the following two examples return the same result.
.IP
.nf
\f[C]
\[dq]abc\[dq].matchAll(/a/g);

/a/g[Symbol.matchAll](\[dq]abc\[dq]);
\f[R]
.fi
.PP
Like \f[V]\[at]\[at]split\f[R], \f[V]\[at]\[at]matchAll\f[R] starts by
using \f[V]\[at]\[at]species\f[R] to construct a new regex, thus
avoiding mutating the original regexp in any way.
\f[V]lastIndex\f[R] starts as the original regex\[cq]s value.
.IP
.nf
\f[C]
const regexp = /[a-c]/g;
regexp.lastIndex = 1;
const str = \[dq]abc\[dq];
Array.from(str.matchAll(regexp), (m) => \[ga]${regexp.lastIndex} ${m[0]}\[ga]);
// [ \[dq]1 b\[dq], \[dq]1 c\[dq] ]
\f[R]
.fi
.PP
The validation that the input is a global regex happens in
\f[V]String.prototype.matchAll()\f[R].
\f[V]\[at]\[at]matchAll\f[R] does not validate the input.
If the regex is not global, the returned iterator yields the
\f[V]exec()\f[R] result once and then returns \f[V]undefined\f[R].
If the regexp is global, each time the returned iterator\[cq]s
\f[V]next()\f[R] method is called, the regex\[cq]s \f[V]exec()\f[R] is
called and the result is yielded.
.PP
When the regex is sticky and global, it will still perform sticky
matches \[em] i.e.\ it will not match any occurrences beyond the
\f[V]lastIndex\f[R].
.IP
.nf
\f[C]
console.log(Array.from(\[dq]ab-c\[dq].matchAll(/[abc]/gy)));
// [ [ \[dq]a\[dq] ], [ \[dq]b\[dq] ] ]
\f[R]
.fi
.PP
If the current match is an empty string, the \f[V]lastIndex\f[R] will
still be advanced.
If the regex has the \f[V]u\f[R] flag, it advances by one Unicode code
point; otherwise, it advances by one UTF-16 code point.
.IP
.nf
\f[C]
console.log(Array.from(\[dq]ðŸ˜„\[dq].matchAll(/(?:)/g)));
// [ [ \[dq]\[dq] ], [ \[dq]\[dq] ], [ \[dq]\[dq] ] ]

console.log(Array.from(\[dq]ðŸ˜„\[dq].matchAll(/(?:)/gu)));
// [ [ \[dq]\[dq] ], [ \[dq]\[dq] ] ]
\f[R]
.fi
.PP
This method exists for customizing the behavior of \f[V]matchAll()\f[R]
in \f[V]RegExp\f[R] subclasses.
.SH Examples
.SS Direct call
.PP
This method can be used in almost the same way as
\f[V]String.prototype.matchAll()\f[R], except for the different value of
\f[V]this\f[R] and the different order of arguments.
.IP
.nf
\f[C]
const re = /[0-9]+/g;
const str = \[dq]2016-01-02\[dq];
const result = re[Symbol.matchAll](str);

console.log(Array.from(result, (x) => x[0]));
// [ \[dq]2016\[dq], \[dq]01\[dq], \[dq]02\[dq] ]
\f[R]
.fi
.SS Using \[at]\[at]matchAll in subclasses
.PP
Subclasses of \f[V]RegExp\f[R] can override the
\f[V][\[at]\[at]matchAll]()\f[R] method to modify the default behavior.
.PP
For example, to return an \f[V]Array\f[R] instead of an iterator:
.IP
.nf
\f[C]
class MyRegExp extends RegExp {
  [Symbol.matchAll](str) {
    const result = RegExp.prototype[Symbol.matchAll].call(this, str);
    return result ? Array.from(result) : null;
  }
}

const re = new MyRegExp(\[dq]([0-9]+)-([0-9]+)-([0-9]+)\[dq], \[dq]g\[dq]);
const str = \[dq]2016-01-02|2019-03-07\[dq];
const result = str.matchAll(re);

console.log(result[0]);
// [ \[dq]2016-01-02\[dq], \[dq]2016\[dq], \[dq]01\[dq], \[dq]02\[dq] ]

console.log(result[1]);
// [ \[dq]2019-03-07\[dq], \[dq]2019\[dq], \[dq]03\[dq], \[dq]07\[dq] ]
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]RegExp.prototype[\[at]\[at]matchAll]\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-string-and-regexp)
.IP \[bu] 2
\f[V]String.prototype.matchAll()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype[\[at]\[at]match]()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype[\[at]\[at]replace]()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype[\[at]\[at]search]()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype[\[at]\[at]split]()\f[R]
.IP \[bu] 2
\f[V]Symbol.matchAll\f[R]
