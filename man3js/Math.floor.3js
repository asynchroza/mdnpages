.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "Math.floor" "JS" "April 12, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Math.floor \- Math.floor()
.SH SYNOPSIS
The \f[B]\f[CB]Math.floor()\f[B]\f[R] static method always rounds down
and returns the largest integer less than or equal to a given number.
.SH SYNTAX
.IP
.EX
Math.floor(x)
.EE
.SS Parameters
.TP
\f[B]x\f[R]
A number.
.SS Return value
The largest integer smaller than or equal to \f[CR]x\f[R].
It\[cq]s the same value as \f[CR]\-Math.ceil(\-x)\f[R].
.SH DESCRIPTION
Because \f[CR]floor()\f[R] is a static method of \f[CR]Math\f[R], you
always use it as \f[CR]Math.floor()\f[R], rather than as a method of a
\f[CR]Math\f[R] object you created (\f[CR]Math\f[R] is not a
constructor).
.SH EXAMPLES
.SS Using Math.floor()
.IP
.EX
Math.floor(\-Infinity); // \-Infinity
Math.floor(\-45.95); // \-46
Math.floor(\-45.05); // \-46
Math.floor(\-0); // \-0
Math.floor(0); // 0
Math.floor(4); // 4
Math.floor(45.05); // 45
Math.floor(45.95); // 45
Math.floor(Infinity); // Infinity
.EE
.SS Decimal adjustment
In this example, we implement a method called \f[CR]decimalAdjust()\f[R]
that is an enhancement method of \f[CR]Math.floor()\f[R],
\f[CR]Math.ceil()\f[R], and \f[CR]Math.round()\f[R].
While the three \f[CR]Math\f[R] functions always adjust the input to the
units digit, \f[CR]decimalAdjust\f[R] accepts an \f[CR]exp\f[R]
parameter that specifies the number of digits to the left of the decimal
point to which the number should be adjusted.
For example, \f[CR]\-1\f[R] means it would leave one digit after the
decimal point (as in \[lq]Ã— 10\[ha]\-1\[rq]).
In addition, it allows you to select the means of adjustment \[em]
\f[CR]round\f[R], \f[CR]floor\f[R], or \f[CR]ceil\f[R] \[em] through the
\f[CR]type\f[R] parameter.
.PP
It does so by multiplying the number by a power of 10, then rounding the
result to the nearest integer, then dividing by the power of 10.
To better preserve precision, it takes advantage of Number\[cq]s
\f[CR]toString()\f[R] method, which represents large or small numbers in
scientific notation (like \f[CR]6.02e23\f[R]).
.IP
.EX
/**
 * Adjusts a number to the specified digit.
 *
 * \[at]param {\[dq]round\[dq] | \[dq]floor\[dq] | \[dq]ceil\[dq]} type The type of adjustment.
 * \[at]param {number} value The number.
 * \[at]param {number} exp The exponent (the 10 logarithm of the adjustment base).
 * \[at]returns {number} The adjusted value.
 */
function decimalAdjust(type, value, exp) {
  type = String(type);
  if (![\[dq]round\[dq], \[dq]floor\[dq], \[dq]ceil\[dq]].includes(type)) {
    throw new TypeError(
      \[dq]The type of decimal adjustment must be one of \[aq]round\[aq], \[aq]floor\[aq], or \[aq]ceil\[aq].\[dq],
    );
  }
  exp = Number(exp);
  value = Number(value);
  if (exp % 1 !== 0 || Number.isNaN(value)) {
    return NaN;
  } else if (exp === 0) {
    return Math[type](value);
  }
  const [magnitude, exponent = 0] = value.toString().split(\[dq]e\[dq]);
  const adjustedValue = Math[type](\[ga]${magnitude}e${exponent \- exp}\[ga]);
  // Shift back
  const [newMagnitude, newExponent = 0] = adjustedValue.toString().split(\[dq]e\[dq]);
  return Number(\[ga]${newMagnitude}e${+newExponent + exp}\[ga]);
}

// Decimal round
const round10 = (value, exp) => decimalAdjust(\[dq]round\[dq], value, exp);
// Decimal floor
const floor10 = (value, exp) => decimalAdjust(\[dq]floor\[dq], value, exp);
// Decimal ceil
const ceil10 = (value, exp) => decimalAdjust(\[dq]ceil\[dq], value, exp);

// Round
round10(55.55, \-1); // 55.6
round10(55.549, \-1); // 55.5
round10(55, 1); // 60
round10(54.9, 1); // 50
round10(\-55.55, \-1); // \-55.5
round10(\-55.551, \-1); // \-55.6
round10(\-55, 1); // \-50
round10(\-55.1, 1); // \-60
// Floor
floor10(55.59, \-1); // 55.5
floor10(59, 1); // 50
floor10(\-55.51, \-1); // \-55.6
floor10(\-51, 1); // \-60
// Ceil
ceil10(55.51, \-1); // 55.6
ceil10(51, 1); // 60
ceil10(\-55.59, \-1); // \-55.5
ceil10(\-59, 1); // \-50
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Math.abs()\f[R]
.IP \[bu] 2
\f[CR]Math.ceil()\f[R]
.IP \[bu] 2
\f[CR]Math.round()\f[R]
.IP \[bu] 2
\f[CR]Math.sign()\f[R]
.IP \[bu] 2
\f[CR]Math.trunc()\f[R]
