.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Math.floor" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Math.floor - Math.floor()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]Math.floor()\f[B]\f[R] static method always rounds down
and returns the largest integer less than or equal to a given number.
.SH SYNTAX
.IP
.nf
\f[C]
Math.floor(x)
\f[R]
.fi
.SS Parameters
.TP
\f[B]x\f[R]
A number.
.SS Return value
.PP
The largest integer smaller than or equal to \f[V]x\f[R].
It\[cq]s the same value as \f[V]-Math.ceil(-x)\f[R].
.SH DESCRIPTION
.PP
Because \f[V]floor()\f[R] is a static method of \f[V]Math\f[R], you
always use it as \f[V]Math.floor()\f[R], rather than as a method of a
\f[V]Math\f[R] object you created (\f[V]Math\f[R] is not a constructor).
.SH EXAMPLES
.SS Using Math.floor()
.IP
.nf
\f[C]
Math.floor(-Infinity); // -Infinity
Math.floor(-45.95); // -46
Math.floor(-45.05); // -46
Math.floor(-0); // -0
Math.floor(0); // 0
Math.floor(4); // 4
Math.floor(45.05); // 45
Math.floor(45.95); // 45
Math.floor(Infinity); // Infinity
\f[R]
.fi
.SS Decimal adjustment
.PP
In this example, we implement a method called \f[V]decimalAdjust()\f[R]
that is an enhancement method of \f[V]Math.floor()\f[R],
\f[V]Math.ceil()\f[R], and \f[V]Math.round()\f[R].
While the three \f[V]Math\f[R] functions always adjust the input to the
units digit, \f[V]decimalAdjust\f[R] accepts an \f[V]exp\f[R] parameter
that specifies the number of digits to the left of the decimal point to
which the number should be adjusted.
For example, \f[V]-1\f[R] means it would leave one digit after the
decimal point (as in \[lq]Ã— 10-1\[rq]).
In addition, it allows you to select the means of adjustment \[em]
\f[V]round\f[R], \f[V]floor\f[R], or \f[V]ceil\f[R] \[em] through the
\f[V]type\f[R] parameter.
.PP
It does so by multiplying the number by a power of 10, then rounding the
result to the nearest integer, then dividing by the power of 10.
To better preserve precision, it takes advantage of Number\[cq]s
\f[V]toString()\f[R] method, which represents large or small numbers in
scientific notation (like \f[V]6.02e23\f[R]).
.IP
.nf
\f[C]
/**
 * Adjusts a number to the specified digit.
 *
 * \[at]param {\[dq]round\[dq] | \[dq]floor\[dq] | \[dq]ceil\[dq]} type The type of adjustment.
 * \[at]param {number} value The number.
 * \[at]param {number} exp The exponent (the 10 logarithm of the adjustment base).
 * \[at]returns {number} The adjusted value.
 */
function decimalAdjust(type, value, exp) {
  type = String(type);
  if (![\[dq]round\[dq], \[dq]floor\[dq], \[dq]ceil\[dq]].includes(type)) {
    throw new TypeError(
      \[dq]The type of decimal adjustment must be one of \[aq]round\[aq], \[aq]floor\[aq], or \[aq]ceil\[aq].\[dq],
    );
  }
  exp = Number(exp);
  value = Number(value);
  if (exp % 1 !== 0 || Number.isNaN(value)) {
    return NaN;
  } else if (exp === 0) {
    return Math[type](value);
  }
  const [magnitude, exponent = 0] = value.toString().split(\[dq]e\[dq]);
  const adjustedValue = Math[type](\[ga]${magnitude}e${exponent - exp}\[ga]);
  // Shift back
  const [newMagnitude, newExponent = 0] = adjustedValue.toString().split(\[dq]e\[dq]);
  return Number(\[ga]${newMagnitude}e${+newExponent + exp}\[ga]);
}

// Decimal round
const round10 = (value, exp) => decimalAdjust(\[dq]round\[dq], value, exp);
// Decimal floor
const floor10 = (value, exp) => decimalAdjust(\[dq]floor\[dq], value, exp);
// Decimal ceil
const ceil10 = (value, exp) => decimalAdjust(\[dq]ceil\[dq], value, exp);

// Round
round10(55.55, -1); // 55.6
round10(55.549, -1); // 55.5
round10(55, 1); // 60
round10(54.9, 1); // 50
round10(-55.55, -1); // -55.5
round10(-55.551, -1); // -55.6
round10(-55, 1); // -50
round10(-55.1, 1); // -60
// Floor
floor10(55.59, -1); // 55.5
floor10(59, 1); // 50
floor10(-55.51, -1); // -55.6
floor10(-51, 1); // -60
// Ceil
ceil10(55.51, -1); // 55.6
ceil10(51, 1); // 60
ceil10(-55.59, -1); // -55.5
ceil10(-59, 1); // -50
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
\f[V]Math.abs()\f[R]
.IP \[bu] 2
\f[V]Math.ceil()\f[R]
.IP \[bu] 2
\f[V]Math.round()\f[R]
.IP \[bu] 2
\f[V]Math.sign()\f[R]
.IP \[bu] 2
\f[V]Math.trunc()\f[R]
