.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "Promise.catch" "JS" "December 29, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Promise.catch \- Promise.prototype.catch()
.SH SYNOPSIS
The \f[B]\f[CB]catch()\f[B]\f[R] method of \f[CR]Promise\f[R] instances
schedules a function to be called when the promise is rejected.
It immediately returns an equivalent \f[CR]Promise\f[R] object, allowing
you to chain calls to other promise methods.
It is a shortcut for
\f[CR]Promise.prototype.then(undefined, onRejected)\f[R].
.SH SYNTAX
.IP
.EX
promiseInstance.catch(onRejected)
.EE
.SS Parameters
.TP
\f[B]onRejected\f[R]
A function to asynchronously execute when this promise becomes rejected.
Its return value becomes the fulfillment value of the promise returned
by \f[CR]catch()\f[R].
The function is called with the following arguments:
.RS
.TP
\f[B]reason\f[R]
The value that the promise was rejected with.
.RE
.SS Return value
Returns a new \f[CR]Promise\f[R].
This new promise is always pending when returned, regardless of the
current promise\[cq]s status.
If \f[CR]onRejected\f[R] is called, the returned promise will resolve
based on the return value of this call, or reject with the thrown error
from this call.
If the current promise fulfills, \f[CR]onRejected\f[R] is not called and
the returned promise fulfills to the same value.
.SH DESCRIPTION
The \f[CR]catch\f[R] method is used for error handling in promise
composition.
Since it returns a \f[CR]Promise\f[R], it can be chained in the same way
as its sister method, \f[CR]then()\f[R].
.PP
If a promise becomes rejected, and there are no rejection handlers to
call (a handler can be attached through any of \f[CR]then()\f[R],
\f[CR]catch()\f[R], or \f[CR]finally()\f[R]), then the rejection event
is surfaced by the host.
In the browser, this results in an \f[CR]unhandledrejection\f[R] event.
If a handler is attached to a rejected promise whose rejection has
already caused an unhandled rejection event, then another
\f[CR]rejectionhandled\f[R] event is fired.
.PP
\f[CR]catch()\f[R] internally calls \f[CR]then()\f[R] on the object upon
which it was called, passing \f[CR]undefined\f[R] and
\f[CR]onRejected\f[R] as arguments.
The value of that call is directly returned.
This is observable if you wrap the methods.
.IP
.EX
// overriding original Promise.prototype.then/catch just to add some logs
((Promise) => {
  const originalThen = Promise.prototype.then;
  const originalCatch = Promise.prototype.catch;

  Promise.prototype.then = function (...args) {
    console.log(\[dq]Called .then on %o with arguments: %o\[dq], this, args);
    return originalThen.apply(this, args);
  };
  Promise.prototype.catch = function (...args) {
    console.error(\[dq]Called .catch on %o with arguments: %o\[dq], this, args);
    return originalCatch.apply(this, args);
  };
})(Promise);

// calling catch on an already resolved promise
Promise.resolve().catch(function XXX() {});

// Logs:
// Called .catch on Promise{} with arguments: Arguments{1} [0: function XXX()]
// Called .then on Promise{} with arguments: Arguments{2} [0: undefined, 1: function XXX()]
.EE
.PP
This means that passing \f[CR]undefined\f[R] still causes the returned
promise to be rejected, and you have to pass a function to prevent the
final promise from being rejected.
.PP
Because \f[CR]catch()\f[R] just calls \f[CR]then()\f[R], it supports
subclassing.
.RS
.PP
\f[B]Note:\f[R] The examples below are throwing instances of
\f[CR]Error\f[R].
As with synchronous \f[CR]throw\f[R] statements, this is considered a
good practice; otherwise, the part doing the catching would have to
perform checks to see if the argument was a string or an error, and you
might lose valuable information such as stack traces.
.RE
.SH EXAMPLES
.SS Using and chaining the catch() method
.IP
.EX
const p1 = new Promise((resolve, reject) => {
  resolve(\[dq]Success\[dq]);
});

p1.then((value) => {
  console.log(value); // \[dq]Success!\[dq]
  throw new Error(\[dq]oh, no!\[dq]);
})
  .catch((e) => {
    console.error(e.message); // \[dq]oh, no!\[dq]
  })
  .then(
    () => console.log(\[dq]after a catch the chain is restored\[dq]), // \[dq]after a catch the chain is restored\[dq]
    () => console.log(\[dq]Not fired due to the catch\[dq]),
  );

// The following behaves the same as above
p1.then((value) => {
  console.log(value); // \[dq]Success!\[dq]
  return Promise.reject(\[dq]oh, no!\[dq]);
})
  .catch((e) => {
    console.error(e); // \[dq]oh, no!\[dq]
  })
  .then(
    () => console.log(\[dq]after a catch the chain is restored\[dq]), // \[dq]after a catch the chain is restored\[dq]
    () => console.log(\[dq]Not fired due to the catch\[dq]),
  );
.EE
.SS Gotchas when throwing errors
Throwing an error will call the \f[CR]catch()\f[R] method most of the
time:
.IP
.EX
const p1 = new Promise((resolve, reject) => {
  throw new Error(\[dq]Uh\-oh!\[dq]);
});

p1.catch((e) => {
  console.error(e); // \[dq]Uh\-oh!\[dq]
});
.EE
.PP
Errors thrown inside asynchronous functions will act like uncaught
errors:
.IP
.EX
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    throw new Error(\[dq]Uncaught Exception!\[dq]);
  }, 1000);
});

p2.catch((e) => {
  console.error(e); // This is never called
});
.EE
.PP
Errors thrown after \f[CR]resolve\f[R] is called will be silenced:
.IP
.EX
const p3 = new Promise((resolve, reject) => {
  resolve();
  throw new Error(\[dq]Silenced Exception!\[dq]);
});

p3.catch((e) => {
  console.error(e); // This is never called
});
.EE
.SS catch() is not called if the promise is fulfilled
.IP
.EX
// Create a promise which would not call onReject
const p1 = Promise.resolve(\[dq]calling next\[dq]);

const p2 = p1.catch((reason) => {
  // This is never called
  console.error(\[dq]catch p1!\[dq]);
  console.error(reason);
});

p2.then(
  (value) => {
    console.log(\[dq]next promise\[aq]s onFulfilled\[dq]);
    console.log(value); // calling next
  },
  (reason) => {
    console.log(\[dq]next promise\[aq]s onRejected\[dq]);
    console.log(reason);
  },
);
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Promise\f[R]
.IP \[bu] 2
\f[CR]Promise.prototype.then()\f[R]
.IP \[bu] 2
\f[CR]Promise.prototype.finally()\f[R]
