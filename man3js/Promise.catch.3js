.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Promise.catch" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Promise.catch - Promise.prototype.catch()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]catch()\f[B]\f[R] method of \f[V]Promise\f[R] instances
schedules a function to be called when the promise is rejected.
It immediately returns an equivalent \f[V]Promise\f[R] object, allowing
you to chain calls to other promise methods.
It is a shortcut for
\f[V]Promise.prototype.then(undefined, onRejected)\f[R].
.SH SYNTAX
.IP
.nf
\f[C]
catch(onRejected)
\f[R]
.fi
.SS Parameters
.TP
\f[B]onRejected\f[R]
A function to asynchronously execute when this promise becomes rejected.
Its return value becomes the fulfillment value of the promise returned
by \f[V]catch()\f[R].
The function is called with the following arguments:
.RS
.TP
\f[B]reason\f[R]
The value that the promise was rejected with.
.RE
.SS Return value
.PP
Returns a new \f[V]Promise\f[R].
This new promise is always pending when returned, regardless of the
current promise\[cq]s status.
It\[cq]s eventually rejected if \f[V]onRejected\f[R] throws an error or
returns a Promise which is itself rejected; otherwise, it\[cq]s
eventually fulfilled.
.SH DESCRIPTION
.PP
The \f[V]catch\f[R] method is used for error handling in promise
composition.
Since it returns a \f[V]Promise\f[R], it can be chained in the same way
as its sister method, \f[V]then()\f[R].
.PP
If a promise becomes rejected, and there are no rejection handlers to
call (a handler can be attached through any of \f[V]then()\f[R],
\f[V]catch()\f[R], or \f[V]finally()\f[R]), then the rejection event is
surfaced by the host.
In the browser, this results in an \f[V]unhandledrejection\f[R] event.
If a handler is attached to a rejected promise whose rejection has
already caused an unhandled rejection event, then another
\f[V]rejectionhandled\f[R] event is fired.
.PP
\f[V]catch()\f[R] internally calls \f[V]then()\f[R] on the object upon
which it was called, passing \f[V]undefined\f[R] and
\f[V]onRejected\f[R] as arguments.
The value of that call is directly returned.
This is observable if you wrap the methods.
.IP
.nf
\f[C]
// overriding original Promise.prototype.then/catch just to add some logs
((Promise) => {
  const originalThen = Promise.prototype.then;
  const originalCatch = Promise.prototype.catch;

  Promise.prototype.then = function (...args) {
    console.log(\[dq]Called .then on %o with arguments: %o\[dq], this, args);
    return originalThen.apply(this, args);
  };
  Promise.prototype.catch = function (...args) {
    console.error(\[dq]Called .catch on %o with arguments: %o\[dq], this, args);
    return originalCatch.apply(this, args);
  };
})(Promise);

// calling catch on an already resolved promise
Promise.resolve().catch(function XXX() {});

// Logs:
// Called .catch on Promise{} with arguments: Arguments{1} [0: function XXX()]
// Called .then on Promise{} with arguments: Arguments{2} [0: undefined, 1: function XXX()]
\f[R]
.fi
.PP
This means that passing \f[V]undefined\f[R] still causes the returned
promise to be rejected, and you have to pass a function to prevent the
final promise from being rejected.
.PP
Because \f[V]catch()\f[R] just calls \f[V]then()\f[R], it supports
subclassing.
.RS
.PP
\f[B]Note:\f[R] The examples below are throwing instances of
\f[V]Error\f[R].
As with synchronous \f[V]throw\f[R] statements, this is considered a
good practice; otherwise, the part doing the catching would have to
perform checks to see if the argument was a string or an error, and you
might lose valuable information such as stack traces.
.RE
.SH EXAMPLES
.SS Using and chaining the catch() method
.IP
.nf
\f[C]
const p1 = new Promise((resolve, reject) => {
  resolve(\[dq]Success\[dq]);
});

p1.then((value) => {
  console.log(value); // \[dq]Success!\[dq]
  throw new Error(\[dq]oh, no!\[dq]);
})
  .catch((e) => {
    console.error(e.message); // \[dq]oh, no!\[dq]
  })
  .then(
    () => console.log(\[dq]after a catch the chain is restored\[dq]),
    () => console.log(\[dq]Not fired due to the catch\[dq]),
  );

// The following behaves the same as above
p1.then((value) => {
  console.log(value); // \[dq]Success!\[dq]
  return Promise.reject(\[dq]oh, no!\[dq]);
})
  .catch((e) => {
    console.error(e); // \[dq]oh, no!\[dq]
  })
  .then(
    () => console.log(\[dq]after a catch the chain is restored\[dq]),
    () => console.log(\[dq]Not fired due to the catch\[dq]),
  );
\f[R]
.fi
.SS Gotchas when throwing errors
.PP
Throwing an error will call the \f[V]catch()\f[R] method most of the
time:
.IP
.nf
\f[C]
const p1 = new Promise((resolve, reject) => {
  throw new Error(\[dq]Uh-oh!\[dq]);
});

p1.catch((e) => {
  console.error(e); // \[dq]Uh-oh!\[dq]
});
\f[R]
.fi
.PP
Errors thrown inside asynchronous functions will act like uncaught
errors:
.IP
.nf
\f[C]
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    throw new Error(\[dq]Uncaught Exception!\[dq]);
  }, 1000);
});

p2.catch((e) => {
  console.error(e); // This is never called
});
\f[R]
.fi
.PP
Errors thrown after \f[V]resolve\f[R] is called will be silenced:
.IP
.nf
\f[C]
const p3 = new Promise((resolve, reject) => {
  resolve();
  throw new Error(\[dq]Silenced Exception!\[dq]);
});

p3.catch((e) => {
  console.error(e); // This is never called
});
\f[R]
.fi
.SS catch() is not called if the promise is fulfilled
.IP
.nf
\f[C]
// Create a promise which would not call onReject
const p1 = Promise.resolve(\[dq]calling next\[dq]);

const p2 = p1.catch((reason) => {
  // This is never called
  console.error(\[dq]catch p1!\[dq]);
  console.error(reason);
});

p2.then(
  (value) => {
    console.log(\[dq]next promise\[aq]s onFulfilled\[dq]);
    console.log(value); // calling next
  },
  (reason) => {
    console.log(\[dq]next promise\[aq]s onRejected\[dq]);
    console.log(reason);
  },
);
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
\f[V]Promise\f[R]
.IP \[bu] 2
\f[V]Promise.prototype.then()\f[R]
.IP \[bu] 2
\f[V]Promise.prototype.finally()\f[R]
