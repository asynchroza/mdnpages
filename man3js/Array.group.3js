.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.group" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]group()\f[B]\f[R] method groups the elements of the
calling array according to the string values returned by a provided
testing function.
The returned object has separate properties for each group, containing
arrays with the elements in the group.
.PP
This method should be used when group names can be represented by
strings.
If you need to group elements using a key that is some arbitrary value,
use \f[V]Array.prototype.groupToMap()\f[R] instead.
.SH Syntax
.IP
.nf
\f[C]
group(callbackFn)
group(callbackFn, thisArg)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]callbackFn\f[R]
.RS 2
.IP \[bu] 2
A function to execute for each element in the array.
It should return a value that can get coerced into a property key
(string or symbol) indicating the group of the current element.
The function is called with the following arguments:
.RS 2
.IP \[bu] 2
\f[V]element\f[R]
.RS 2
.IP \[bu] 2
The current element being processed in the array.
.RE
.IP \[bu] 2
\f[V]index\f[R]
.RS 2
.IP \[bu] 2
The index of the current element being processed in the array.
.RE
.IP \[bu] 2
\f[V]array\f[R]
.RS 2
.IP \[bu] 2
The array \f[V]group()\f[R] was called upon.
.RE
.RE
.RE
.IP \[bu] 2
\f[V]thisArg\f[R] \f[I](optional)\f[R]
.RS 2
.IP \[bu] 2
A value to use as \f[V]this\f[R] when executing \f[V]callbackFn\f[R].
See iterative methods.
.RE
.SS Return value
.PP
A \f[V]null\f[R]-prototype object with properties for all groups, each
assigned to an array containing the elements of the associated group.
.SH Description
.PP
The \f[V]group()\f[R] method is an iterative method.
It calls a provided \f[V]callbackFn\f[R] function once for each element
in an array, returning a string or symbol (values that are neither type
are coerced to strings) indicating the group of the element.
A new property and array is created in the result object for each unique
group name that is returned by the callback.
Each element is added to the array in the property that corresponds to
its group.
.PP
\f[V]callbackFn\f[R] is invoked for \f[I]every\f[R] index of the array,
not just those with assigned values.
Empty slots in sparse arrays behave the same as \f[V]undefined\f[R].
.PP
The \f[V]group()\f[R] method is a copying method.
It does not alter \f[V]this\f[R] but instead returns an object of arrays
that contains the same elements as the ones from the original array.
However, the function provided as \f[V]callbackFn\f[R] can mutate the
array.
Note, however, that the length of the array is saved \f[I]before\f[R]
the first invocation of \f[V]callbackFn\f[R].
Therefore:
.IP \[bu] 2
\f[V]callbackFn\f[R] will not visit any elements added beyond the
array\[cq]s initial length when the call to \f[V]group()\f[R] began.
.IP \[bu] 2
Changes to already-visited indexes do not cause \f[V]callbackFn\f[R] to
be invoked on them again.
.IP \[bu] 2
If an existing, yet-unvisited element of the array is changed by
\f[V]callbackFn\f[R], its value passed to the \f[V]callbackFn\f[R] will
be the value at the time that element gets visited.
Deleted elements are visited as if they were \f[V]undefined\f[R].
.RS
.PP
\f[B]Warning:\f[R] Concurrent modifications of the kind described above
frequently lead to hard-to-understand code and are generally to be
avoided (except in special cases).
.RE
.PP
The returned object references the \f[I]same\f[R] elements as the
original array (not deep copies).
Changing the internal structure of these elements will be reflected in
both the original array and the returned object.
.PP
The \f[V]group()\f[R] method is generic.
It only expects the \f[V]this\f[R] value to have a \f[V]length\f[R]
property and integer-keyed properties.
.SH Examples
.SS Using group()
.PP
First we define an array containing objects representing an inventory of
different foodstuffs.
Each food has a \f[V]type\f[R] and a \f[V]quantity\f[R].
.IP
.nf
\f[C]
const inventory = [
  { name: \[dq]asparagus\[dq], type: \[dq]vegetables\[dq], quantity: 5 },
  { name: \[dq]bananas\[dq], type: \[dq]fruit\[dq], quantity: 0 },
  { name: \[dq]goat\[dq], type: \[dq]meat\[dq], quantity: 23 },
  { name: \[dq]cherries\[dq], type: \[dq]fruit\[dq], quantity: 5 },
  { name: \[dq]fish\[dq], type: \[dq]meat\[dq], quantity: 22 },
];
\f[R]
.fi
.PP
The code below groups the elements by the value of their \f[V]type\f[R]
property.
.IP
.nf
\f[C]
const result = inventory.group(({ type }) => type);

/* Result is:
{
  vegetables: [
    { name: \[aq]asparagus\[aq], type: \[aq]vegetables\[aq], quantity: 5 },
  ],
  fruit: [
    { name: \[dq]bananas\[dq], type: \[dq]fruit\[dq], quantity: 0 },
    { name: \[dq]cherries\[dq], type: \[dq]fruit\[dq], quantity: 5 }
  ],
  meat: [
    { name: \[dq]goat\[dq], type: \[dq]meat\[dq], quantity: 23 },
    { name: \[dq]fish\[dq], type: \[dq]meat\[dq], quantity: 22 }
  ]
}
*/
\f[R]
.fi
.PP
The arrow function just returns the \f[V]type\f[R] of each array element
each time it is called.
Note that the function argument \f[V]{ type }\f[R] is a basic example of
object destructuring syntax for function arguments.
This unpacks the \f[V]type\f[R] property of an object passed as a
parameter, and assigns it to a variable named \f[V]type\f[R] in the body
of the function.
This is a very succinct way to access the relevant values of elements
within a function.
.PP
We can also create groups inferred from values in one or more properties
of the elements.
Below is a very similar example that puts the items into \f[V]ok\f[R] or
\f[V]restock\f[R] groups based on the value of the \f[V]quantity\f[R]
field.
.IP
.nf
\f[C]
function myCallback({ quantity }) {
  return quantity > 5 ? \[dq]ok\[dq] : \[dq]restock\[dq];
}

const result2 = inventory.group(myCallback);

/* Result is:
{
  restock: [
    { name: \[dq]asparagus\[dq], type: \[dq]vegetables\[dq], quantity: 5 },
    { name: \[dq]bananas\[dq], type: \[dq]fruit\[dq], quantity: 0 },
    { name: \[dq]cherries\[dq], type: \[dq]fruit\[dq], quantity: 5 }
  ],
  ok: [
    { name: \[dq]goat\[dq], type: \[dq]meat\[dq], quantity: 23 },
    { name: \[dq]fish\[dq], type: \[dq]meat\[dq], quantity: 22 }
  ]
}
*/
\f[R]
.fi
.SS Using group() on sparse arrays
.PP
When used on sparse arrays, the \f[V]group()\f[R] method iterates empty
slots as if they have the value \f[V]undefined\f[R].
.IP
.nf
\f[C]
console.log([1, , 3].group((x) => x)); // { 1: [1], undefined: [undefined], 3: [3] }
\f[R]
.fi
.SS Calling group() on non-array objects
.PP
The \f[V]group()\f[R] method reads the \f[V]length\f[R] property of
\f[V]this\f[R] and then accesses each integer index.
.IP
.nf
\f[C]
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.group.call(arrayLike, (x) => x % 2));
// { 0: [2, 4], 1: [3] }
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]Array.prototype.group\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#array-grouping)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[V]Array\f[R]
.IP \[bu] 2
\f[V]Array.prototype.groupToMap()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.reduce()\f[R]
.IP \[bu] 2
\f[V]Object.fromEntries()\f[R]
