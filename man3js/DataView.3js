.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "DataView" "JS" "August 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
DataView - DataView
.SH SYNOPSIS
The \f[B]\f[CB]DataView\f[B]\f[R] view provides a low-level interface
for reading and writing multiple number types in a binary
\f[CR]ArrayBuffer\f[R], without having to care about the platform\[cq]s
endianness.
.SH DESCRIPTION
.SS Endianness
Multi-byte number formats are represented in memory differently
depending on machine architecture \[em] see Endianness for an
explanation.
\f[CR]DataView\f[R] accessors provide explicit control of how data is
accessed, regardless of the executing computer\[cq]s endianness.
.IP
.EX
const littleEndian = (() => {
  const buffer = new ArrayBuffer(2);
  new DataView(buffer).setInt16(0, 256, true /* littleEndian */);
  // Int16Array uses the platform\[aq]s endianness.
  return new Int16Array(buffer)[0] === 256;
})();
console.log(littleEndian); // true or false
.EE
.SS 64-bit Integer Values
Some browsers don\[cq]t have support for
\f[CR]DataView.prototype.setBigInt64()\f[R] and
\f[CR]DataView.prototype.setBigUint64()\f[R].
So to enable 64-bit operations in your code that will work across
browsers, you could implement your own \f[CR]getUint64()\f[R] function,
to obtain values with precision up to \f[CR]Number.MAX_SAFE_INTEGER\f[R]
\[em] which could suffice for certain cases.
.IP
.EX
function getUint64(dataview, byteOffset, littleEndian) {
  // split 64-bit number into two 32-bit (4-byte) parts
  const left = dataview.getUint32(byteOffset, littleEndian);
  const right = dataview.getUint32(byteOffset + 4, littleEndian);

  // combine the two 32-bit values
  const combined = littleEndian
    ? left + 2 ** 32 * right
    : 2 ** 32 * left + right;

  if (!Number.isSafeInteger(combined))
    console.warn(combined, \[dq]exceeds MAX_SAFE_INTEGER. Precision may be lost\[dq]);

  return combined;
}
.EE
.PP
Alternatively, if you need full 64-bit range, you can create a
\f[CR]BigInt\f[R].
Further, although native BigInts are much faster than user-land library
equivalents, BigInts will always be much slower than 32-bit integers in
JavaScript due to the nature of their variable size.
.IP
.EX
const BigInt = window.BigInt,
  bigThirtyTwo = BigInt(32),
  bigZero = BigInt(0);
function getUint64BigInt(dataview, byteOffset, littleEndian) {
  // split 64-bit number into two 32-bit (4-byte) parts
  const left = BigInt(dataview.getUint32(byteOffset | 0, !!littleEndian) >>> 0);
  const right = BigInt(
    dataview.getUint32(((byteOffset | 0) + 4) | 0, !!littleEndian) >>> 0,
  );

  // combine the two 32-bit values and return
  return littleEndian
    ? (right << bigThirtyTwo) | left
    : (left << bigThirtyTwo) | right;
}
.EE
.SH CONSTRUCTOR
.TP
\f[B]DataView()\f[R]
Creates a new \f[CR]DataView\f[R] object.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]DataView.prototype\f[R] and shared
by all \f[CR]DataView\f[R] instances.
.TP
\f[B]DataView.prototype.buffer\f[R]
The \f[CR]ArrayBuffer\f[R] referenced by this view.
Fixed at construction time and thus \f[B]read only.\f[R]
.TP
\f[B]DataView.prototype.byteLength\f[R]
The length (in bytes) of this view.
Fixed at construction time and thus \f[B]read only.\f[R]
.TP
\f[B]DataView.prototype.byteOffset\f[R]
The offset (in bytes) of this view from the start of its
\f[CR]ArrayBuffer\f[R].
Fixed at construction time and thus \f[B]read only.\f[R]
.TP
\f[B]DataView.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]DataView\f[R] instances, the initial value is the
\f[CR]DataView\f[R] constructor.
.TP
\f[B]DataView.prototype[\[at]\[at]toStringTag]\f[R]
The initial value of the \f[CR]\[at]\[at]toStringTag\f[R] property is
the string \f[CR]\[dq]DataView\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
.SH INSTANCE METHODS
.TP
\f[B]DataView.prototype.getBigInt64()\f[R]
Reads 8 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 64-bit signed integer.
.TP
\f[B]DataView.prototype.getBigUint64()\f[R]
Reads 8 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 64-bit unsigned integer.
.TP
\f[B]DataView.prototype.getFloat32()\f[R]
Reads 4 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 32-bit floating point
number.
.TP
\f[B]DataView.prototype.getFloat64()\f[R]
Reads 8 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 64-bit floating point
number.
.TP
\f[B]DataView.prototype.getInt16()\f[R]
Reads 2 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 16-bit signed integer.
.TP
\f[B]DataView.prototype.getInt32()\f[R]
Reads 4 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 32-bit signed integer.
.TP
\f[B]DataView.prototype.getInt8()\f[R]
Reads 1 byte at the specified byte offset of this \f[CR]DataView\f[R]
and interprets it as an 8-bit signed integer.
.TP
\f[B]DataView.prototype.getUint16()\f[R]
Reads 2 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 16-bit unsigned integer.
.TP
\f[B]DataView.prototype.getUint32()\f[R]
Reads 4 bytes starting at the specified byte offset of this
\f[CR]DataView\f[R] and interprets them as a 32-bit unsigned integer.
.TP
\f[B]DataView.prototype.getUint8()\f[R]
Reads 1 byte at the specified byte offset of this \f[CR]DataView\f[R]
and interprets it as an 8-bit unsigned integer.
.TP
\f[B]DataView.prototype.setBigInt64()\f[R]
Takes a BigInt and stores it as a 64-bit signed integer in the 8 bytes
starting at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setBigUint64()\f[R]
Takes a BigInt and stores it as a 64-bit unsigned integer in the 8 bytes
starting at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setFloat32()\f[R]
Takes a number and stores it as a 32-bit float in the 4 bytes starting
at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setFloat64()\f[R]
Takes a number and stores it as a 64-bit float in the 8 bytes starting
at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setInt16()\f[R]
Takes a number and stores it as a 16-bit signed integer in the 2 bytes
at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setInt32()\f[R]
Takes a number and stores it as a 32-bit signed integer in the 4 bytes
at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setInt8()\f[R]
Takes a number and stores it as an 8-bit signed integer in the byte at
the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setUint16()\f[R]
Takes a number and stores it as a 16-bit unsigned integer in the 2 bytes
at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setUint32()\f[R]
Takes a number and stores it as a 32-bit unsigned integer in the 4 bytes
at the specified byte offset of this \f[CR]DataView\f[R].
.TP
\f[B]DataView.prototype.setUint8()\f[R]
Takes a number and stores it as an 8-bit unsigned integer in the byte at
the specified byte offset of this \f[CR]DataView\f[R].
.SH EXAMPLES
.SS Using DataView
.IP
.EX
const buffer = new ArrayBuffer(16);
const view = new DataView(buffer, 0);

view.setInt16(1, 42);
view.getInt16(1); // 42
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]DataView\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-typed-arrays)
.IP \[bu] 2
\f[CR]ArrayBuffer\f[R]
.IP \[bu] 2
\f[CR]SharedArrayBuffer\f[R]
