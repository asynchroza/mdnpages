.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "JSON.parse" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]JSON.parse()\f[B]\f[R] static method parses a JSON
string, constructing the JavaScript value or object described by the
string.
An optional \f[I]reviver\f[R] function can be provided to perform a
transformation on the resulting object before it is returned.
.SH Syntax
.IP
.nf
\f[C]
JSON.parse(text)
JSON.parse(text, reviver)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]text\f[R]
.RS 2
.IP \[bu] 2
The string to parse as JSON.
See the \f[V]JSON\f[R] object for a description of JSON syntax.
.RE
.IP \[bu] 2
\f[V]reviver\f[R] \f[I](optional)\f[R]
.RS 2
.IP \[bu] 2
If a function, this prescribes how each value originally produced by
parsing is transformed before being returned.
Non-callable values are ignored.
The function is called with the following arguments:
.RS 2
.IP \[bu] 2
\f[V]key\f[R]
.RS 2
.IP \[bu] 2
The key associated with the value.
.RE
.IP \[bu] 2
\f[V]value\f[R]
.RS 2
.IP \[bu] 2
The value produced by parsing.
.RE
.RE
.RE
.SS Return value
.PP
The \f[V]Object\f[R], \f[V]Array\f[R], string, number, boolean, or
\f[V]null\f[R] value corresponding to the given JSON \f[V]text\f[R].
.SS Exceptions
.IP \[bu] 2
\f[V]SyntaxError\f[R]
.RS 2
.IP \[bu] 2
Thrown if the string to parse is not valid JSON.
.RE
.SH Description
.PP
\f[V]JSON.parse()\f[R] parses a JSON string according to the JSON
grammar, then evaluates the string as if it\[cq]s a JavaScript
expression.
The only instance where a piece of JSON text represents a different
value from the same JavaScript expression is when dealing with the
\f[V]\[dq]__proto__\[dq]\f[R] key \[em] see Object literal syntax
vs.\ JSON.
.SS The reviver parameter
.PP
If a \f[V]reviver\f[R] is specified, the value computed by parsing is
\f[I]transformed\f[R] before being returned.
Specifically, the computed value and all its properties (in a
depth-first (https://en.wikipedia.org/wiki/Depth-first_search) fashion,
beginning with the most nested properties and proceeding to the original
value itself) are individually run through the \f[V]reviver\f[R].
.PP
The \f[V]reviver\f[R] is called with the object containing the property
being processed as \f[V]this\f[R], and two arguments: \f[V]key\f[R] and
\f[V]value\f[R], representing the property name as a string (even for
arrays) and the property value.
If the \f[V]reviver\f[R] function returns \f[V]undefined\f[R] (or
returns no value \[em] for example, if execution falls off the end of
the function), the property is deleted from the object.
Otherwise, the property is redefined to be the return value.
If the \f[V]reviver\f[R] only transforms some values and not others, be
certain to return all untransformed values as-is \[em] otherwise, they
will be deleted from the resulting object.
.PP
Similar to the \f[V]replacer\f[R] parameter of
\f[V]JSON.stringify()\f[R], \f[V]reviver\f[R] will be last called on the
root object with an empty string as the \f[V]key\f[R] and the root
object as the \f[V]value\f[R].
For JSON text parsing to primitive values, \f[V]reviver\f[R] will be
called once.
.PP
Note that \f[V]reviver\f[R] is run after the value is parsed.
So, for example, numbers in JSON text will have already been converted
to JavaScript numbers, and may lose precision in the process.
To transfer large numbers without loss of precision, serialize them as
strings, and revive them to BigInts, or other appropriate arbitrary
precision formats.
.SH Examples
.SS Using JSON.parse()
.IP
.nf
\f[C]
JSON.parse(\[dq]{}\[dq]); // {}
JSON.parse(\[dq]true\[dq]); // true
JSON.parse(\[aq]\[dq]foo\[dq]\[aq]); // \[dq]foo\[dq]
JSON.parse(\[aq][1, 5, \[dq]false\[dq]]\[aq]); // [1, 5, \[dq]false\[dq]]
JSON.parse(\[dq]null\[dq]); // null
\f[R]
.fi
.SS Using the reviver parameter
.IP
.nf
\f[C]
JSON.parse(
  \[aq]{\[dq]p\[dq]: 5}\[aq],
  (key, value) =>
    typeof value === \[dq]number\[dq]
      ? value * 2 // return value * 2 for numbers
      : value, // return everything else unchanged
);
// { p: 10 }

JSON.parse(\[aq]{\[dq]1\[dq]: 1, \[dq]2\[dq]: 2, \[dq]3\[dq]: {\[dq]4\[dq]: 4, \[dq]5\[dq]: {\[dq]6\[dq]: 6}}}\[aq], (key, value) => {
  console.log(key);
  return value;
});
// 1
// 2
// 4
// 6
// 5
// 3
// \[dq]\[dq]
\f[R]
.fi
.SS Using reviver when paired with the replacer of JSON.stringify()
.PP
In order for a value to properly round-trip (that is, it gets
deserialized to the same original object), the serialization process
must preserve the type information.
For example, you can use the \f[V]replacer\f[R] parameter of
\f[V]JSON.stringify()\f[R] for this purpose:
.IP
.nf
\f[C]
// Maps are normally serialized as objects with no properties.
// We can use the replacer to specify the entries to be serialized.
const map = new Map([
  [1, \[dq]one\[dq]],
  [2, \[dq]two\[dq]],
  [3, \[dq]three\[dq]],
]);

const jsonText = JSON.stringify(map, (key, value) =>
  value instanceof Map ? Array.from(value.entries()) : value,
);

console.log(jsonText);
// [[1,\[dq]one\[dq]],[2,\[dq]two\[dq]],[3,\[dq]three\[dq]]]

const map2 = JSON.parse(jsonText, (key, value) =>
  key === \[dq]\[dq] ? new Map(value) : value,
);

console.log(map2);
// Map { 1 => \[dq]one\[dq], 2 => \[dq]two\[dq], 3 => \[dq]three\[dq] }
\f[R]
.fi
.PP
Because JSON has no syntax space for annotating type metadata, in order
to revive values that are not plain objects, you have to consider one of
the following:
.IP \[bu] 2
Serialize the entire object to a string and prefix it with a type tag.
.IP \[bu] 2
\[lq]Guess\[rq] based on the structure of the data (for example, an
array of two-member arrays)
.IP \[bu] 2
If the shape of the payload is fixed, based on the property name (for
example, all properties called \f[V]registry\f[R] hold \f[V]Map\f[R]
objects).
.SS JSON.parse() does not allow trailing commas
.PP
\f[B]Bad\f[R]
.IP
.nf
\f[C]
// both will throw a SyntaxError
JSON.parse(\[dq][1, 2, 3, 4, ]\[dq]);
JSON.parse(\[aq]{\[dq]foo\[dq] : 1, }\[aq]);
\f[R]
.fi
.SS JSON.parse() does not allow single quotes
.PP
\f[B]Bad\f[R]
.IP
.nf
\f[C]
// will throw a SyntaxError
JSON.parse(\[dq]{\[aq]foo\[aq]: 1}\[dq]);
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]JSON.stringify()\f[R]
