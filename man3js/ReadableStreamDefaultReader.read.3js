.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "ReadableStreamDefaultReader.read" "JS" "May 10, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
ReadableStreamDefaultReader.read \- ReadableStreamDefaultReader: read()
method
.SH SYNOPSIS
The \f[B]\f[CB]read()\f[B]\f[R] method of the
\f[CR]ReadableStreamDefaultReader\f[R] interface returns a
\f[CR]Promise\f[R] providing access to the next chunk in the
stream\[cq]s internal queue.
.SH SYNTAX
.IP
.EX
read()
.EE
.SS Parameters
None.
.SS Return value
A \f[CR]Promise\f[R], which fulfills/rejects with a result depending on
the state of the stream.
The different possibilities are as follows:
.IP \[bu] 2
If a chunk is available, the promise will be fulfilled with an object of
the form \f[CR]{ value: theChunk, done: false }\f[R].
.IP \[bu] 2
If the stream becomes closed, the promise will be fulfilled with an
object of the form \f[CR]{ value: undefined, done: true }\f[R].
.IP \[bu] 2
If the stream becomes errored, the promise will be rejected with the
relevant error.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
The source object is not a \f[CR]ReadableStreamDefaultReader\f[R], the
stream has no owner, or
\f[CR]ReadableStreamDefaultReader.releaseLock()\f[R] is called (when
there\[cq]s a pending read request).
.SH EXAMPLES
.SS Example 1 \- simple example
This example shows the basic API usage, but doesn\[cq]t try to deal with
complications like stream chunks not ending on line boundaries for
example.
.PP
In this example, \f[CR]stream\f[R] is a previously\-created custom
\f[CR]ReadableStream\f[R].
It is read using a \f[CR]ReadableStreamDefaultReader\f[R] created using
\f[CR]getReader()\f[R].
(see our \c
.UR https://mdn.github.io/dom-examples/streams/simple-random-stream/
Simple random stream example
.UE \c
\ for the full code).
Each chunk is read sequentially and output to the UI as an array of
UTF\-8 bytes, until the stream has finished being read, at which point
we return out of the recursive function and print the entire stream to
another part of the UI.
.IP
.EX
function fetchStream() {
  const reader = stream.getReader();
  let charsReceived = 0;

  // read() returns a promise that fulfills
  // when a value has been received
  reader.read().then(function processText({ done, value }) {
    // Result objects contain two properties:
    // done  \- true if the stream has already given you all its data.
    // value \- some data. Always undefined when done is true.
    if (done) {
      console.log(\[dq]Stream complete\[dq]);
      para.textContent = result;
      return;
    }

    // value for fetch streams is a Uint8Array
    charsReceived += value.length;
    const chunk = value;
    let listItem = document.createElement(\[dq]li\[dq]);
    listItem.textContent = \[ga]Received ${charsReceived} characters so far. Current chunk = ${chunk}\[ga];
    list2.appendChild(listItem);

    result += chunk;

    // Read some more, and call this function again
    return reader.read().then(processText);
  });
}
.EE
.SS Example 2 \- handling text line by line
This example shows how you might fetch a text file and handle it as a
stream of text lines.
It deals with stream chunks not ending on line boundaries, and with
converting from \f[CR]Uint8Array\f[R] to strings.
.IP
.EX
async function* makeTextFileLineIterator(fileURL) {
  const utf8Decoder = new TextDecoder(\[dq]utf\-8\[dq]);
  let response = await fetch(fileURL);
  let reader = response.body.getReader();
  let { value: chunk, done: readerDone } = await reader.read();
  chunk = chunk ? utf8Decoder.decode(chunk, { stream: true }) : \[dq]\[dq];

  let re = /\[rs]r\[rs]n|\[rs]n|\[rs]r/gm;
  let startIndex = 0;

  for (;;) {
    let result = re.exec(chunk);
    if (!result) {
      if (readerDone) {
        break;
      }
      let remainder = chunk.substr(startIndex);
      ({ value: chunk, done: readerDone } = await reader.read());
      chunk =
        remainder + (chunk ? utf8Decoder.decode(chunk, { stream: true }) : \[dq]\[dq]);
      startIndex = re.lastIndex = 0;
      continue;
    }
    yield chunk.substring(startIndex, result.index);
    startIndex = re.lastIndex;
  }
  if (startIndex < chunk.length) {
    // last line didn\[aq]t end in a newline char
    yield chunk.substr(startIndex);
  }
}

for await (let line of makeTextFileLineIterator(urlOfFile)) {
  processLine(line);
}
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]ReadableStreamDefaultReader()\f[R] constructor
.IP \[bu] 2
Using readable streams
