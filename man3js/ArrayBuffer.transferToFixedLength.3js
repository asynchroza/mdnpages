.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "ArrayBuffer.transferToFixedLength" "JS" "December 24, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
ArrayBuffer.transferToFixedLength \-
ArrayBuffer.prototype.transferToFixedLength()
.SH SYNOPSIS
The \f[B]\f[CB]transferToFixedLength()\f[B]\f[R] method of
\f[CR]ArrayBuffer\f[R] instances creates a new non\-resizable
\f[CR]ArrayBuffer\f[R] with the same byte content as this buffer, then
detaches this buffer.
.SH SYNTAX
.IP
.EX
transferToFixedLength()
transferToFixedLength(newByteLength)
.EE
.SS Parameters
.TP
\f[B]newByteLength\f[R]
The \f[CR]byteLength\f[R] of the new \f[CR]ArrayBuffer\f[R].
Defaults to the \f[CR]byteLength\f[R] of this \f[CR]ArrayBuffer\f[R].
.RS
.IP \[bu] 2
If \f[CR]newByteLength\f[R] is smaller than the \f[CR]byteLength\f[R] of
this \f[CR]ArrayBuffer\f[R], the \[lq]overflowing\[rq] bytes are
dropped.
.IP \[bu] 2
If \f[CR]newByteLength\f[R] is larger than the \f[CR]byteLength\f[R] of
this \f[CR]ArrayBuffer\f[R], the extra bytes are filled with zeros.
.RE
.SS Return value
A new \f[CR]ArrayBuffer\f[R] object.
Its contents are initialized to the contents of this
\f[CR]ArrayBuffer\f[R], and extra bytes, if any, are filled with zeros.
The new \f[CR]ArrayBuffer\f[R] is always non\-resizable.
The original \f[CR]ArrayBuffer\f[R] is detached.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if this \f[CR]ArrayBuffer\f[R] is already detached.
.SH DESCRIPTION
Unlike \f[CR]transfer()\f[R], \f[CR]transferToFixedLength()\f[R] always
creates a non\-resizable \f[CR]ArrayBuffer\f[R].
This means \f[CR]newByteLength\f[R] can be larger than the
\f[CR]maxByteLength\f[R], even if this \f[CR]ArrayBuffer\f[R] is
resizable.
See transferring ArrayBuffers for more information.
.SH EXAMPLES
.SS Transferring a resizable ArrayBuffer to fixed\-length
.IP
.EX
const buffer = new ArrayBuffer(8, { maxByteLength: 16 });
const view = new Uint8Array(buffer);
view[1] = 2;
view[7] = 4;

const buffer2 = buffer.transferToFixedLength();
console.log(buffer2.byteLength); // 8
console.log(buffer2.resizable); // false
const view2 = new Uint8Array(buffer2);
console.log(view2[1]); // 2
console.log(view2[7]); // 4
.EE
.PP
Using \f[CR]transferToFixedLength\f[R], \f[CR]newByteLength\f[R] can be
larger than the \f[CR]maxByteLength\f[R] of the original
\f[CR]ArrayBuffer\f[R].
.IP
.EX
const buffer = new ArrayBuffer(8, { maxByteLength: 16 });
const view = new Uint8Array(buffer);
view[1] = 2;
view[7] = 4;

const buffer2 = buffer.transferToFixedLength(20);
console.log(buffer2.byteLength); // 20
console.log(buffer2.resizable); // false
const view2 = new Uint8Array(buffer2);
console.log(view2[1]); // 2
console.log(view2[7]); // 4
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]ArrayBuffer\f[R]
.IP \[bu] 2
\f[CR]ArrayBuffer.prototype.detached\f[R]
.IP \[bu] 2
\f[CR]ArrayBuffer.prototype.transfer()\f[R]
