.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "eval" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.RS
.PP
\f[B]Warning:\f[R] Executing JavaScript from a string is an enormous
security risk.
It is far too easy for a bad actor to run arbitrary code when you use
\f[V]eval()\f[R].
See Never use eval()!, below.
.RE
.PP
The \f[B]\f[VB]eval()\f[B]\f[R] function evaluates JavaScript code
represented as a string and returns its completion value.
The source is parsed as a script.
.SH Syntax
.IP
.nf
\f[C]
eval(script)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]script\f[R]
.RS 2
.IP \[bu] 2
A string representing a JavaScript expression, statement, or sequence of
statements.
The expression can include variables and properties of existing objects.
It will be parsed as a script, so \f[V]import\f[R] declarations (which
can only exist in modules) are not allowed.
.RE
.SS Return value
.PP
The completion value of evaluating the given code.
If the completion value is empty, \f[V]undefined\f[R] is returned.
If \f[V]script\f[R] is not a string primitive, \f[V]eval()\f[R] returns
the argument unchanged.
.SS Exceptions
.PP
Throws any exception that occurs during evaluation of the code,
including \f[V]SyntaxError\f[R] if \f[V]script\f[R] fails to be parsed
as a script.
.SH Description
.PP
\f[V]eval()\f[R] is a function property of the global object.
.PP
The argument of the \f[V]eval()\f[R] function is a string.
It will evaluate the source string as a script body, which means both
statements and expressions are allowed.
It returns the completion value of the code.
For expressions, it\[cq]s the value the expression evaluates to.
Many statements and declarations have completion values as well, but the
result may be surprising (for example, the completion value of an
assignment is the assigned value, but the completion value of
\f[V]let\f[R] is undefined), so it\[cq]s recommended to not rely on
statements\[cq] completion values.
.PP
In strict mode, declaring a variable named \f[V]eval\f[R] or
re-assigning \f[V]eval\f[R] is a \f[V]SyntaxError\f[R].
.PP
\f[B]Bad\f[R]
.IP
.nf
\f[C]
\[dq]use strict\[dq];

const eval = 1; // SyntaxError: Unexpected eval or arguments in strict mode
\f[R]
.fi
.PP
If the argument of \f[V]eval()\f[R] is not a string, \f[V]eval()\f[R]
returns the argument unchanged.
In the following example, passing a \f[V]String\f[R] object instead of a
primitive causes \f[V]eval()\f[R] to return the \f[V]String\f[R] object
rather than evaluating the string.
.IP
.nf
\f[C]
eval(new String(\[dq]2 + 2\[dq])); // returns a String object containing \[dq]2 + 2\[dq]
eval(\[dq]2 + 2\[dq]); // returns 4
\f[R]
.fi
.PP
To work around the issue in a generic fashion, you can coerce the
argument to a string yourself before passing it to \f[V]eval()\f[R].
.IP
.nf
\f[C]
const expression = new String(\[dq]2 + 2\[dq]);
eval(String(expression)); // returns 4
\f[R]
.fi
.SS Direct and indirect eval
.PP
There are two modes of \f[V]eval()\f[R] calls: \f[I]direct\f[R] eval and
\f[I]indirect\f[R] eval.
Direct eval only has one form: \f[V]eval( )\f[R] (the invoked
function\[cq]s name is \f[V]eval\f[R] and its value is the global
\f[V]eval\f[R] function).
Everything else, including invoking it via an aliased variable, via a
member access or other expression, or through the optional chaining
\f[V]?.\f[R] operator, is indirect.
.IP
.nf
\f[C]
// Indirect call using the comma operator to return eval
(0, eval)(\[dq]x + y\[dq]);

// Indirect call through optional chaining
eval?.(\[dq]x + y\[dq]);

// Indirect call using a variable to store and return eval
const geval = eval;
geval(\[dq]x + y\[dq]);

// Indirect call through member access
const obj = { eval };
obj.eval(\[dq]x + y\[dq]);
\f[R]
.fi
.PP
Indirect eval can be seen as if the code is evaluated within a separate
\f[V]<script>\f[R] tag.
This means:
.IP \[bu] 2
Indirect eval works in the global scope rather than the local scope, and
the code being evaluated doesn\[cq]t have access to local variables
within the scope where it\[cq]s being called.
.RS 2
.IP
.nf
\f[C]
function test() {
  const x = 2;
  const y = 4;
  // Direct call, uses local scope
  console.log(eval(\[dq]x + y\[dq])); // Result is 6
  console.log(eval?.(\[dq]x + y\[dq])); // Uses global scope, throws because x is undefined
}
\f[R]
.fi
.RE
.IP \[bu] 2
Indirect \f[V]eval\f[R] would not inherit the strictness of the
surrounding context, and would only be in strict mode if the source
string itself has a \f[V]\[dq]use strict\[dq]\f[R] directive.
.RS 2
.IP
.nf
\f[C]
function strictContext() {
  \[dq]use strict\[dq];
  eval?.(\[ga]with (Math) console.log(PI);\[ga]);
}
function strictContextStrictEval() {
  \[dq]use strict\[dq];
  eval?.(\[ga]\[dq]use strict\[dq]; with (Math) console.log(PI);\[ga]);
}
strictContext(); // Logs 3.141592653589793
strictContextStrictEval(); // Throws a SyntaxError because the source string is in strict mode
\f[R]
.fi
.PP
On the other hand, direct eval inherits the strictness of the invoking
context.
.IP
.nf
\f[C]
function nonStrictContext() {
  eval(\[ga]with (Math) console.log(PI);\[ga]);
}
function strictContext() {
  \[dq]use strict\[dq];
  eval(\[ga]with (Math) console.log(PI);\[ga]);
}
nonStrictContext(); // Logs 3.141592653589793
strictContext(); // Throws a SyntaxError because it\[aq]s in strict mode
\f[R]
.fi
.RE
.IP \[bu] 2
\f[V]var\f[R]-declared variables and function declarations would go into
the surrounding scope if the source string is not interpreted in strict
mode \[em] for indirect eval, they become global variables.
If it\[cq]s a direct eval in a strict mode context, or if the
\f[V]eval\f[R] source string itself is in strict mode, then
\f[V]var\f[R] and function declarations do not \[lq]leak\[rq] into the
surrounding scope.
.RS 2
.IP
.nf
\f[C]
// Neither context nor source string is strict,
// so var creates a variable in the surrounding scope
eval(\[dq]var a = 1;\[dq]);
console.log(a); // 1
// Context is not strict, but eval source is strict,
// so b is scoped to the evaluated script
eval(\[dq]\[aq]use strict\[aq]; var b = 1;\[dq]);
console.log(b); // ReferenceError: b is not defined

function strictContext() {
  \[dq]use strict\[dq];
  // Context is strict, but this is indirect and the source
  // string is not strict, so c is still global
  eval?.(\[dq]var c = 1;\[dq]);
  // Direct eval in a strict context, so d is scoped
  eval(\[dq]var d = 1;\[dq]);
}
strictContext();
console.log(c); // 1
console.log(d); // ReferenceError: d is not defined
\f[R]
.fi
.PP
\f[V]let\f[R] and \f[V]const\f[R] declarations within the evaluated
string are always scoped to that script.
.RE
.IP \[bu] 2
Direct eval may have access to additional contextual expressions.
For example, in a function\[cq]s body, one can use \f[V]new.target\f[R]:
.RS 2
.IP
.nf
\f[C]
function Ctor() {
  eval(\[dq]console.log(new.target)\[dq]);
}
new Ctor(); // [Function: Ctor]
\f[R]
.fi
.RE
.SS Never use eval()!
.PP
Using direct \f[V]eval()\f[R] suffers from multiple problems:
.IP \[bu] 2
\f[V]eval()\f[R] executes the code it\[cq]s passed with the privileges
of the caller.
If you run \f[V]eval()\f[R] with a string that could be affected by a
malicious party, you may end up running malicious code on the user\[cq]s
machine with the permissions of your webpage / extension.
More importantly, allowing third-party code to access the scope in which
\f[V]eval()\f[R] was invoked (if it\[cq]s a direct eval) can lead to
possible attacks that reads or changes local variables.
.IP \[bu] 2
\f[V]eval()\f[R] is slower than the alternatives, since it has to invoke
the JavaScript interpreter, while many other constructs are optimized by
modern JS engines.
.IP \[bu] 2
Modern JavaScript interpreters convert JavaScript to machine code.
This means that any concept of variable naming gets obliterated.
Thus, any use of \f[V]eval()\f[R] will force the browser to do long
expensive variable name lookups to figure out where the variable exists
in the machine code and set its value.
Additionally, new things can be introduced to that variable through
\f[V]eval()\f[R], such as changing the type of that variable, forcing
the browser to re-evaluate all of the generated machine code to
compensate.
.IP \[bu] 2
Minifiers give up on any minification if the scope is transitively
depended on by \f[V]eval()\f[R], because otherwise \f[V]eval()\f[R]
cannot read the correct variable at runtime.
.PP
There are many cases where the use of \f[V]eval()\f[R] or related
methods can be optimized or avoided altogether.
.SS Using indirect eval()
.PP
Consider this code:
.IP
.nf
\f[C]
function looseJsonParse(obj) {
  return eval(\[ga](${obj})\[ga]);
}
console.log(looseJsonParse(\[dq]{ a: 4 - 1, b: function () {}, c: new Date() }\[dq]));
\f[R]
.fi
.PP
Simply using indirect eval and forcing strict mode can make the code
much better:
.IP
.nf
\f[C]
function looseJsonParse(obj) {
  return eval?.(\[ga]\[dq]use strict\[dq];(${obj})\[ga]);
}
console.log(looseJsonParse(\[dq]{ a: 4 - 1, b: function () {}, c: new Date() }\[dq]));
\f[R]
.fi
.PP
The two code snippets above may seem to work the same way, but they do
not; the first one using direct eval suffers from multiple problems.
.IP \[bu] 2
It is a great deal slower, due to more scope inspections.
Notice \f[V]c: new Date()\f[R] in the evaluated string.
In the indirect eval version, the object is being evaluated in the
global scope, so it is safe for the interpreter to assume that
\f[V]Date\f[R] refers to the global \f[V]Date()\f[R] constructor instead
of a local variable called \f[V]Date\f[R].
However, in the code using direct eval, the interpreter cannot assume
this.
For example, in the following code, \f[V]Date\f[R] in the evaluated
string doesn\[cq]t refer to \f[V]window.Date()\f[R].
.RS 2
.IP
.nf
\f[C]
function looseJsonParse(obj) {
  function Date() {}
  return eval(\[ga](${obj})\[ga]);
}
console.log(looseJsonParse(\[ga]{ a: 4 - 1, b: function () {}, c: new Date() }\[ga]));
\f[R]
.fi
.PP
Thus, in the \f[V]eval()\f[R] version of the code, the browser is forced
to make the expensive lookup call to check to see if there are any local
variables called \f[V]Date()\f[R].
.RE
.IP \[bu] 2
If not using strict mode, \f[V]var\f[R] declarations within the
\f[V]eval()\f[R] source becomes variables in the surrounding scope.
This leads to hard-to-debug issues if the string is acquired from
external input, especially if there\[cq]s an existing variable with the
same name.
.IP \[bu] 2
Direct eval can read and mutate bindings in the surrounding scope, which
may lead to external input corrupting local data.
.IP \[bu] 2
When using direct \f[V]eval\f[R], especially when the eval source cannot
be proven to be in strict mode, the engine \[em] and build tools \[em]
have to disable all optimizations related to inlining, because the
\f[V]eval()\f[R] source can depend on any variable name in its
surrounding scope.
.PP
However, using indirect \f[V]eval()\f[R] does not allow passing extra
bindings other than existing global variables for the evaluated source
to read.
If you need to specify additional variables that the evaluated source
should have access to, consider using the \f[V]Function()\f[R]
constructor.
.SS Using the Function() constructor
.PP
The \f[V]Function()\f[R] constructor is very similar to the indirect
eval example above: it also evaluates the JavaScript source passed to it
in the global scope without reading or mutating any local bindings, and
therefore allows engines to do more optimizations than direct
\f[V]eval()\f[R].
.PP
The difference between \f[V]eval()\f[R] and \f[V]Function()\f[R] is that
the source string passed to \f[V]Function()\f[R] is parsed as a function
body, not as a script.
There are a few nuances \[em] for example, you can use \f[V]return\f[R]
statements at the top level of a function body, but not in a script.
.PP
The \f[V]Function()\f[R] constructor is useful if you wish to create
local bindings within your eval source, by passing the variables as
parameter bindings.
.IP
.nf
\f[C]
function Date(n) {
  return [
    \[dq]Monday\[dq],
    \[dq]Tuesday\[dq],
    \[dq]Wednesday\[dq],
    \[dq]Thursday\[dq],
    \[dq]Friday\[dq],
    \[dq]Saturday\[dq],
    \[dq]Sunday\[dq],
  ][n % 7 || 0];
}
function runCodeWithDateFunction(obj) {
  return Function(\[dq]Date\[dq], \[ga]\[dq]use strict\[dq];return (${obj});\[ga])(Date);
}
console.log(runCodeWithDateFunction(\[dq]Date(5)\[dq])); // Saturday
\f[R]
.fi
.PP
Both \f[V]eval()\f[R] and \f[V]Function()\f[R] implicitly evaluate
arbitrary code, and are forbidden in strict CSP settings.
There are also additional safer (and faster!)
alternatives to \f[V]eval()\f[R] or \f[V]Function()\f[R] for common
use-cases.
.SS Using bracket accessors
.PP
You should not use \f[V]eval()\f[R] to access properties dynamically.
Consider the following example where the property of the object to be
accessed is not known until the code is executed.
This can be done with \f[V]eval()\f[R]:
.IP
.nf
\f[C]
const obj = { a: 20, b: 30 };
const propName = getPropName(); // returns \[dq]a\[dq] or \[dq]b\[dq]

const result = eval(\[ga]obj.${propName}\[ga]);
\f[R]
.fi
.PP
However, \f[V]eval()\f[R] is not necessary here \[em] in fact, it\[cq]s
more error-prone, because if \f[V]propName\f[R] is not a valid
identifier, it leads to a syntax error.
Moreover, if \f[V]getPropName\f[R] is not a function you control, this
may lead to execution of arbitrary code.
Instead, use the property accessors, which are much faster and safer:
.IP
.nf
\f[C]
const obj = { a: 20, b: 30 };
const propName = getPropName(); // returns \[dq]a\[dq] or \[dq]b\[dq]
const result = obj[propName]; // obj[\[dq]a\[dq]] is the same as obj.a
\f[R]
.fi
.PP
You can even use this method to access descendant properties.
Using \f[V]eval()\f[R], this would look like:
.IP
.nf
\f[C]
const obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns \[dq]a.b.c\[dq]

const result = eval(\[ga]obj.${propPath}\[ga]); // 0
\f[R]
.fi
.PP
Avoiding \f[V]eval()\f[R] here could be done by splitting the property
path and looping through the different properties:
.IP
.nf
\f[C]
function getDescendantProp(obj, desc) {
  const arr = desc.split(\[dq].\[dq]);
  while (arr.length) {
    obj = obj[arr.shift()];
  }
  return obj;
}

const obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns \[dq]a.b.c\[dq]
const result = getDescendantProp(obj, propPath); // 0
\f[R]
.fi
.PP
Setting a property that way works similarly:
.IP
.nf
\f[C]
function setDescendantProp(obj, desc, value) {
  const arr = desc.split(\[dq].\[dq]);
  while (arr.length > 1) {
    obj = obj[arr.shift()];
  }
  return (obj[arr[0]] = value);
}

const obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns \[dq]a.b.c\[dq]
const result = setDescendantProp(obj, propPath, 1); // obj.a.b.c is now 1
\f[R]
.fi
.PP
However, beware that using bracket accessors with unconstrained input is
not safe either \[em] it may lead to object injection
attacks (https://github.com/nodesecurity/eslint-plugin-security/blob/main/docs/the-dangers-of-square-bracket-notation.md).
.SS Using callbacks
.PP
JavaScript has first-class functions, which means you can pass functions
as arguments to other APIs, store them in variables and objects\[cq]
properties, and so on.
Many DOM APIs are designed with this in mind, so you can (and should)
write:
.IP
.nf
\f[C]
// Instead of setTimeout(\[dq]\&...\[dq], 1000) use:
setTimeout(() => {
  // \&...
}, 1000);

// Instead of elt.setAttribute(\[dq]onclick\[dq], \[dq]\&...\[dq]) use:
elt.addEventListener(\[dq]click\[dq], () => {
  // \&...
});
\f[R]
.fi
.PP
Closures are also helpful as a way to create parameterized functions
without concatenating strings.
.SS Using JSON
.PP
If the string you\[cq]re calling \f[V]eval()\f[R] on contains data (for
example, an array: \f[V]\[dq][1, 2, 3]\[dq]\f[R]), as opposed to code,
you should consider switching to JSON, which allows the string to use a
subset of JavaScript syntax to represent data.
.PP
Note that since JSON syntax is limited compared to JavaScript syntax,
many valid JavaScript literals will not parse as JSON.
For example, trailing commas are not allowed in JSON, and property names
(keys) in object literals must be enclosed in quotes.
Be sure to use a JSON serializer to generate strings that will be later
parsed as JSON.
.PP
Passing carefully constrained data instead of arbitrary code is a good
idea in general.
For example, an extension designed to scrape contents of web-pages could
have the scraping rules defined in XPath instead of JavaScript code.
.SH Examples
.SS Using eval()
.PP
In the following code, both of the statements containing
\f[V]eval()\f[R] return 42.
The first evaluates the string \f[V]\[dq]x + y + 1\[dq]\f[R]; the second
evaluates the string \f[V]\[dq]42\[dq]\f[R].
.IP
.nf
\f[C]
const x = 2;
const y = 39;
const z = \[dq]42\[dq];
eval(\[dq]x + y + 1\[dq]); // 42
eval(z); // 42
\f[R]
.fi
.SS eval() returns the completion value of statements
.PP
\f[V]eval()\f[R] returns the completion value of statements.
For \f[V]if\f[R], it would be the last expression or statement
evaluated.
.IP
.nf
\f[C]
const str = \[dq]if (a) { 1 + 1 } else { 1 + 2 }\[dq];
let a = true;
let b = eval(str);

console.log(\[ga]b is: ${b}\[ga]); // b is: 2

a = false;
b = eval(str);

console.log(\[ga]b is: ${b}\[ga]); // b is: 3
\f[R]
.fi
.PP
The following example uses \f[V]eval()\f[R] to evaluate the string
\f[V]str\f[R].
This string consists of JavaScript statements that assign \f[V]z\f[R] a
value of 42 if \f[V]x\f[R] is five, and assign 0 to \f[V]z\f[R]
otherwise.
When the second statement is executed, \f[V]eval()\f[R] will cause these
statements to be performed, and it will also evaluate the set of
statements and return the value that is assigned to \f[V]z\f[R], because
the completion value of an assignment is the assigned value.
.IP
.nf
\f[C]
const x = 5;
const str = \[ga]if (x === 5) {
  console.log(\[dq]z is 42\[dq]);
  z = 42;
} else {
  z = 0;
}\[ga];

console.log(\[dq]z is \[dq], eval(str)); // z is 42  z is 42
\f[R]
.fi
.PP
If you assign multiple values then the last value is returned.
.IP
.nf
\f[C]
let x = 5;
const str = \[ga]if (x === 5) {
  console.log(\[dq]z is 42\[dq]);
  z = 42;
  x = 420;
} else {
  z = 0;
}\[ga];

console.log(\[dq]x is\[dq], eval(str)); // z is 42  x is 420
\f[R]
.fi
.SS eval() as a string defining function requires \[lq](\[rq] and \[lq])\[rq] as prefix and suffix
.IP
.nf
\f[C]
// This is a function declaration
const fctStr1 = \[dq]function a() {}\[dq];
// This is a function expression
const fctStr2 = \[dq](function b() {})\[dq];
const fct1 = eval(fctStr1); // return undefined, but \[ga]a\[ga] is available as a global function now
const fct2 = eval(fctStr2); // return the function \[ga]b\[ga]
\f[R]
.fi
.SH See also
.IP \[bu] 2
Property accessors
.IP \[bu] 2
WebExtensions: Using eval in content scripts
