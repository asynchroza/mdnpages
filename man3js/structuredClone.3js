.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "structuredClone" "JS" "November 9, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
structuredClone \- structuredClone() global function
.SH SYNOPSIS
This feature is available in Web Workers.
.PP
The global \f[B]\f[CB]structuredClone()\f[B]\f[R] method creates a deep
clone of a given value using the structured clone algorithm.
.PP
The method also allows transferable objects in the original value to be
\f[I]transferred\f[R] rather than cloned to the new object.
Transferred objects are detached from the original object and attached
to the new object; they are no longer accessible in the original object.
.SH SYNTAX
.IP
.EX
structuredClone(value)
structuredClone(value, options)
.EE
.SS Parameters
.TP
\f[B]value\f[R]
The object to be cloned.
This can be any structured\-cloneable type.
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An object with the following properties:
.RS
.TP
\f[B]transfer\f[R]
An array of transferable objects that will be moved rather than cloned
to the returned object.
.RE
.SS Return value
The returned value is a deep copy of the original \f[CR]value\f[R].
.SS Exceptions
.TP
\f[B]DataCloneError\f[R] \f[B]DOMException\f[R]
Thrown if any part of the input value is not serializable.
.SH DESCRIPTION
This function can be used to deep copy JavaScript values.
It also supports circular references, as shown below:
.IP
.EX
// Create an object with a value and a circular reference to itself.
const original = { name: \[dq]MDN\[dq] };
original.itself = original;

// Clone it
const clone = structuredClone(original);

console.assert(clone !== original); // the objects are not the same (not same identity)
console.assert(clone.name === \[dq]MDN\[dq]); // they do have the same values
console.assert(clone.itself === clone); // and the circular reference is preserved
.EE
.SS Transferring values
Transferable objects (only) can be transferred rather than duplicated in
the cloned object, using the \f[CR]transfer\f[R] property of the
\f[CR]options\f[R] parameter.
Transferring makes the original object unusable.
.RS
.PP
\f[B]Note:\f[R] A scenario where this might be useful is when
asynchronously validating some data in a buffer before saving it.
To avoid the buffer being modified before the data is saved, you can
clone the buffer and validate that data.
If you also \f[I]transfer\f[R] the data, any attempts to modify the
original buffer will fail, preventing its accidental misuse.
.RE
.PP
The following code shows how to clone an array and transfer its
underlying resources to the new object.
On return, the original \f[CR]uInt8Array.buffer\f[R] will be cleared.
.IP
.EX
// 16MB = 1024 * 1024 * 16
const uInt8Array = Uint8Array.from({ length: 1024 * 1024 * 16 }, (v, i) => i);

const transferred = structuredClone(uInt8Array, {
  transfer: [uInt8Array.buffer],
});
console.log(uInt8Array.byteLength); // 0
.EE
.PP
You can clone any number of objects and transfer any subset of those
objects.
For example, the code below would transfer \f[CR]arrayBuffer1\f[R] from
the passed in value, but not \f[CR]arrayBuffer2\f[R].
.IP
.EX
const transferred = structuredClone(
  { x: { y: { z: arrayBuffer1, w: arrayBuffer2 } } },
  { transfer: [arrayBuffer1] },
);
.EE
.SH EXAMPLES
.SS Cloning an object
In this example, we clone an object with one member, which is an array.
After cloning, changes to each object do not affect the other object.
.IP
.EX
const mushrooms1 = {
  amanita: [\[dq]muscaria\[dq], \[dq]virosa\[dq]],
};

const mushrooms2 = structuredClone(mushrooms1);

mushrooms2.amanita.push(\[dq]pantherina\[dq]);
mushrooms1.amanita.pop();

console.log(mushrooms2.amanita); // [\[dq]muscaria\[dq], \[dq]virosa\[dq], \[dq]pantherina\[dq]]
console.log(mushrooms1.amanita); // [\[dq]muscaria\[dq]]
.EE
.SS Transferring an object
In this example we create an \f[CR]ArrayBuffer\f[R] and then clone the
object it is a member of, transferring the buffer.
We can use the buffer in the cloned object, but if we try to use the
original buffer we will get an exception.
.IP
.EX
// Create an ArrayBuffer with a size in bytes
const buffer1 = new ArrayBuffer(16);

const object1 = {
  buffer: buffer1,
};

// Clone the object containing the buffer, and transfer it
const object2 = structuredClone(object1, { transfer: [buffer1] });

// Create an array from the cloned buffer
const int32View2 = new Int32Array(object2.buffer);
int32View2[0] = 42;
console.log(int32View2[0]);

// Creating an array from the original buffer throws a TypeError
const int32View1 = new Int32Array(object1.buffer);
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#structuredclone
A polyfill of \f[CR]structuredClone\f[R]
.UE \c
\ is available in \c
.UR https://github.com/zloirock/core-js
\f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Structured clone algorithm
.IP \[bu] 2
\c
.UR https://github.com/ungap/structured-clone
Structured clone polyfill
.UE \c
