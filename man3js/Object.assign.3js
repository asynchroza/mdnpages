.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Object.assign" "JS" "February 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.assign - Object.assign()
.SH SYNOPSIS
The \f[B]\f[CB]Object.assign()\f[B]\f[R] static method copies all
\f[CR]enumerable\f[R] \f[CR]own properties\f[R] from one or more
\f[I]source objects\f[R] to a \f[I]target object\f[R].
It returns the modified target object.
.SH SYNTAX
.IP
.EX
Object.assign(target, ...sources)
.EE
.SS Parameters
.TP
\f[B]target\f[R]
The target object \[em] what to apply the sources\[cq] properties to,
which is returned after it is modified.
.TP
\f[B]sources\f[R]
The source object(s) \[em] objects containing the properties you want to
apply.
.SS Return value
The target object.
.SH DESCRIPTION
Properties in the target object are overwritten by properties in the
sources if they have the same \f[CR]key\f[R].
Later sources\[cq] properties overwrite earlier ones.
.PP
The \f[CR]Object.assign()\f[R] method only copies \f[I]enumerable\f[R]
and \f[I]own\f[R] properties from a source object to a target object.
It uses \f[CR][[Get]]\f[R] on the source and \f[CR][[Set]]\f[R] on the
target, so it will invoke getters and setters.
Therefore it \f[I]assigns\f[R] properties, versus copying or defining
new properties.
This may make it unsuitable for merging new properties into a prototype
if the merge sources contain getters.
.PP
For copying property definitions (including their enumerability) into
prototypes, use \f[CR]Object.getOwnPropertyDescriptor()\f[R] and
\f[CR]Object.defineProperty()\f[R] instead.
.PP
Both \f[CR]String\f[R] and \f[CR]Symbol\f[R] properties are copied.
.PP
In case of an error, for example if a property is non-writable, a
\f[CR]TypeError\f[R] is raised, and the \f[CR]target\f[R] object is
changed if any properties are added before the error is raised.
.RS
.PP
\f[B]Note:\f[R] \f[CR]Object.assign()\f[R] does not throw on
\f[CR]null\f[R] or \f[CR]undefined\f[R] sources.
.RE
.SH EXAMPLES
.SS Cloning an object
.IP
.EX
const obj = { a: 1 };
const copy = Object.assign({}, obj);
console.log(copy); // { a: 1 }
.EE
.SS Warning for Deep Clone
For deep cloning, we need to use alternatives, because
\f[CR]Object.assign()\f[R] copies property values.
.PP
If the source value is a reference to an object, it only copies the
reference value.
.IP
.EX
const obj1 = { a: 0, b: { c: 0 } };
const obj2 = Object.assign({}, obj1);
console.log(obj2); // { a: 0, b: { c: 0 } }

obj1.a = 1;
console.log(obj1); // { a: 1, b: { c: 0 } }
console.log(obj2); // { a: 0, b: { c: 0 } }

obj2.a = 2;
console.log(obj1); // { a: 1, b: { c: 0 } }
console.log(obj2); // { a: 2, b: { c: 0 } }

obj2.b.c = 3;
console.log(obj1); // { a: 1, b: { c: 3 } }
console.log(obj2); // { a: 2, b: { c: 3 } }

// Deep Clone
const obj3 = { a: 0, b: { c: 0 } };
const obj4 = JSON.parse(JSON.stringify(obj3));
obj3.a = 4;
obj3.b.c = 4;
console.log(obj4); // { a: 0, b: { c: 0 } }
.EE
.SS Merging objects
.IP
.EX
const o1 = { a: 1 };
const o2 = { b: 2 };
const o3 = { c: 3 };

const obj = Object.assign(o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }
console.log(o1); // { a: 1, b: 2, c: 3 }, target object itself is changed.
.EE
.SS Merging objects with same properties
.IP
.EX
const o1 = { a: 1, b: 1, c: 1 };
const o2 = { b: 2, c: 2 };
const o3 = { c: 3 };

const obj = Object.assign({}, o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }
.EE
.PP
The properties are overwritten by other objects that have the same
properties later in the parameters order.
.SS Copying symbol-typed properties
.IP
.EX
const o1 = { a: 1 };
const o2 = { [Symbol(\[dq]foo\[dq])]: 2 };

const obj = Object.assign({}, o1, o2);
console.log(obj); // { a : 1, [Symbol(\[dq]foo\[dq])]: 2 } (cf. bug 1207182 on Firefox)
Object.getOwnPropertySymbols(obj); // [Symbol(foo)]
.EE
.SS Properties on the prototype chain and non-enumerable properties cannot be copied
.IP
.EX
const obj = Object.create(
  // foo is on obj\[aq]s prototype chain.
  { foo: 1 },
  {
    bar: {
      value: 2, // bar is a non-enumerable property.
    },
    baz: {
      value: 3,
      enumerable: true, // baz is an own enumerable property.
    },
  },
);

const copy = Object.assign({}, obj);
console.log(copy); // { baz: 3 }
.EE
.SS Primitives will be wrapped to objects
.IP
.EX
const v1 = \[dq]abc\[dq];
const v2 = true;
const v3 = 10;
const v4 = Symbol(\[dq]foo\[dq]);

const obj = Object.assign({}, v1, null, v2, undefined, v3, v4);
// Primitives will be wrapped, null and undefined will be ignored.
// Note, only string wrappers can have own enumerable properties.
console.log(obj); // { \[dq]0\[dq]: \[dq]a\[dq], \[dq]1\[dq]: \[dq]b\[dq], \[dq]2\[dq]: \[dq]c\[dq] }
.EE
.SS Exceptions will interrupt the ongoing copying task
.IP
.EX
const target = Object.defineProperty({}, \[dq]foo\[dq], {
  value: 1,
  writable: false,
}); // target.foo is a read-only property

Object.assign(target, { bar: 2 }, { foo2: 3, foo: 3, foo3: 3 }, { baz: 4 });
// TypeError: \[dq]foo\[dq] is read-only
// The Exception is thrown when assigning target.foo

console.log(target.bar); // 2, the first source was copied successfully.
console.log(target.foo2); // 3, the first property of the second source was copied successfully.
console.log(target.foo); // 1, exception is thrown here.
console.log(target.foo3); // undefined, assign method has finished, foo3 will not be copied.
console.log(target.baz); // undefined, the third source will not be copied either.
.EE
.SS Copying accessors
.IP
.EX
const obj = {
  foo: 1,
  get bar() {
    return 2;
  },
};

let copy = Object.assign({}, obj);
console.log(copy);
// { foo: 1, bar: 2 }
// The value of copy.bar is obj.bar\[aq]s getter\[aq]s return value.

// This is an assign function that copies full descriptors
function completeAssign(target, ...sources) {
  sources.forEach((source) => {
    const descriptors = Object.keys(source).reduce((descriptors, key) => {
      descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
      return descriptors;
    }, {});

    // By default, Object.assign copies enumerable Symbols, too
    Object.getOwnPropertySymbols(source).forEach((sym) => {
      const descriptor = Object.getOwnPropertyDescriptor(source, sym);
      if (descriptor.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  return target;
}

copy = completeAssign({}, obj);
console.log(copy);
// { foo:1, get bar() { return 2 } }
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]Object.assign\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-object)
.IP \[bu] 2
\f[CR]Object.defineProperties()\f[R]
.IP \[bu] 2
Enumerability and ownership of properties
.IP \[bu] 2
Spread in object literals
