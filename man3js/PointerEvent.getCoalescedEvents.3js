.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "PointerEvent.getCoalescedEvents" "JS" "December 14, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
PointerEvent.getCoalescedEvents \- PointerEvent: getCoalescedEvents()
method
.SH SYNOPSIS
\f[B]Secure context\f[R]: This feature is available only in secure
contexts (HTTPS).
.PP
The \f[B]\f[CB]getCoalescedEvents()\f[B]\f[R] method of the
\f[CR]PointerEvent\f[R] interface returns a sequence of
\f[CR]PointerEvent\f[R] instances that were coalesced (merged) into a
single \f[CR]pointermove\f[R] or \f[CR]pointerrawupdate\f[R] event.
Instead of a stream of many \f[CR]pointermove\f[R] events, user agents
coalesce multiple updates into a single event.
This helps with performance as the user agent has less event handling to
perform, but there is a reduction in the granularity and accuracy when
tracking, especially with fast and large movements.
.PP
The \f[B]\f[CB]getCoalescedEvents()\f[B]\f[R] method lets applications
access all un\-coalesced position changes for precise handling of
pointer movement data where necessary.
Un\-coalesced position changes are desirable in drawing applications,
for instance, where having access to all events helps to build smoother
curves that better match the movement of a pointer.
.PP
For an illustration of coalesced events, see \c
.UR https://w3c.github.io/pointerevents/#figure_coalesced
Figure 7 in the specification
.UE \c
\&.
.SH SYNTAX
.IP
.EX
getCoalescedEvents()
.EE
.SS Parameters
None.
.SS Return value
A sequence of \f[CR]PointerEvent\f[R] instances.
.SH EXAMPLE
.SS HTML
.IP
.EX
<canvas id=\[dq]target\[dq] width=\[dq]600\[dq] height=\[dq]300\[dq]></canvas>
.EE
.SS JavaScript
.IP
.EX
const canvas = document.getElementById(\[dq]target\[dq]);
const ctx = canvas.getContext(\[dq]2d\[dq]);

const pointerEvents = [];

function drawCircle(x, y, color) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // draw the last 20 events
  if (pointerEvents.length > 20) {
    pointerEvents.shift();
  }
  pointerEvents.push({ x, y, color });

  for (const pointerEvent of pointerEvents) {
    ctx.beginPath();
    ctx.arc(pointerEvent.x, pointerEvent.y, 10, 0, 2 * Math.PI);
    ctx.strokeStyle = pointerEvent.color;
    ctx.stroke();
  }
}

canvas.addEventListener(\[dq]pointermove\[dq], (e) => {
  // draw a circle for the current event
  drawCircle(e.clientX, e.clientY, \[dq]black\[dq]);

  const coalescedEvents = e.getCoalescedEvents();
  for (let coalescedEvent of coalescedEvents) {
    // give it an offset so we can see the difference and color it red
    drawCircle(coalescedEvent.clientX + 20, coalescedEvent.clientY + 20, \[dq]red\[dq]);
  }
});
.EE
.SS Result
