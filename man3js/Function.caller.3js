.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Function.caller" "JS" "April 12, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Function.caller - Function.prototype.caller
.SH SYNOPSIS
*(non-standard)**(deprecated)*
.RS
.PP
\f[B]Note:\f[R] In strict mode, accessing \f[CR]caller\f[R] of a
function throws an error \[em] the API is removed with no replacement.
This is to prevent code from being able to \[lq]walk the stack\[rq],
which both poses security risks and severely limits the possibility of
optimizations like inlining and tail-call optimization.
For more explanation, you can read the rationale for the deprecation of
\f[CR]arguments.callee\f[R].
.RE
.PP
The \f[B]\f[CB]caller\f[B]\f[R] accessor property of \f[CR]Function\f[R]
instances returns the function that invoked this function.
For strict, arrow, async, and generator functions, accessing the
\f[CR]caller\f[R] property throws a \f[CR]TypeError\f[R].
.SH DESCRIPTION
If the function \f[CR]f\f[R] was invoked by the top-level code, the
value of \f[CR]f.caller\f[R] is \f[CR]null\f[R]; otherwise it\[cq]s the
function that called \f[CR]f\f[R].
If the function that called \f[CR]f\f[R] is a strict mode function, the
value of \f[CR]f.caller\f[R] is also \f[CR]null\f[R].
.PP
Note that the only behavior specified by the ECMAScript specification is
that \f[CR]Function.prototype\f[R] has an initial \f[CR]caller\f[R]
accessor that unconditionally throws a \f[CR]TypeError\f[R] for any
\f[CR]get\f[R] or \f[CR]set\f[R] request (known as a \[lq]poison pill
accessor\[rq]), and that implementations are not allowed to change this
semantic for any function except non-strict plain functions, in which
case it must not have the value of a strict mode function.
The actual behavior of the \f[CR]caller\f[R] property, if it\[cq]s
anything other than throwing an error, is implementation-defined.
For example, Chrome defines it as an own data property, while Firefox
and Safari extend the initial poison-pill
\f[CR]Function.prototype.caller\f[R] accessor to specially handle
\f[CR]this\f[R] values that are non-strict functions.
.IP
.EX
(function f() {
  if (Object.hasOwn(f, \[dq]caller\[dq])) {
    console.log(
      \[dq]caller is an own property with descriptor\[dq],
      Object.getOwnPropertyDescriptor(f, \[dq]caller\[dq]),
    );
  } else {
    console.log(
      \[dq]f doesn\[aq]t have an own property named caller. Trying to get f.[[Prototype]].caller\[dq],
    );
    console.log(
      Object.getOwnPropertyDescriptor(
        Object.getPrototypeOf(f),
        \[dq]caller\[dq],
      ).get.call(f),
    );
  }
})();

// In Chrome:
// caller is an own property with descriptor {value: null, writable: false, enumerable: false, configurable: false}

// In Firefox:
// f doesn\[aq]t have an own property named caller. Trying to get f.[[Prototype]].caller
// null
.EE
.PP
This property replaces the obsolete \f[CR]arguments.caller\f[R] property
of the \f[CR]arguments\f[R] object.
.PP
The special property \f[CR]__caller__\f[R], which returned the
activation object of the caller thus allowing to reconstruct the stack,
was removed for security reasons.
.SH EXAMPLES
.SS Checking the value of a function\[cq]s caller property
The following code checks the value a function\[cq]s \f[CR]caller\f[R]
property.
.IP
.EX
function myFunc() {
  if (myFunc.caller === null) {
    return \[dq]The function was called from the top!\[dq];
  } else {
    return \[ga]This function\[aq]s caller was ${myFunc.caller}\[ga];
  }
}
.EE
.SS Reconstructing the stack and recursion
Note that in case of recursion, you can\[cq]t reconstruct the call stack
using this property.
Consider:
.IP
.EX
function f(n) {
  g(n - 1);
}
function g(n) {
  if (n > 0) {
    f(n);
  } else {
    stop();
  }
}
f(2);
.EE
.PP
At the moment \f[CR]stop()\f[R] is called the call stack will be:
.IP
.EX
f(2) -> g(1) -> f(1) -> g(0) -> stop()
.EE
.PP
The following is true:
.IP
.EX
stop.caller === g && f.caller === g && g.caller === f;
.EE
.PP
so if you tried to get the stack trace in the \f[CR]stop()\f[R] function
like this:
.IP
.EX
let f = stop;
let stack = \[dq]Stack trace:\[dq];
while (f) {
  stack += \[ga]\[rs]n${f.name}\[ga];
  f = f.caller;
}
.EE
.PP
the loop would never stop.
.SS Strict mode caller
If the caller is a strict mode function, the value of \f[CR]caller\f[R]
is \f[CR]null\f[R].
.IP
.EX
function callerFunc() {
  calleeFunc();
}

function strictCallerFunc() {
  \[dq]use strict\[dq];
  calleeFunc();
}

function calleeFunc() {
  console.log(calleeFunc.caller);
}

(function () {
  callerFunc();
})();
// Logs [Function: callerFunc]

(function () {
  strictCallerFunc();
})();
// Logs null
.EE
