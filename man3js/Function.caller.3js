.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Function.caller" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Function.caller - Function.prototype.caller
.SH SYNOPSIS
.PP
*(non-standard)**(deprecated)*
.RS
.PP
\f[B]Note:\f[R] In strict mode, accessing \f[V]caller\f[R] of a function
throws an error \[em] the API is removed with no replacement.
This is to prevent code from being able to \[lq]walk the stack\[rq],
which both poses security risks and severely limits the possibility of
optimizations like inlining and tail-call optimization.
For more explanation, you can read the rationale for the deprecation of
\f[V]arguments.callee\f[R].
.RE
.PP
The \f[B]\f[VB]caller\f[B]\f[R] accessor property of \f[V]Function\f[R]
instances returns the function that invoked this function.
For strict, arrow, async, and generator functions, accessing the
\f[V]caller\f[R] property throws a \f[V]TypeError\f[R].
.SH DESCRIPTION
.PP
If the function \f[V]f\f[R] was invoked by the top-level code, the value
of \f[V]f.caller\f[R] is \f[V]null\f[R]; otherwise it\[cq]s the function
that called \f[V]f\f[R].
If the function that called \f[V]f\f[R] is a strict mode function, the
value of \f[V]f.caller\f[R] is also \f[V]null\f[R].
.PP
Note that the only behavior specified by the ECMAScript specification is
that \f[V]Function.prototype\f[R] has an initial \f[V]caller\f[R]
accessor that unconditionally throws a \f[V]TypeError\f[R] for any
\f[V]get\f[R] or \f[V]set\f[R] request (known as a \[lq]poison pill
accessor\[rq]), and that implementations are not allowed to change this
semantic for any function except non-strict plain functions, in which
case it must not have the value of a strict mode function.
The actual behavior of the \f[V]caller\f[R] property, if it\[cq]s
anything other than throwing an error, is implementation-defined.
For example, Chrome defines it as an own data property, while Firefox
and Safari extend the initial poison-pill
\f[V]Function.prototype.caller\f[R] accessor to specially handle
\f[V]this\f[R] values that are non-strict functions.
.IP
.nf
\f[C]
(function f() {
  if (Object.hasOwn(f, \[dq]caller\[dq])) {
    console.log(
      \[dq]caller is an own property with descriptor\[dq],
      Object.getOwnPropertyDescriptor(f, \[dq]caller\[dq]),
    );
  } else {
    console.log(
      \[dq]f doesn\[aq]t have an own property named caller. Trying to get f.[[Prototype]].caller\[dq],
    );
    console.log(
      Object.getOwnPropertyDescriptor(
        Object.getPrototypeOf(f),
        \[dq]caller\[dq],
      ).get.call(f),
    );
  }
})();

// In Chrome:
// caller is an own property with descriptor {value: null, writable: false, enumerable: false, configurable: false}

// In Firefox:
// f doesn\[aq]t have an own property named caller. Trying to get f.[[Prototype]].caller
// null
\f[R]
.fi
.PP
This property replaces the obsolete \f[V]arguments.caller\f[R] property
of the \f[V]arguments\f[R] object.
.PP
The special property \f[V]__caller__\f[R], which returned the activation
object of the caller thus allowing to reconstruct the stack, was removed
for security reasons.
.SH EXAMPLES
.SS Checking the value of a function\[cq]s caller property
.PP
The following code checks the value a function\[cq]s \f[V]caller\f[R]
property.
.IP
.nf
\f[C]
function myFunc() {
  if (myFunc.caller === null) {
    return \[dq]The function was called from the top!\[dq];
  } else {
    return \[ga]This function\[aq]s caller was ${myFunc.caller}\[ga];
  }
}
\f[R]
.fi
.SS Reconstructing the stack and recursion
.PP
Note that in case of recursion, you can\[cq]t reconstruct the call stack
using this property.
Consider:
.IP
.nf
\f[C]
function f(n) {
  g(n - 1);
}
function g(n) {
  if (n > 0) {
    f(n);
  } else {
    stop();
  }
}
f(2);
\f[R]
.fi
.PP
At the moment \f[V]stop()\f[R] is called the call stack will be:
.IP
.nf
\f[C]
f(2) -> g(1) -> f(1) -> g(0) -> stop()
\f[R]
.fi
.PP
The following is true:
.IP
.nf
\f[C]
stop.caller === g && f.caller === g && g.caller === f;
\f[R]
.fi
.PP
so if you tried to get the stack trace in the \f[V]stop()\f[R] function
like this:
.IP
.nf
\f[C]
let f = stop;
let stack = \[dq]Stack trace:\[dq];
while (f) {
  stack += \[ga]\[rs]n${f.name}\[ga];
  f = f.caller;
}
\f[R]
.fi
.PP
the loop would never stop.
.SS Strict mode caller
.PP
If the caller is a strict mode function, the value of \f[V]caller\f[R]
is \f[V]null\f[R].
.IP
.nf
\f[C]
function callerFunc() {
  calleeFunc();
}

function strictCallerFunc() {
  \[dq]use strict\[dq];
  calleeFunc();
}

function calleeFunc() {
  console.log(calleeFunc.caller);
}

(function () {
  callerFunc();
})();
// Logs [Function: callerFunc]

(function () {
  strictCallerFunc();
})();
// Logs null
\f[R]
.fi
