.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "CacheStorage" "JS" "July 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
CacheStorage \- CacheStorage
.SH SYNOPSIS
The \f[B]\f[CB]CacheStorage\f[B]\f[R] interface represents the storage
for \f[CR]Cache\f[R] objects.
.PP
The interface:
.IP \[bu] 2
Provides a master directory of all the named caches that can be accessed
by a \f[CR]ServiceWorker\f[R] or other type of worker or
\f[CR]window\f[R] scope (you\[cq]re not limited to only using it with
service workers).
.IP \[bu] 2
Maintains a mapping of string names to corresponding \f[CR]Cache\f[R]
objects.
.PP
Use \f[CR]CacheStorage.open()\f[R] to obtain a \f[CR]Cache\f[R]
instance.
.PP
Use \f[CR]CacheStorage.match()\f[R] to check if a given
\f[CR]Request\f[R] is a key in any of the \f[CR]Cache\f[R] objects that
the \f[CR]CacheStorage\f[R] object tracks.
.PP
You can access \f[CR]CacheStorage\f[R] through the global
\f[CR]caches\f[R] property.
.RS
.PP
\f[B]Note:\f[R] \f[CR]CacheStorage\f[R] always rejects with a
\f[CR]SecurityError\f[R] on untrusted origins (i.e.\ those that
aren\[cq]t using HTTPS, although this definition will likely become more
complex in the future.)
When testing on Firefox, you can get around this by checking the
\f[B]Enable Service Workers over HTTP (when toolbox is open)\f[R] option
in the Firefox Devtools options/gear menu.
Furthermore, because \f[CR]CacheStorage\f[R] requires file\-system
access, it may be unavailable in private mode in Firefox.
.RE
.RS
.PP
\f[B]Note:\f[R] \f[CR]CacheStorage.match()\f[R] is a convenience method.
Equivalent functionality to match a cache entry can be implemented by
returning an array of cache names from \f[CR]CacheStorage.keys()\f[R],
opening each cache with \f[CR]CacheStorage.open()\f[R], and matching the
one you want with \f[CR]Cache.match()\f[R].
.RE
.PP
This feature is available in Web Workers.
.PP
\f[B]Secure context\f[R]: This feature is available only in secure
contexts (HTTPS).
.SH INSTANCE METHODS
.TP
\f[B]CacheStorage.match()\f[R]
Checks if a given \f[CR]Request\f[R] is a key in any of the
\f[CR]Cache\f[R] objects that the \f[CR]CacheStorage\f[R] object tracks,
and returns a \f[CR]Promise\f[R] that resolves to that match.
.TP
\f[B]CacheStorage.has()\f[R]
Returns a \f[CR]Promise\f[R] that resolves to \f[CR]true\f[R] if a
\f[CR]Cache\f[R] object matching the \f[CR]cacheName\f[R] exists.
.TP
\f[B]CacheStorage.open()\f[R]
Returns a \f[CR]Promise\f[R] that resolves to the \f[CR]Cache\f[R]
object matching the \f[CR]cacheName\f[R] (a new cache is created if it
doesn\[cq]t already exist.)
.TP
\f[B]CacheStorage.delete()\f[R]
Finds the \f[CR]Cache\f[R] object matching the \f[CR]cacheName\f[R], and
if found, deletes the \f[CR]Cache\f[R] object and returns a
\f[CR]Promise\f[R] that resolves to \f[CR]true\f[R].
If no \f[CR]Cache\f[R] object is found, it resolves to \f[CR]false\f[R].
.TP
\f[B]CacheStorage.keys()\f[R]
Returns a \f[CR]Promise\f[R] that will resolve with an array containing
strings corresponding to all of the named \f[CR]Cache\f[R] objects
tracked by the \f[CR]CacheStorage\f[R].
Use this method to iterate over a list of all the \f[CR]Cache\f[R]
objects.
.SH EXAMPLES
This code snippet is from the MDN \c
.UR
https://github.com/mdn/dom-examples/tree/main/service-worker/simple-service-worker
simple service worker example
.UE \c
\ (see \c
.UR https://bncb2v.csb.app/
simple service worker running live
.UE \c
\&.)
This service worker script waits for an \f[CR]InstallEvent\f[R] to fire,
then runs \f[CR]waitUntil\f[R] to handle the install process for the
app.
This consists of calling \f[CR]CacheStorage.open\f[R] to create a new
cache, then using \f[CR]Cache.addAll\f[R] to add a series of assets to
it.
.PP
In the second code block, we wait for a \f[CR]FetchEvent\f[R] to fire.
We construct a custom response like so:
.IP "1." 3
Check whether a match for the request is found in the CacheStorage.
If so, serve that.
.IP "2." 3
If not, fetch the request from the network, then also open the cache
created in the first block and add a clone of the request to it using
\f[CR]Cache.put\f[R]
(\f[CR]cache.put(event.request, response.clone())\f[R].)
.IP "3." 3
If this fails (e.g.\ because the network is down), return a fallback
response.
.PP
Finally, return whatever the custom response ended up being equal to,
using \f[CR]FetchEvent.respondWith\f[R].
.IP
.EX
self.addEventListener(\[dq]install\[dq], (event) => {
  event.waitUntil(
    caches
      .open(\[dq]v1\[dq])
      .then((cache) =>
        cache.addAll([
          \[dq]/\[dq],
          \[dq]/index.html\[dq],
          \[dq]/style.css\[dq],
          \[dq]/app.js\[dq],
          \[dq]/image\-list.js\[dq],
          \[dq]/star\-wars\-logo.jpg\[dq],
          \[dq]/gallery/bountyHunters.jpg\[dq],
          \[dq]/gallery/myLittleVader.jpg\[dq],
          \[dq]/gallery/snowTroopers.jpg\[dq],
        ]),
      ),
  );
});

self.addEventListener(\[dq]fetch\[dq], (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      // caches.match() always resolves
      // but in case of success response will have value
      if (response !== undefined) {
        return response;
      } else {
        return fetch(event.request)
          .then((response) => {
            // response may be used only once
            // we need to save clone to put one copy in cache
            // and serve second one
            let responseClone = response.clone();

            caches.open(\[dq]v1\[dq]).then((cache) => {
              cache.put(event.request, responseClone);
            });
            return response;
          })
          .catch(() => caches.match(\[dq]/gallery/myLittleVader.jpg\[dq]));
      }
    }),
  );
});
.EE
.PP
This snippet shows how the API can be used outside of a service worker
context, and uses the \f[CR]await\f[R] operator for much more readable
code.
.IP
.EX
// Try to get data from the cache, but fall back to fetching it live.
async function getData() {
  const cacheVersion = 1;
  const cacheName = \[ga]myapp\-${cacheVersion}\[ga];
  const url = \[dq]https://jsonplaceholder.typicode.com/todos/1\[dq];
  let cachedData = await getCachedData(cacheName, url);

  if (cachedData) {
    console.log(\[dq]Retrieved cached data\[dq]);
    return cachedData;
  }

  console.log(\[dq]Fetching fresh data\[dq]);

  const cacheStorage = await caches.open(cacheName);
  await cacheStorage.add(url);
  cachedData = await getCachedData(cacheName, url);
  await deleteOldCaches(cacheName);

  return cachedData;
}

// Get data from the cache.
async function getCachedData(cacheName, url) {
  const cacheStorage = await caches.open(cacheName);
  const cachedResponse = await cacheStorage.match(url);

  if (!cachedResponse || !cachedResponse.ok) {
    return false;
  }

  return await cachedResponse.json();
}

// Delete any old caches to respect user\[aq]s disk space.
async function deleteOldCaches(currentCache) {
  const keys = await caches.keys();

  for (const key of keys) {
    const isOurCache = key.startsWith(\[dq]myapp\-\[dq]);
    if (currentCache === key || !isOurCache) {
      continue;
    }
    caches.delete(key);
  }
}

try {
  const data = await getData();
  console.log({ data });
} catch (error) {
  console.error({ error });
}
.EE
.SH SEE ALSO
.IP \[bu] 2
Using Service Workers
.IP \[bu] 2
\f[CR]Cache\f[R]
.IP \[bu] 2
\f[CR]caches\f[R]
.IP \[bu] 2
Private Browsing / Incognito modes
