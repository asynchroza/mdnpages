.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.\[at]\[at]iterator" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Array.\[at]\[at]iterator - Array.prototype\[at]\[at]iterator
.SH SYNOPSIS
.PP
The \f[B]\f[VB][\[at]\[at]iterator]()\f[B]\f[R] method of
\f[V]Array\f[R] instances implements the iterable protocol and allows
arrays to be consumed by most syntaxes expecting iterables, such as the
spread syntax and \f[V]for...of\f[R] loops.
It returns an array iterator object that yields the value of each index
in the array.
.PP
The initial value of this property is the same function object as the
initial value of the \f[V]Array.prototype.values\f[R] property.
.SH SYNTAX
.IP
.nf
\f[C]
array[Symbol.iterator]()
\f[R]
.fi
.SS Return value
.PP
The same return value as \f[V]Array.prototype.values()\f[R]: a new
iterable iterator object that yields the value of each index in the
array.
.SH EXAMPLES
.SS Iteration using for\&...of loop
.PP
Note that you seldom need to call this method directly.
The existence of the \f[V]\[at]\[at]iterator\f[R] method makes arrays
iterable, and iterating syntaxes like the \f[V]for...of\f[R] loop
automatically calls this method to obtain the iterator to loop over.
.SS HTML
.IP
.nf
\f[C]
<ul id=\[dq]letterResult\[dq]></ul>
\f[R]
.fi
.SS JavaScript
.IP
.nf
\f[C]
const arr = [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq]];
const letterResult = document.getElementById(\[dq]letterResult\[dq]);
for (const letter of arr) {
  const li = document.createElement(\[dq]li\[dq]);
  li.textContent = letter;
  letterResult.appendChild(li);
}
\f[R]
.fi
.SS Result
.SS Manually hand-rolling the iterator
.PP
You may still manually call the \f[V]next()\f[R] method of the returned
iterator object to achieve maximum control over the iteration process.
.IP
.nf
\f[C]
const arr = [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq], \[dq]d\[dq], \[dq]e\[dq]];
const arrIter = arr[Symbol.iterator]();
console.log(arrIter.next().value); // a
console.log(arrIter.next().value); // b
console.log(arrIter.next().value); // c
console.log(arrIter.next().value); // d
console.log(arrIter.next().value); // e
\f[R]
.fi
.SS Handling strings and string arrays with the same function
.PP
Because both strings and arrays implement the iterable protocol, a
generic function can be designed to handle both inputs in the same
fashion.
This is better than calling \f[V]Array.prototype.values()\f[R] directly,
which requires the input to be an array, or at least an object with such
a method.
.IP
.nf
\f[C]
function logIterable(it) {
  if (typeof it[Symbol.iterator] !== \[dq]function\[dq]) {
    console.log(it, \[dq]is not iterable.\[dq]);
    return;
  }
  for (const letter of it) {
    console.log(letter);
  }
}

// Array
logIterable([\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq]]);
// a
// b
// c

// String
logIterable(\[dq]abc\[dq]);
// a
// b
// c

// Number
logIterable(123);
// 123 is not iterable.
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]Array.prototype[\[at]\[at]iterator]\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-array)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[V]Array\f[R]
.IP \[bu] 2
\f[V]Array.prototype.keys()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.entries()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.values()\f[R]
.IP \[bu] 2
\f[V]TypedArray.prototype[\[at]\[at]iterator]()\f[R]
.IP \[bu] 2
\f[V]String.prototype[\[at]\[at]iterator]()\f[R]
.IP \[bu] 2
\f[V]Symbol.iterator\f[R]
.IP \[bu] 2
Iteration protocols
