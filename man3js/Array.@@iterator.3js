.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Array.\[at]\[at]iterator" "JS" "April 17, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.\[at]\[at]iterator - Array.prototype\[at]\[at]iterator
.SH SYNOPSIS
The \f[B]\f[CB][\[at]\[at]iterator]()\f[B]\f[R] method of
\f[CR]Array\f[R] instances implements the iterable protocol and allows
arrays to be consumed by most syntaxes expecting iterables, such as the
spread syntax and \f[CR]for...of\f[R] loops.
It returns an array iterator object that yields the value of each index
in the array.
.PP
The initial value of this property is the same function object as the
initial value of the \f[CR]Array.prototype.values\f[R] property.
.SH SYNTAX
.IP
.EX
array[Symbol.iterator]()
.EE
.SS Return value
The same return value as \f[CR]Array.prototype.values()\f[R]: a new
iterable iterator object that yields the value of each index in the
array.
.SH EXAMPLES
.SS Iteration using for\&...of loop
Note that you seldom need to call this method directly.
The existence of the \f[CR]\[at]\[at]iterator\f[R] method makes arrays
iterable, and iterating syntaxes like the \f[CR]for...of\f[R] loop
automatically calls this method to obtain the iterator to loop over.
.SS HTML
.IP
.EX
<ul id=\[dq]letterResult\[dq]></ul>
.EE
.SS JavaScript
.IP
.EX
const arr = [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq]];
const letterResult = document.getElementById(\[dq]letterResult\[dq]);
for (const letter of arr) {
  const li = document.createElement(\[dq]li\[dq]);
  li.textContent = letter;
  letterResult.appendChild(li);
}
.EE
.SS Result
.SS Manually hand-rolling the iterator
You may still manually call the \f[CR]next()\f[R] method of the returned
iterator object to achieve maximum control over the iteration process.
.IP
.EX
const arr = [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq], \[dq]d\[dq], \[dq]e\[dq]];
const arrIter = arr[Symbol.iterator]();
console.log(arrIter.next().value); // a
console.log(arrIter.next().value); // b
console.log(arrIter.next().value); // c
console.log(arrIter.next().value); // d
console.log(arrIter.next().value); // e
.EE
.SS Handling strings and string arrays with the same function
Because both strings and arrays implement the iterable protocol, a
generic function can be designed to handle both inputs in the same
fashion.
This is better than calling \f[CR]Array.prototype.values()\f[R]
directly, which requires the input to be an array, or at least an object
with such a method.
.IP
.EX
function logIterable(it) {
  if (typeof it[Symbol.iterator] !== \[dq]function\[dq]) {
    console.log(it, \[dq]is not iterable.\[dq]);
    return;
  }
  for (const letter of it) {
    console.log(letter);
  }
}

// Array
logIterable([\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq]]);
// a
// b
// c

// String
logIterable(\[dq]abc\[dq]);
// a
// b
// c

// Number
logIterable(123);
// 123 is not iterable.
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]Array.prototype[\[at]\[at]iterator]\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-array)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.keys()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.entries()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.values()\f[R]
.IP \[bu] 2
\f[CR]TypedArray.prototype[\[at]\[at]iterator]()\f[R]
.IP \[bu] 2
\f[CR]String.prototype[\[at]\[at]iterator]()\f[R]
.IP \[bu] 2
\f[CR]Symbol.iterator\f[R]
.IP \[bu] 2
Iteration protocols
