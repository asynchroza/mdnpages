.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "OffscreenCanvas" "JS" "July 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
OffscreenCanvas \- OffscreenCanvas
.SH SYNOPSIS
When using the \f[CR]<canvas>\f[R] element or the Canvas API, rendering,
animation, and user interaction usually happen on the main execution
thread of a web application.
The computation relating to canvas animations and rendering can have a
significant impact on application performance.
.PP
The \f[B]\f[CB]OffscreenCanvas\f[B]\f[R] interface provides a canvas
that can be rendered off screen, decoupling the DOM and the Canvas API
so that the \f[CR]<canvas>\f[R] element is no longer entirely dependent
on the DOM.
Rendering operations can also be run inside a worker context, allowing
you to run some tasks in a separate thread and avoid heavy work on the
main thread.
.PP
\f[CR]OffscreenCanvas\f[R] is a transferable object.
.PP
This feature is available in Web Workers.
.SH CONSTRUCTORS
.TP
\f[B]OffscreenCanvas()\f[R]
\f[CR]OffscreenCanvas\f[R] constructor.
Creates a new \f[CR]OffscreenCanvas\f[R] object.
.SH INSTANCE PROPERTIES
.TP
\f[B]OffscreenCanvas.height\f[R]
The height of the offscreen canvas.
.TP
\f[B]OffscreenCanvas.width\f[R]
The width of the offscreen canvas.
.SH INSTANCE METHODS
.TP
\f[B]OffscreenCanvas.getContext()\f[R]
Returns a rendering context for the offscreen canvas.
.TP
\f[B]OffscreenCanvas.convertToBlob()\f[R]
Creates a \f[CR]Blob\f[R] object representing the image contained in the
canvas.
.TP
\f[B]OffscreenCanvas.transferToImageBitmap()\f[R]
Creates an \f[CR]ImageBitmap\f[R] object from the most recently rendered
image of the \f[CR]OffscreenCanvas\f[R].
See the \f[CR]API description\f[R] for important notes on managing this
\f[CR]ImageBitmap\f[R].
.SH EXAMPLES
.SS Synchronous display of frames produced by an \f[CR]OffscreenCanvas\f[R]
One way to use the \f[CR]OffscreenCanvas\f[R] API is to use a rendering
context that has been obtained from an \f[CR]OffscreenCanvas\f[R] object
to generate new frames.
Once a new frame has finished rendering in this context, the
\f[CR]transferToImageBitmap()\f[R] method can be called to save the most
recent rendered image.
This method returns an \f[CR]ImageBitmap\f[R] object, which can be used
in a variety of Web APIs and also in a second canvas without creating a
transfer copy.
.PP
To display the \f[CR]ImageBitmap\f[R], you can use an
\f[CR]ImageBitmapRenderingContext\f[R] context, which can be created by
calling \f[CR]canvas.getContext(\[dq]bitmaprenderer\[dq])\f[R] on a
(visible) canvas element.
This context only provides functionality to replace the canvas\[cq]s
contents with the given \f[CR]ImageBitmap\f[R].
A call to
\f[CR]ImageBitmapRenderingContext.transferFromImageBitmap()\f[R] with
the previously rendered and saved \f[CR]ImageBitmap\f[R] from the
OffscreenCanvas, will display the \f[CR]ImageBitmap\f[R] on the canvas
and transfer its ownership to the canvas.
A single \f[CR]OffscreenCanvas\f[R] may transfer frames into an
arbitrary number of other \f[CR]ImageBitmapRenderingContext\f[R]
objects.
.PP
Given these two \f[CR]<canvas>\f[R] elements
.IP
.EX
<canvas id=\[dq]one\[dq]></canvas> <canvas id=\[dq]two\[dq]></canvas>
.EE
.PP
the following code will provide the rendering using
\f[CR]OffscreenCanvas\f[R] as described above.
.IP
.EX
const one = document.getElementById(\[dq]one\[dq]).getContext(\[dq]bitmaprenderer\[dq]);
const two = document.getElementById(\[dq]two\[dq]).getContext(\[dq]bitmaprenderer\[dq]);

const offscreen = new OffscreenCanvas(256, 256);
const gl = offscreen.getContext(\[dq]webgl\[dq]);

// Perform some drawing for the first canvas using the gl context
const bitmapOne = offscreen.transferToImageBitmap();
one.transferFromImageBitmap(bitmapOne);

// Perform some more drawing for the second canvas
const bitmapTwo = offscreen.transferToImageBitmap();
two.transferFromImageBitmap(bitmapTwo);
.EE
.SS Asynchronous display of frames produced by an \f[CR]OffscreenCanvas\f[R]
Another way to use the \f[CR]OffscreenCanvas\f[R] API, is to call
\f[CR]transferControlToOffscreen()\f[R] on a \f[CR]<canvas>\f[R]
element, either on a worker or the main thread, which will return an
\f[CR]OffscreenCanvas\f[R] object from an \f[CR]HTMLCanvasElement\f[R]
object from the main thread.
Calling \f[CR]getContext()\f[R] will then obtain a rendering context
from that \f[CR]OffscreenCanvas\f[R].
.PP
The \f[CR]main.js\f[R] script (main thread) may look like this:
.IP
.EX
const htmlCanvas = document.getElementById(\[dq]canvas\[dq]);
const offscreen = htmlCanvas.transferControlToOffscreen();

const worker = new Worker(\[dq]offscreencanvas.js\[dq]);
worker.postMessage({ canvas: offscreen }, [offscreen]);
.EE
.PP
While the \f[CR]offscreencanvas.js\f[R] script (worker thread) can look
like this:
.IP
.EX
onmessage = (evt) => {
  const canvas = evt.data.canvas;
  const gl = canvas.getContext(\[dq]webgl\[dq]);
  // Perform some drawing using the gl context
};
.EE
.PP
It\[cq]s also possible to use \f[CR]requestAnimationFrame()\f[R] in
workers:
.IP
.EX
onmessage = (evt) => {
  const canvas = evt.data.canvas;
  const gl = canvas.getContext(\[dq]webgl\[dq]);

  function render(time) {
    // Perform some drawing using the gl context
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
};
.EE
.PP
For a full example, see the \c
.UR
https://github.com/mdn/dom-examples/tree/main/web-workers/offscreen-canvas-worker
OffscreenCanvas example source
.UE \c
\ on GitHub or run the \c
.UR
https://mdn.github.io/dom-examples/web-workers/offscreen-canvas-worker/
OffscreenCanvas example live
.UE \c
\&.
.SH SEE ALSO
.IP \[bu] 2
\f[CR]CanvasRenderingContext2D\f[R]
.IP \[bu] 2
\f[CR]OffscreenCanvasRenderingContext2D\f[R]
.IP \[bu] 2
\f[CR]ImageBitmap\f[R]
.IP \[bu] 2
\f[CR]ImageBitmapRenderingContext\f[R]
.IP \[bu] 2
\f[CR]HTMLCanvasElement.transferControlToOffscreen()\f[R]
.IP \[bu] 2
\f[CR]requestAnimationFrame()\f[R]
.IP \[bu] 2
\c
.UR https://hacks.mozilla.org/2016/01/webgl-off-the-main-thread/
WebGL Off the Main Thread \[en] Mozilla Hacks
.UE \c
\ (2016)
