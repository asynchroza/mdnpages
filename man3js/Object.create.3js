.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Object.create" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]Object.create()\f[B]\f[R] static method creates a new
object, using an existing object as the prototype of the newly created
object.
.SH Syntax
.IP
.nf
\f[C]
Object.create(proto)
Object.create(proto, propertiesObject)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]proto\f[R]
.RS 2
.IP \[bu] 2
The object which should be the prototype of the newly-created object.
.RE
.IP \[bu] 2
\f[V]propertiesObject\f[R] \f[I](optional)\f[R]
.RS 2
.IP \[bu] 2
If specified and not \f[V]undefined\f[R], an object whose enumerable own
properties specify property descriptors to be added to the newly-created
object, with the corresponding property names.
These properties correspond to the second argument of
\f[V]Object.defineProperties()\f[R].
.RE
.SS Return value
.PP
A new object with the specified prototype object and properties.
.SS Exceptions
.IP \[bu] 2
\f[V]TypeError\f[R]
.RS 2
.IP \[bu] 2
Thrown if \f[V]proto\f[R] is neither \f[V]null\f[R] nor an
\f[V]Object\f[R].
.RE
.SH Examples
.SS Classical inheritance with Object.create()
.PP
Below is an example of how to use \f[V]Object.create()\f[R] to achieve
classical inheritance.
This is for a single inheritance, which is all that JavaScript supports.
.IP
.nf
\f[C]
// Shape - superclass
function Shape() {
  this.x = 0;
  this.y = 0;
}

// superclass method
Shape.prototype.move = function (x, y) {
  this.x += x;
  this.y += y;
  console.info(\[dq]Shape moved.\[dq]);
};

// Rectangle - subclass
function Rectangle() {
  Shape.call(this); // call super constructor.
}

// subclass extends superclass
Rectangle.prototype = Object.create(Shape.prototype, {
  // If you don\[aq]t set Rectangle.prototype.constructor to Rectangle,
  // it will take the prototype.constructor of Shape (parent).
  // To avoid that, we set the prototype.constructor to Rectangle (child).
  constructor: {
    value: Rectangle,
    enumerable: false,
    writable: true,
    configurable: true,
  },
});

const rect = new Rectangle();

console.log(\[dq]Is rect an instance of Rectangle?\[dq], rect instanceof Rectangle); // true
console.log(\[dq]Is rect an instance of Shape?\[dq], rect instanceof Shape); // true
rect.move(1, 1); // Logs \[aq]Shape moved.\[aq]
\f[R]
.fi
.PP
Note that there are caveats to watch out for using \f[V]create()\f[R],
such as re-adding the \f[V]constructor\f[R] property to ensure proper
semantics.
Although \f[V]Object.create()\f[R] is believed to have better
performance than mutating the prototype with
\f[V]Object.setPrototypeOf()\f[R], the difference is in fact negligible
if no instances have been created and property accesses haven\[cq]t been
optimized yet.
In modern code, the class syntax should be preferred in any case.
.SS Using propertiesObject argument with Object.create()
.PP
\f[V]Object.create()\f[R] allows fine-tuned control over the object
creation process.
The object initializer syntax is, in fact, a syntax sugar of
\f[V]Object.create()\f[R].
With \f[V]Object.create()\f[R], we can create objects with a designated
prototype and also some properties.
Note that the second parameter maps keys to \f[I]property
descriptors\f[R] \[em] this means you can control each property\[cq]s
enumerability, configurability, etc.
as well, which you can\[cq]t do in object initializers.
.IP
.nf
\f[C]
o = {};
// Is equivalent to:
o = Object.create(Object.prototype);

o = Object.create(Object.prototype, {
  // foo is a regular data property
  foo: {
    writable: true,
    configurable: true,
    value: \[dq]hello\[dq],
  },
  // bar is an accessor property
  bar: {
    configurable: false,
    get() {
      return 10;
    },
    set(value) {
      console.log(\[dq]Setting \[ga]o.bar\[ga] to\[dq], value);
    },
  },
});

// Create a new object whose prototype is a new, empty
// object and add a single property \[aq]p\[aq], with value 42.
o = Object.create({}, { p: { value: 42 } });
\f[R]
.fi
.PP
With \f[V]Object.create()\f[R], we can create an object with
\f[V]null\f[R] as prototype.
The equivalent syntax in object initializers would be the
\f[V]__proto__\f[R] key.
.IP
.nf
\f[C]
o = Object.create(null);
// Is equivalent to:
o = { __proto__: null };
\f[R]
.fi
.PP
By default properties are \f[I]not\f[R] writable, enumerable or
configurable.
.IP
.nf
\f[C]
o.p = 24; // throws in strict mode
o.p; // 42

o.q = 12;
for (const prop in o) {
  console.log(prop);
}
// \[aq]q\[aq]

delete o.p;
// false; throws in strict mode
\f[R]
.fi
.PP
To specify a property with the same attributes as in an initializer,
explicitly specify \f[V]writable\f[R], \f[V]enumerable\f[R] and
\f[V]configurable\f[R].
.IP
.nf
\f[C]
o2 = Object.create(
  {},
  {
    p: {
      value: 42,
      writable: true,
      enumerable: true,
      configurable: true,
    },
  },
);
// This is not equivalent to:
// o2 = Object.create({ p: 42 })
// which will create an object with prototype { p: 42 }
\f[R]
.fi
.PP
You can use \f[V]Object.create()\f[R] to mimic the behavior of the
\f[V]new\f[R] operator.
.IP
.nf
\f[C]
function Constructor() {}
o = new Constructor();
// Is equivalent to:
o = Object.create(Constructor.prototype);
\f[R]
.fi
.PP
Of course, if there is actual initialization code in the
\f[V]Constructor\f[R] function, the \f[V]Object.create()\f[R] method
cannot reflect it.
.SH See also
.IP \[bu] 2
Polyfill of \f[V]Object.create\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-object)
.IP \[bu] 2
\f[V]Object.defineProperty()\f[R]
.IP \[bu] 2
\f[V]Object.defineProperties()\f[R]
.IP \[bu] 2
\f[V]Object.prototype.isPrototypeOf()\f[R]
.IP \[bu] 2
\f[V]Reflect.construct()\f[R]
.IP \[bu] 2
John Resig\[cq]s post on
getPrototypeOf() (https://johnresig.com/blog/objectgetprototypeof/)
