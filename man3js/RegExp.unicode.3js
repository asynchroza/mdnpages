.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "RegExp.unicode" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
RegExp.unicode - RegExp.prototype.unicode
.SH SYNOPSIS
.PP
The \f[B]\f[VB]unicode\f[B]\f[R] accessor property of \f[V]RegExp\f[R]
instances returns whether or not the \f[V]u\f[R] flag is used with this
regular expression.
.SH DESCRIPTION
.PP
\f[V]RegExp.prototype.unicode\f[R] has the value \f[V]true\f[R] if the
\f[V]u\f[R] flag was used; otherwise, \f[V]false\f[R].
The \f[V]u\f[R] flag enables various Unicode-related features.
With the \[lq]u\[rq] flag:
.IP \[bu] 2
Any Unicode code point escapes (\f[V]\[rs]u{xxxx}\f[R],
\f[V]\[rs]p{UnicodePropertyValue}\f[R]) will be interpreted as such
instead of identity escapes.
For example \f[V]/\[rs]u{61}/u\f[R] matches \f[V]\[dq]a\[dq]\f[R], but
\f[V]/\[rs]u{61}/\f[R] (without \f[V]u\f[R] flag) matches
\f[V]\[dq]u\[dq].repeat(61)\f[R], where the \f[V]\[rs]u\f[R] is
equivalent to a single \f[V]u\f[R].
.IP \[bu] 2
Surrogate pairs will be interpreted as whole characters instead of two
separate characters.
For example, \f[V]/[ðŸ˜„]/u\f[R] would only match \f[V]\[dq]ðŸ˜„\[dq]\f[R]
but not \f[V]\[dq]\[rs]ud83d\[dq]\f[R].
.IP \[bu] 2
When \f[V]lastIndex\f[R] is automatically advanced (such as when calling
\f[V]exec()\f[R]), unicode regexes advance by Unicode code points
instead of UTF-16 code units.
.PP
There are other changes to the parsing behavior that prevent possible
syntax mistakes (which are analogous to strict mode for regex syntax).
These syntaxes are all deprecated and only kept for web compatibility,
and you should not rely on them.
.PP
The set accessor of \f[V]unicode\f[R] is \f[V]undefined\f[R].
You cannot change this property directly.
.SH EXAMPLES
.SS Using the unicode property
.IP
.nf
\f[C]
const regex = /\[rs]u{61}/u;

console.log(regex.unicode); // true
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
\f[V]RegExp.prototype.lastIndex\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype.dotAll\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype.global\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype.hasIndices\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype.ignoreCase\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype.multiline\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype.source\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype.sticky\f[R]
