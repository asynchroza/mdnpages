.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "InternalError" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
InternalError - InternalError
.SH SYNOPSIS
.PP
\f[I](non-standard)\f[R]
.PP
The \f[B]\f[VB]InternalError\f[B] object\f[R] indicates an error that
occurred internally in the JavaScript engine.
.PP
Example cases are mostly when something is too large, e.g.:
.IP \[bu] 2
\[lq]too many switch cases\[rq],
.IP \[bu] 2
\[lq]too many parentheses in regular expression\[rq],
.IP \[bu] 2
\[lq]array initializer too large\[rq],
.IP \[bu] 2
\[lq]too much recursion\[rq].
.PP
\f[V]InternalError\f[R] is a subclass of \f[V]Error\f[R].
.SH CONSTRUCTOR
.TP
\f[B]InternalError()\f[R] \f[I](non-standard)\f[R]
Creates a new \f[V]InternalError\f[R] object.
.SH INSTANCE PROPERTIES
.PP
\f[I]Also inherits instance properties from its parent
\f[VI]Error\f[I]\f[R].
.PP
These properties are defined on \f[V]InternalError.prototype\f[R] and
shared by all \f[V]InternalError\f[R] instances.
.TP
\f[B]InternalError.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[V]InternalError\f[R] instances, the initial value is the
\f[V]InternalError\f[R] constructor.
.TP
\f[B]InternalError.prototype.name\f[R]
Represents the name for the type of error.
For \f[V]InternalError.prototype.name\f[R], the initial value is
\f[V]\[dq]InternalError\[dq]\f[R].
.SH INSTANCE METHODS
.PP
\f[I]Inherits instance methods from its parent \f[VI]Error\f[I]\f[R].
.SH EXAMPLES
.SS Too much recursion
.PP
This recursive function runs 10 times, as per the exit condition.
.IP
.nf
\f[C]
function loop(x) {
  // \[dq]x >= 10\[dq] is the exit condition
  if (x >= 10) return;

  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);
\f[R]
.fi
.PP
Setting this condition to an extremely high value, may not work:
.PP
\f[B]Bad\f[R]
.IP
.nf
\f[C]
function loop(x) {
  if (x >= 1000000000000) return;

  // do stuff
  loop(x + 1);
}
loop(0);

// InternalError: too much recursion
\f[R]
.fi
.PP
For more information, see InternalError: too much recursion.
