'\" t
.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Object.constructor" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]constructor\f[B]\f[R] data property of an
\f[V]Object\f[R] instance returns a reference to the constructor
function that created the instance object.
Note that the value of this property is a reference to \f[I]the function
itself\f[R], not a string containing the function\[cq]s name.
.RS
.PP
\f[B]Note:\f[R] This is a property of JavaScript objects.
For the \f[V]constructor\f[R] method in classes, see its own reference
page.
.RE
.SH Value
.PP
A reference to the constructor function that created the instance
object.
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
yes
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
yes
T}
.TE
.RS
.PP
\f[B]Note:\f[R] This property is created by default on the
\f[V]prototype\f[R] property of every constructor function and is
inherited by all objects created by that constructor.
.RE
.SH Description
.PP
Any object (with the exception of \f[V]null\f[R] prototype objects) will
have a \f[V]constructor\f[R] property on its \f[V][[Prototype]]\f[R].
Objects created with literals will also have a \f[V]constructor\f[R]
property that points to the constructor type for that object \[em] for
example, array literals create \f[V]Array\f[R] objects, and object
literals create plain objects.
.IP
.nf
\f[C]
const o1 = {};
o1.constructor === Object; // true

const o2 = new Object();
o2.constructor === Object; // true

const a1 = [];
a1.constructor === Array; // true

const a2 = new Array();
a2.constructor === Array; // true

const n = 3;
n.constructor === Number; // true
\f[R]
.fi
.PP
Note that \f[V]constructor\f[R] usually comes from the constructor\[cq]s
\f[V]prototype\f[R] property.
If you have a longer prototype chain, you can usually expect every
object in the chain to have a \f[V]constructor\f[R] property.
.IP
.nf
\f[C]
const o = new TypeError(); // Inheritance: TypeError -> Error -> Object
const proto = Object.getPrototypeOf;
proto(o).constructor === TypeError; // true
proto(proto(o)).constructor === Error; // true
proto(proto(proto(o))).constructor === Object; // true
\f[R]
.fi
.SH Examples
.SS Displaying the constructor of an object
.PP
The following example creates a constructor (\f[V]Tree\f[R]) and an
object of that type (\f[V]theTree\f[R]).
The example then displays the \f[V]constructor\f[R] property for the
object \f[V]theTree\f[R].
.IP
.nf
\f[C]
function Tree(name) {
  this.name = name;
}

const theTree = new Tree(\[dq]Redwood\[dq]);
console.log(\[ga]theTree.constructor is ${theTree.constructor}\[ga]);
\f[R]
.fi
.PP
This example displays the following output:
.IP
.nf
\f[C]
theTree.constructor is function Tree(name) {
  this.name = name;
}
\f[R]
.fi
.SS Assigning the constructor property to an object
.PP
One can assign the \f[V]constructor\f[R] property of non-primitives.
.IP
.nf
\f[C]
const arr = [];
arr.constructor = String;
arr.constructor === String; // true
arr instanceof String; // false
arr instanceof Array; // true

const foo = new Foo();
foo.constructor = \[dq]bar\[dq];
foo.constructor === \[dq]bar\[dq]; // true

// etc.
\f[R]
.fi
.PP
This does not overwrite the old \f[V]constructor\f[R] property \[em] it
was originally present on the instance\[cq]s \f[V][[Prototype]]\f[R],
not as its own property.
.IP
.nf
\f[C]
const arr = [];
Object.hasOwn(arr, \[dq]constructor\[dq]); // false
Object.hasOwn(Object.getPrototypeOf(arr), \[dq]constructor\[dq]); // true

arr.constructor = String;
Object.hasOwn(arr, \[dq]constructor\[dq]); // true \[em] the instance property shadows the one on its prototype
\f[R]
.fi
.PP
But even when \f[V]Object.getPrototypeOf(a).constructor\f[R] is
re-assigned, it won\[cq]t change other behaviors of the object.
For example, the behavior of \f[V]instanceof\f[R] is controlled by
\f[V]Symbol.hasInstance\f[R], not \f[V]constructor\f[R]:
.IP
.nf
\f[C]
const arr = [];
arr.constructor = String;
arr instanceof String; // false
arr instanceof Array; // true
\f[R]
.fi
.PP
There is nothing protecting the \f[V]constructor\f[R] property from
being re-assigned or shadowed, so using it to detect the type of a
variable should usually be avoided in favor of less fragile ways like
\f[V]instanceof\f[R] and \f[V]Symbol.toStringTag\f[R] for objects, or
\f[V]typeof\f[R] for primitives.
.SS Changing the constructor of a constructor function\[cq]s prototype
.PP
Every constructor has a \f[V]prototype\f[R] property, which will become
the instance\[cq]s \f[V][[Prototype]]\f[R] when called via the
\f[V]new\f[R] operator.
\f[V]ConstructorFunction.prototype.constructor\f[R] will therefore
become a property on the instance\[cq]s \f[V][[Prototype]]\f[R], as
previously demonstrated.
.PP
However, if \f[V]ConstructorFunction.prototype\f[R] is re-assigned, the
\f[V]constructor\f[R] property will be lost.
For example, the following is a common way to create an inheritance
pattern:
.IP
.nf
\f[C]
function Parent() {
  // \&...
}
Parent.prototype.parentMethod = function () {};

function Child() {
  Parent.call(this); // Make sure everything is initialized properly
}
// Pointing the [[Prototype]] of Child.prototype to Parent.prototype
Child.prototype = Object.create(Parent.prototype);
\f[R]
.fi
.PP
The \f[V]constructor\f[R] of instances of \f[V]Child\f[R] will be
\f[V]Parent\f[R] due to \f[V]Child.prototype\f[R] being re-assigned.
.PP
This is usually not a big deal \[em] the language almost never reads the
\f[V]constructor\f[R] property of an object.
The only exception is when using \f[V]\[at]\[at]species\f[R] to create
new instances of a class, but such cases are rare, and you should be
using the \f[V]extends\f[R] syntax to subclass builtins anyway.
.PP
However, ensuring that \f[V]Child.prototype.constructor\f[R] always
points to \f[V]Child\f[R] itself is crucial when some caller is using
\f[V]constructor\f[R] to access the original class from an instance.
Take the following case: the object has the \f[V]create()\f[R] method to
create itself.
.IP
.nf
\f[C]
function Parent() {
  // \&...
}
function CreatedConstructor() {
  Parent.call(this);
}

CreatedConstructor.prototype = Object.create(Parent.prototype);

CreatedConstructor.prototype.create = function () {
  return new this.constructor();
};

new CreatedConstructor().create().create(); // TypeError: new CreatedConstructor().create().create is undefined, since constructor === Parent
\f[R]
.fi
.PP
In the example above, an exception is thrown, since the
\f[V]constructor\f[R] links to \f[V]Parent\f[R].
To avoid this, just assign the necessary constructor you are going to
use.
.IP
.nf
\f[C]
function Parent() {
  // \&...
}
function CreatedConstructor() {
  // \&...
}

CreatedConstructor.prototype = Object.create(Parent.prototype, {
  // Return original constructor to Child
  constructor: {
    value: CreatedConstructor,
    enumerable: false, // Make it non-enumerable, so it won\[aq]t appear in \[ga]for...in\[ga] loop
    writable: true,
    configurable: true,
  },
});

CreatedConstructor.prototype.create = function () {
  return new this.constructor();
};

new CreatedConstructor().create().create(); // it\[aq]s pretty fine
\f[R]
.fi
.PP
Note that when manually adding the \f[V]constructor\f[R] property,
it\[cq]s crucial to make the property non-enumerable, so
\f[V]constructor\f[R] won\[cq]t be visited in \f[V]for...in\f[R] loops
\[em] as it normally isn\[cq]t.
.PP
If the code above looks like too much boilerplate, you may also consider
using \f[V]Object.setPrototypeOf()\f[R] to manipulate the prototype
chain.
.IP
.nf
\f[C]
function Parent() {
  // \&...
}
function CreatedConstructor() {
  // \&...
}

Object.setPrototypeOf(CreatedConstructor.prototype, Parent.prototype);

CreatedConstructor.prototype.create = function () {
  return new this.constructor();
};

new CreatedConstructor().create().create(); // still works without re-creating constructor property
\f[R]
.fi
.PP
\f[V]Object.setPrototypeOf()\f[R] comes with its potential performance
downsides because all previously created objects involved in the
prototype chain have to be re-compiled; but if the above initialization
code happens before \f[V]Parent\f[R] or \f[V]CreatedConstructor\f[R] are
constructed, the effect should be minimal.
.PP
Let\[cq]s consider one more involved case.
.IP
.nf
\f[C]
function ParentWithStatic() {}

ParentWithStatic.startPosition = { x: 0, y: 0 }; // Static member property
ParentWithStatic.getStartPosition = function () {
  return this.startPosition;
};

function Child(x, y) {
  this.position = { x, y };
}

Child.prototype = Object.create(ParentWithStatic.prototype, {
  // Return original constructor to Child
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true,
  },
});

Child.prototype.getOffsetByInitialPosition = function () {
  const position = this.position;
  // Using this.constructor, in hope that getStartPosition exists as a static method
  const startPosition = this.constructor.getStartPosition();

  return {
    offsetX: startPosition.x - position.x,
    offsetY: startPosition.y - position.y,
  };
};

new Child(1, 1).getOffsetByInitialPosition();
// Error: this.constructor.getStartPosition is undefined, since the
// constructor is Child, which doesn\[aq]t have the getStartPosition static method
\f[R]
.fi
.PP
For this example to work properly, we can reassign the
\f[V]Parent\f[R]\[cq]s static properties to \f[V]Child\f[R]:
.IP
.nf
\f[C]
// \&...
Object.assign(Child, ParentWithStatic); // Notice that we assign it before we create() a prototype below
Child.prototype = Object.create(ParentWithStatic.prototype, {
  // Return original constructor to Child
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true,
  },
});
// \&...
\f[R]
.fi
.PP
But even better, we can make the constructor functions themselves extend
each other, as classes\[cq] \f[V]extends\f[R] do.
.IP
.nf
\f[C]
function ParentWithStatic() {}

ParentWithStatic.startPosition = { x: 0, y: 0 }; // Static member property
ParentWithStatic.getStartPosition = function () {
  return this.startPosition;
};

function Child(x, y) {
  this.position = { x, y };
}

// Properly create inheritance!
Object.setPrototypeOf(Child.prototype, ParentWithStatic.prototype);
Object.setPrototypeOf(Child, ParentWithStatic);

Child.prototype.getOffsetByInitialPosition = function () {
  const position = this.position;
  const startPosition = this.constructor.getStartPosition();

  return {
    offsetX: startPosition.x - position.x,
    offsetY: startPosition.y - position.y,
  };
};

console.log(new Child(1, 1).getOffsetByInitialPosition()); // { offsetX: -1, offsetY: -1 }
\f[R]
.fi
.PP
Again, using \f[V]Object.setPrototypeOf()\f[R] may have adverse
performance effects, so make sure it happens immediately after the
constructor declaration and before any instances are created \[em] to
avoid objects being \[lq]tainted\[rq].
.RS
.PP
\f[B]Note:\f[R] Manually updating or setting the constructor can lead to
different and sometimes confusing consequences.
To prevent this, just define the role of \f[V]constructor\f[R] in each
specific case.
In most cases, \f[V]constructor\f[R] is not used and reassigning it is
not necessary.
.RE
.SH See also
.IP \[bu] 2
\f[V]Class declaration\f[R]
.IP \[bu] 2
\f[V]Class constructor\f[R]
.IP \[bu] 2
Glossary: constructor
