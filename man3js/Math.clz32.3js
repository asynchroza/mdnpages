.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Math.clz32" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Math.clz32 - Math.clz32()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]Math.clz32()\f[B]\f[R] static method returns the number
of leading zero bits in the 32-bit binary representation of a number.
.SH SYNTAX
.IP
.nf
\f[C]
Math.clz32(x)
\f[R]
.fi
.SS Parameters
.TP
\f[B]x\f[R]
A number.
.SS Return value
.PP
The number of leading zero bits in the 32-bit binary representation of
\f[V]x\f[R].
.SH DESCRIPTION
.PP
\f[V]clz32\f[R] is short for
\f[B]C\f[R]ount\f[B]L\f[R]eading\f[B]Z\f[R]eros\f[B]32\f[R].
.PP
If \f[V]x\f[R] is not a number, it will be converted to a number first,
then converted to a 32-bit unsigned integer.
.PP
If the converted 32-bit unsigned integer is \f[V]0\f[R], \f[V]32\f[R] is
returned, because all bits are \f[V]0\f[R].
If the most significant bit is \f[V]1\f[R] (i.e.\ the number is greater
than or equal to 231), \f[V]0\f[R] is returned.
.PP
This function is particularly useful for systems that compile to JS,
like Emscripten (https://emscripten.org).
.SH EXAMPLES
.SS Using Math.clz32()
.IP
.nf
\f[C]
Math.clz32(1); // 31
Math.clz32(1000); // 22
Math.clz32(); // 32

const stuff = [
  NaN,
  Infinity,
  -Infinity,
  0,
  -0,
  false,
  null,
  undefined,
  \[dq]foo\[dq],
  {},
  [],
];
stuff.every((n) => Math.clz32(n) === 32); // true

Math.clz32(true); // 31
Math.clz32(3.5); // 30
\f[R]
.fi
.SS Implementing Count Leading Ones and beyond
.PP
At present, there is no \f[V]Math.clon\f[R] for \[lq]Count Leading
Ones\[rq] (named \[lq]clon\[rq], not \[lq]clo\[rq], because
\[lq]clo\[rq] and \[lq]clz\[rq] are too similar especially for
non-English-speaking people).
However, a \f[V]clon\f[R] function can easily be created by inverting
the bits of a number and passing the result to \f[V]Math.clz32\f[R].
Doing this will work because the inverse of 1 is 0 and vice versa.
Thus, inverting the bits will inverse the measured quantity of 0\[cq]s
(from \f[V]Math.clz32\f[R]), thereby making \f[V]Math.clz32\f[R] count
the number of ones instead of counting the number of zeros.
.PP
Consider the following 32-bit word:
.IP
.nf
\f[C]
const a = 32776; // 00000000000000001000000000001000 (16 leading zeros)
Math.clz32(a); // 16

const b = \[ti]32776; // 11111111111111110111111111110111 (32776 inverted, 0 leading zeros)
Math.clz32(b); // 0 (this is equal to how many leading one\[aq]s there are in a)
\f[R]
.fi
.PP
Using this logic, a \f[V]clon\f[R] function can be created as follows:
.IP
.nf
\f[C]
const clz = Math.clz32;

function clon(integer) {
  return clz(\[ti]integer);
}
\f[R]
.fi
.PP
Further, this technique could be extended to create a jumpless
\[lq]Count Trailing Zeros\[rq] function, as seen below.
The \f[V]ctrz\f[R] function takes a bitwise AND of the integer with its
two\[cq]s complement.
By how two\[cq]s complement works, all trailing zeros will be converted
to ones, and then when adding 1, it would be carried over until the
first \f[V]0\f[R] (which was originally a \f[V]1\f[R]) is reached.
All bits higher than this one stay the same and are inverses of the
original integer\[cq]s bits.
Therefore, when doing bitwise AND with the original integer, all higher
bits become \f[V]0\f[R], which can be counted with \f[V]clz\f[R].
The number of trailing zeros, plus the first \f[V]1\f[R] bit, plus the
leading bits that were counted by \f[V]clz\f[R], total to 32.
.IP
.nf
\f[C]
function ctrz(integer) {
  integer >>>= 0; // coerce to Uint32
  if (integer === 0) {
    // skipping this step would make it return -1
    return 32;
  }
  integer &= -integer; // equivalent to \[ga]int = int & (\[ti]int + 1)\[ga]
  return 31 - clz(integer);
}
\f[R]
.fi
.PP
Then we can define a \[lq]Count Trailing Ones\[rq] function like so:
.IP
.nf
\f[C]
function ctron(integer) {
  return ctrz(\[ti]integer);
}
\f[R]
.fi
.PP
These helper functions can be made into an asm.js module for a potential
performance improvement.
.IP
.nf
\f[C]
const countTrailsMethods = (function (stdlib, foreign, heap) {
  \[dq]use asm\[dq];
  const clz = stdlib.Math.clz32;

  // count trailing zeros
  function ctrz(integer) {
    integer = integer | 0; // coerce to an integer
    if ((integer | 0) == 0) {
      // skipping this step would make it return -1
      return 32;
    }
    // Note: asm.js doesn\[aq]t have compound assignment operators such as &=
    integer = integer & -integer; // equivalent to \[ga]int = int & (\[ti]int + 1)\[ga]
    return (31 - clz(integer)) | 0;
  }

  // count trailing ones
  function ctron(integer) {
    integer = integer | 0; // coerce to an integer
    return ctrz(\[ti]integer) | 0;
  }

  // asm.js demands plain objects:
  return { ctrz: ctrz, ctron: ctron };
})(window, null, null);

const { ctrz, ctron } = countTrailsMethods;
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]Math.clz32\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-math)
.IP \[bu] 2
\f[V]Math\f[R]
.IP \[bu] 2
\f[V]Math.imul\f[R]
