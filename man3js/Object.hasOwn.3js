.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Object.hasOwn" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Object.hasOwn - Object.hasOwn()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]Object.hasOwn()\f[B]\f[R] static method returns
\f[V]true\f[R] if the specified object has the indicated property as its
\f[I]own\f[R] property.
If the property is inherited, or does not exist, the method returns
\f[V]false\f[R].
.RS
.PP
\f[B]Note:\f[R] \f[V]Object.hasOwn()\f[R] is intended as a replacement
for \f[V]Object.prototype.hasOwnProperty()\f[R].
.RE
.SH SYNTAX
.IP
.nf
\f[C]
Object.hasOwn(obj, prop)
\f[R]
.fi
.SS Parameters
.TP
\f[B]obj\f[R]
The JavaScript object instance to test.
.TP
\f[B]prop\f[R]
The \f[V]String\f[R] name or Symbol of the property to test.
.SS Return value
.PP
\f[V]true\f[R] if the specified object has directly defined the
specified property.
Otherwise \f[V]false\f[R]
.SH DESCRIPTION
.PP
The \f[B]\f[VB]Object.hasOwn()\f[B]\f[R] method returns \f[V]true\f[R]
if the specified property is a direct property of the object \[em] even
if the property value is \f[V]null\f[R] or \f[V]undefined\f[R].
The method returns \f[V]false\f[R] if the property is inherited, or has
not been declared at all.
Unlike the \f[V]in\f[R] operator, this method does not check for the
specified property in the object\[cq]s prototype chain.
.PP
It is recommended over \f[V]Object.prototype.hasOwnProperty()\f[R]
because it works for objects created using \f[V]Object.create(null)\f[R]
and with objects that have overridden the inherited
\f[V]hasOwnProperty()\f[R] method.
While it is possible to workaround these problems by calling
\f[V]Object.prototype.hasOwnProperty()\f[R] on an external object,
\f[V]Object.hasOwn()\f[R] is more intuitive.
.SH EXAMPLES
.SS Using hasOwn to test for a property\[cq]s existence
.PP
The following code shows how to determine whether the \f[V]example\f[R]
object contains a property named \f[V]prop\f[R].
.IP
.nf
\f[C]
const example = {};
Object.hasOwn(example, \[dq]prop\[dq]); // false - \[aq]prop\[aq] has not been defined

example.prop = \[dq]exists\[dq];
Object.hasOwn(example, \[dq]prop\[dq]); // true - \[aq]prop\[aq] has been defined

example.prop = null;
Object.hasOwn(example, \[dq]prop\[dq]); // true - own property exists with value of null

example.prop = undefined;
Object.hasOwn(example, \[dq]prop\[dq]); // true - own property exists with value of undefined
\f[R]
.fi
.SS Direct vs.\ inherited properties
.PP
The following example differentiates between direct properties and
properties inherited through the prototype chain:
.IP
.nf
\f[C]
const example = {};
example.prop = \[dq]exists\[dq];

// \[ga]hasOwn\[ga] will only return true for direct properties:
Object.hasOwn(example, \[dq]prop\[dq]); // true
Object.hasOwn(example, \[dq]toString\[dq]); // false
Object.hasOwn(example, \[dq]hasOwnProperty\[dq]); // false

// The \[ga]in\[ga] operator will return true for direct or inherited properties:
\[dq]prop\[dq] in example; // true
\[dq]toString\[dq] in example; // true
\[dq]hasOwnProperty\[dq] in example; // true
\f[R]
.fi
.SS Iterating over the properties of an object
.PP
To iterate over the enumerable properties of an object, you
\f[I]should\f[R] use:
.IP
.nf
\f[C]
const example = { foo: true, bar: true };
for (const name of Object.keys(example)) {
  // \&...
}
\f[R]
.fi
.PP
But if you need to use \f[V]for...in\f[R], you can use
\f[V]Object.hasOwn()\f[R] to skip the inherited properties:
.IP
.nf
\f[C]
const example = { foo: true, bar: true };
for (const name in example) {
  if (Object.hasOwn(example, name)) {
    // \&...
  }
}
\f[R]
.fi
.SS Checking if an Array index exists
.PP
The elements of an \f[V]Array\f[R] are defined as direct properties, so
you can use \f[V]hasOwn()\f[R] method to check whether a particular
index exists:
.IP
.nf
\f[C]
const fruits = [\[dq]Apple\[dq], \[dq]Banana\[dq], \[dq]Watermelon\[dq], \[dq]Orange\[dq]];
Object.hasOwn(fruits, 3); // true (\[aq]Orange\[aq])
Object.hasOwn(fruits, 4); // false - not defined
\f[R]
.fi
.SS Problematic cases for hasOwnProperty
.PP
This section demonstrates that \f[V]hasOwn()\f[R] is immune to the
problems that affect \f[V]hasOwnProperty\f[R].
Firstly, it can be used with objects that have reimplemented
\f[V]hasOwnProperty()\f[R]:
.IP
.nf
\f[C]
const foo = {
  hasOwnProperty() {
    return false;
  },
  bar: \[dq]The dragons be out of office\[dq],
};

if (Object.hasOwn(foo, \[dq]bar\[dq])) {
  console.log(foo.bar); // true - re-implementation of hasOwnProperty() does not affect Object
}
\f[R]
.fi
.PP
It can also be used to test objects created using
\f[V]Object.create(null)\f[R].
These do not inherit from \f[V]Object.prototype\f[R], and so
\f[V]hasOwnProperty()\f[R] is inaccessible.
.IP
.nf
\f[C]
const foo = Object.create(null);
foo.prop = \[dq]exists\[dq];
if (Object.hasOwn(foo, \[dq]prop\[dq])) {
  console.log(foo.prop); // true - works irrespective of how the object is created.
}
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]Object.hasOwn\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-object)
.IP \[bu] 2
\f[V]Object.prototype.hasOwnProperty()\f[R]
.IP \[bu] 2
Enumerability and ownership of properties
.IP \[bu] 2
\f[V]Object.getOwnPropertyNames()\f[R]
.IP \[bu] 2
\f[V]for...in\f[R]
.IP \[bu] 2
\f[V]in\f[R]
.IP \[bu] 2
JavaScript Guide: Inheritance revisited
