.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Object.hasOwn" "JS" "September 25, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.hasOwn - Object.hasOwn()
.SH SYNOPSIS
The \f[B]\f[CB]Object.hasOwn()\f[B]\f[R] static method returns
\f[CR]true\f[R] if the specified object has the indicated property as
its \f[I]own\f[R] property.
If the property is inherited, or does not exist, the method returns
\f[CR]false\f[R].
.RS
.PP
\f[B]Note:\f[R] \f[CR]Object.hasOwn()\f[R] is intended as a replacement
for \f[CR]Object.prototype.hasOwnProperty()\f[R].
.RE
.SH SYNTAX
.IP
.EX
Object.hasOwn(obj, prop)
.EE
.SS Parameters
.TP
\f[B]obj\f[R]
The JavaScript object instance to test.
.TP
\f[B]prop\f[R]
The \f[CR]String\f[R] name or Symbol of the property to test.
.SS Return value
\f[CR]true\f[R] if the specified object has directly defined the
specified property.
Otherwise \f[CR]false\f[R]
.SH DESCRIPTION
The \f[B]\f[CB]Object.hasOwn()\f[B]\f[R] method returns \f[CR]true\f[R]
if the specified property is a direct property of the object \[em] even
if the property value is \f[CR]null\f[R] or \f[CR]undefined\f[R].
The method returns \f[CR]false\f[R] if the property is inherited, or has
not been declared at all.
Unlike the \f[CR]in\f[R] operator, this method does not check for the
specified property in the object\[cq]s prototype chain.
.PP
It is recommended over \f[CR]Object.prototype.hasOwnProperty()\f[R]
because it works for \f[CR]null\f[R]-prototype objects and with objects
that have overridden the inherited \f[CR]hasOwnProperty()\f[R] method.
While it is possible to workaround these problems by calling
\f[CR]Object.prototype.hasOwnProperty()\f[R] on an external object,
\f[CR]Object.hasOwn()\f[R] is more intuitive.
.SH EXAMPLES
.SS Using hasOwn to test for a property\[cq]s existence
The following code shows how to determine whether the \f[CR]example\f[R]
object contains a property named \f[CR]prop\f[R].
.IP
.EX
const example = {};
Object.hasOwn(example, \[dq]prop\[dq]); // false - \[aq]prop\[aq] has not been defined

example.prop = \[dq]exists\[dq];
Object.hasOwn(example, \[dq]prop\[dq]); // true - \[aq]prop\[aq] has been defined

example.prop = null;
Object.hasOwn(example, \[dq]prop\[dq]); // true - own property exists with value of null

example.prop = undefined;
Object.hasOwn(example, \[dq]prop\[dq]); // true - own property exists with value of undefined
.EE
.SS Direct vs.\ inherited properties
The following example differentiates between direct properties and
properties inherited through the prototype chain:
.IP
.EX
const example = {};
example.prop = \[dq]exists\[dq];

// \[ga]hasOwn\[ga] will only return true for direct properties:
Object.hasOwn(example, \[dq]prop\[dq]); // true
Object.hasOwn(example, \[dq]toString\[dq]); // false
Object.hasOwn(example, \[dq]hasOwnProperty\[dq]); // false

// The \[ga]in\[ga] operator will return true for direct or inherited properties:
\[dq]prop\[dq] in example; // true
\[dq]toString\[dq] in example; // true
\[dq]hasOwnProperty\[dq] in example; // true
.EE
.SS Iterating over the properties of an object
To iterate over the enumerable properties of an object, you
\f[I]should\f[R] use:
.IP
.EX
const example = { foo: true, bar: true };
for (const name of Object.keys(example)) {
  // \&...
}
.EE
.PP
But if you need to use \f[CR]for...in\f[R], you can use
\f[CR]Object.hasOwn()\f[R] to skip the inherited properties:
.IP
.EX
const example = { foo: true, bar: true };
for (const name in example) {
  if (Object.hasOwn(example, name)) {
    // \&...
  }
}
.EE
.SS Checking if an Array index exists
The elements of an \f[CR]Array\f[R] are defined as direct properties, so
you can use \f[CR]hasOwn()\f[R] method to check whether a particular
index exists:
.IP
.EX
const fruits = [\[dq]Apple\[dq], \[dq]Banana\[dq], \[dq]Watermelon\[dq], \[dq]Orange\[dq]];
Object.hasOwn(fruits, 3); // true (\[aq]Orange\[aq])
Object.hasOwn(fruits, 4); // false - not defined
.EE
.SS Problematic cases for hasOwnProperty
This section demonstrates that \f[CR]hasOwn()\f[R] is immune to the
problems that affect \f[CR]hasOwnProperty\f[R].
Firstly, it can be used with objects that have reimplemented
\f[CR]hasOwnProperty()\f[R]:
.IP
.EX
const foo = {
  hasOwnProperty() {
    return false;
  },
  bar: \[dq]The dragons be out of office\[dq],
};

if (Object.hasOwn(foo, \[dq]bar\[dq])) {
  console.log(foo.bar); // true - re-implementation of hasOwnProperty() does not affect Object
}
.EE
.PP
It can also be used with \f[CR]null\f[R]-prototype objects.
These do not inherit from \f[CR]Object.prototype\f[R], and so
\f[CR]hasOwnProperty()\f[R] is inaccessible.
.IP
.EX
const foo = Object.create(null);
foo.prop = \[dq]exists\[dq];
if (Object.hasOwn(foo, \[dq]prop\[dq])) {
  console.log(foo.prop); // true - works irrespective of how the object is created.
}
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]Object.hasOwn\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-object)
.IP \[bu] 2
\f[CR]Object.prototype.hasOwnProperty()\f[R]
.IP \[bu] 2
Enumerability and ownership of properties
.IP \[bu] 2
\f[CR]Object.getOwnPropertyNames()\f[R]
.IP \[bu] 2
\f[CR]for...in\f[R]
.IP \[bu] 2
\f[CR]in\f[R]
.IP \[bu] 2
Inheritance and the prototype chain
