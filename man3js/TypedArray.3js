'\" t
.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "TypedArray" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
A \f[B]\f[BI]TypedArray\f[B]\f[R] object describes an array-like view of
an underlying binary data buffer.
There is no global property named \f[V]TypedArray\f[R], nor is there a
directly visible \f[V]TypedArray\f[R] constructor.
Instead, there are a number of different global properties, whose values
are typed array constructors for specific element types, listed below.
On the following pages you will find common properties and methods that
can be used with any typed array containing elements of any type.
.SH Description
.PP
The \f[V]TypedArray\f[R] constructor (often referred to as
\f[V]%TypedArray%\f[R] to indicate its \[lq]intrinsicness\[rq], since it
does not correspond to any global exposed to a JavaScript program)
serves as the common superclass of all \f[V]TypedArray\f[R] subclasses.
Think about \f[V]%TypedArray%\f[R] as an \[lq]abstract class\[rq]
providing a common interface of utility methods for all typed array
subclasses.
This constructor is not directly exposed: there is no global
\f[V]TypedArray\f[R] property.
It is only accessible through \f[V]Object.getPrototypeOf(Int8Array)\f[R]
and similar.
.PP
When creating an instance of a \f[V]TypedArray\f[R] subclass
(e.g.\ \f[V]Int8Array\f[R]), an array buffer is created internally in
memory or, if an \f[V]ArrayBuffer\f[R] object is given as constructor
argument, that \f[V]ArrayBuffer\f[R] is used instead.
The buffer address is saved as an internal property of the instance and
all the methods of \f[V]%TypedArray%.prototype\f[R] will set and get
values based on that array buffer address.
.SS TypedArray objects
.PP
.TS
tab(@);
lw(9.0n) lw(18.3n) lw(3.8n) lw(23.8n) lw(6.1n) lw(9.0n).
T{
Type
T}@T{
Value Range
T}@T{
Size in bytes
T}@T{
Description
T}@T{
Web IDL type
T}@T{
Equivalent C type
T}
_
T{
\f[V]Int8Array\f[R]
T}@T{
-128 to 127
T}@T{
1
T}@T{
8-bit two\[cq]s complement signed integer
T}@T{
\f[V]byte\f[R]
T}@T{
\f[V]int8_t\f[R]
T}
T{
\f[V]Uint8Array\f[R]
T}@T{
0 to 255
T}@T{
1
T}@T{
8-bit unsigned integer
T}@T{
\f[V]octet\f[R]
T}@T{
\f[V]uint8_t\f[R]
T}
T{
\f[V]Uint8ClampedArray\f[R]
T}@T{
0 to 255
T}@T{
1
T}@T{
8-bit unsigned integer (clamped)
T}@T{
\f[V]octet\f[R]
T}@T{
\f[V]uint8_t\f[R]
T}
T{
\f[V]Int16Array\f[R]
T}@T{
-32768 to 32767
T}@T{
2
T}@T{
16-bit two\[cq]s complement signed integer
T}@T{
\f[V]short\f[R]
T}@T{
\f[V]int16_t\f[R]
T}
T{
\f[V]Uint16Array\f[R]
T}@T{
0 to 65535
T}@T{
2
T}@T{
16-bit unsigned integer
T}@T{
\f[V]unsigned short\f[R]
T}@T{
\f[V]uint16_t\f[R]
T}
T{
\f[V]Int32Array\f[R]
T}@T{
-2147483648 to 2147483647
T}@T{
4
T}@T{
32-bit two\[cq]s complement signed integer
T}@T{
\f[V]long\f[R]
T}@T{
\f[V]int32_t\f[R]
T}
T{
\f[V]Uint32Array\f[R]
T}@T{
0 to 4294967295
T}@T{
4
T}@T{
32-bit unsigned integer
T}@T{
\f[V]unsigned long\f[R]
T}@T{
\f[V]uint32_t\f[R]
T}
T{
\f[V]Float32Array\f[R]
T}@T{
\f[V]-3.4E38\f[R] to \f[V]3.4E38\f[R] and \f[V]1.2E-38\f[R] is the min
positive number
T}@T{
4
T}@T{
32-bit IEEE floating point number (7 significant digits e.g.,
\f[V]1.234567\f[R])
T}@T{
\f[V]unrestricted float\f[R]
T}@T{
\f[V]float\f[R]
T}
T{
\f[V]Float64Array\f[R]
T}@T{
\f[V]-1.8E308\f[R] to \f[V]1.8E308\f[R] and \f[V]5E-324\f[R] is the min
positive number
T}@T{
8
T}@T{
64-bit IEEE floating point number (16 significant digits e.g.,
\f[V]1.23456789012345\f[R])
T}@T{
\f[V]unrestricted double\f[R]
T}@T{
\f[V]double\f[R]
T}
T{
\f[V]BigInt64Array\f[R]
T}@T{
-263 to 263 - 1
T}@T{
8
T}@T{
64-bit two\[cq]s complement signed integer
T}@T{
\f[V]bigint\f[R]
T}@T{
\f[V]int64_t (signed long long)\f[R]
T}
T{
\f[V]BigUint64Array\f[R]
T}@T{
0 to 264 - 1
T}@T{
8
T}@T{
64-bit unsigned integer
T}@T{
\f[V]bigint\f[R]
T}@T{
\f[V]uint64_t (unsigned long long)\f[R]
T}
.TE
.SS Behavior when viewing a resizable buffer
.PP
When a \f[V]TypedArray\f[R] is created as a view of a resizable buffer,
resizing the underlying buffer will have different effects on the size
of the \f[V]TypedArray\f[R] depending on whether the
\f[V]TypedArray\f[R] is constructed as length-tracking.
.PP
If a typed array is created without a specific size by omitting the
third parameter or passing \f[V]undefined\f[R], the typed array will
become \f[I]length-tracking\f[R], and will automatically resize to fit
the underlying \f[V]buffer\f[R] as the latter is resized:
.IP
.nf
\f[C]
const buffer = new ArrayBuffer(8, { maxByteLength: 16 });
const float32 = new Float32Array(buffer);

console.log(float32.byteLength); // 8
console.log(float32.length); // 2

buffer.resize(12);

console.log(float32.byteLength); // 12
console.log(float32.length); // 3
\f[R]
.fi
.PP
If a typed array is created with a specific size using the third
\f[V]length\f[R] parameter, it won\[cq]t resize to contain the
\f[V]buffer\f[R] as the latter is grown:
.IP
.nf
\f[C]
const buffer = new ArrayBuffer(8, { maxByteLength: 16 });
const float32 = new Float32Array(buffer, 0, 2);

console.log(float32.byteLength); // 8
console.log(float32.length); // 2
console.log(float32[0]); // 0, the initial value

buffer.resize(12);

console.log(float32.byteLength); // 8
console.log(float32.length); // 2
console.log(float32[0]); // 0, the initial value
\f[R]
.fi
.PP
When a \f[V]buffer\f[R] is shrunk, the viewing typed array may become
out of bounds, in which case the typed array\[cq]s observed size will
decrease to 0.
This is the only case where a non-length-tracking typed array\[cq]s
length may change.
.IP
.nf
\f[C]
const buffer = new ArrayBuffer(8, { maxByteLength: 16 });
const float32 = new Float32Array(buffer, 0, 2);

buffer.resize(7);

console.log(float32.byteLength); // 0
console.log(float32.length); // 0
console.log(float32[0]); // undefined
\f[R]
.fi
.PP
If you then grow the \f[V]buffer\f[R] again to bring the typed array
back in bounds, the typed array\[cq]s size will be restored to its
original value.
.IP
.nf
\f[C]
buffer.resize(8);

console.log(float32.byteLength); // 8
console.log(float32.length); // 2
console.log(float32[0]); // 0 - back in bounds again!
\f[R]
.fi
.PP
The same can happen for length-tracking typed arrays as well, if the
buffer is shrunk beyond the \f[V]byteOffset\f[R].
.IP
.nf
\f[C]
const buffer = new ArrayBuffer(8, { maxByteLength: 16 });
const float32 = new Float32Array(buffer, 4);
// float32 is length-tracking, but it only extends from the 4th byte
// to the end of the buffer, so if the buffer is resized to be shorter
// than 4 bytes, the typed array will become out of bounds
buffer.resize(3);
console.log(float32.byteLength); // 0
\f[R]
.fi
.SH Constructor
.PP
This object cannot be instantiated directly \[em] attempting to
construct it with \f[V]new\f[R] throws a \f[V]TypeError\f[R].
.IP
.nf
\f[C]
new (Object.getPrototypeOf(Int8Array))();
// TypeError: Abstract class TypedArray not directly constructable
\f[R]
.fi
.PP
Instead, you create an instance of a typed array of a particular type,
such as an \f[V]Int8Array\f[R] or a \f[V]BigInt64Array\f[R].
These objects all have a common syntax for their constructors:
.IP
.nf
\f[C]
new TypedArray()
new TypedArray(length)
new TypedArray(typedArray)
new TypedArray(object)

new TypedArray(buffer)
new TypedArray(buffer, byteOffset)
new TypedArray(buffer, byteOffset, length)
\f[R]
.fi
.PP
Where \f[V]TypedArray\f[R] is a constructor for one of the concrete
types.
.RS
.PP
\f[B]Note:\f[R] All \f[V]TypedArray\f[R] subclasses\[cq] constructors
can only be constructed with \f[V]new\f[R].
Attempting to call one without \f[V]new\f[R] throws a
\f[V]TypeError\f[R].
.RE
.SS Parameters
.IP \[bu] 2
\f[V]typedArray\f[R]
.RS 2
.IP \[bu] 2
When called with an instance of a \f[V]TypedArray\f[R] subclass, the
\f[V]typedArray\f[R] gets copied into a new typed array.
For a non-bigint \f[V]TypedArray\f[R] constructor, the
\f[V]typedArray\f[R] parameter can only be of one of the non-bigint
types (such as \f[V]Int32Array\f[R]).
Similarly, for a bigint \f[V]TypedArray\f[R] constructor
(\f[V]BigInt64Array\f[R] or \f[V]BigUint64Array\f[R]), the
\f[V]typedArray\f[R] parameter can only be of one of the bigint types.
Each value in \f[V]typedArray\f[R] is converted to the corresponding
type of the constructor before being copied into the new array.
The length of the new typed array will be same as the length of the
\f[V]typedArray\f[R] argument.
.RE
.IP \[bu] 2
\f[V]object\f[R]
.RS 2
.IP \[bu] 2
When called with an object that\[cq]s not a \f[V]TypedArray\f[R]
instance, a new typed array is created in the same way as the
\f[V]TypedArray.from()\f[R] method.
.RE
.IP \[bu] 2
\f[V]length\f[R] \f[I](optional)\f[R]
.RS 2
.IP \[bu] 2
When called with a non-object, the parameter will be treated as a number
specifying the length of the typed array.
An internal array buffer is created in memory, of size \f[V]length\f[R]
multiplied by \f[V]BYTES_PER_ELEMENT\f[R] bytes, filled with zeros.
Omitting all parameters is equivalent to using \f[V]0\f[R] as
\f[V]length\f[R].
.RE
.IP \[bu] 2
\f[V]buffer\f[R], \f[V]byteOffset\f[R] \f[I](optional)\f[R],
\f[V]length\f[R] \f[I](optional)\f[R]
.RS 2
.IP \[bu] 2
When called with an \f[V]ArrayBuffer\f[R] or \f[V]SharedArrayBuffer\f[R]
instance, and optionally a \f[V]byteOffset\f[R] and a \f[V]length\f[R]
argument, a new typed array view is created that views the specified
buffer.
The \f[V]byteOffset\f[R] (in bytes) and \f[V]length\f[R] (in number of
elements, each occupying \f[V]BYTES_PER_ELEMENT\f[R] bytes) parameters
specify the memory range that will be exposed by the typed array view.
If both are omitted, all of \f[V]buffer\f[R] is viewed; if only
\f[V]length\f[R] is omitted, the remainder of \f[V]buffer\f[R] starting
from \f[V]byteOffset\f[R] is viewed.
If \f[V]length\f[R] is omitted, the typed array becomes length-tracking.
.RE
.SS Exceptions
.PP
All \f[V]TypeArray\f[R] subclass constructors operate in the same way.
They would all throw the following exceptions:
.IP \[bu] 2
\f[V]TypeError\f[R]
.RS 2
.IP \[bu] 2
Thrown in one of the following cases:
.RS 2
.IP \[bu] 2
A \f[V]typedArray\f[R] is passed but it is a bigint type while the
current constructor is not, or vice versa.
.IP \[bu] 2
A \f[V]typedArray\f[R] is passed but the buffer it\[cq]s viewing is
detached, or a detached \f[V]buffer\f[R] is directly passed.
.RE
.RE
.IP \[bu] 2
\f[V]RangeError\f[R]
.RS 2
.IP \[bu] 2
Thrown in one of the following cases:
.RS 2
.IP \[bu] 2
The new typed array\[cq]s length is too large.
.IP \[bu] 2
The length of \f[V]buffer\f[R] (if the \f[V]length\f[R] parameter is not
specified) or \f[V]byteOffset\f[R] is not an integral multiple of the
new typed array\[cq]s element size.
.IP \[bu] 2
\f[V]byteOffset\f[R] is not a valid array index (an integer between 0
and 253 - 1).
.IP \[bu] 2
When creating a view from a buffer, the bounds are outside the buffer.
In other words,
\f[V]byteOffset + length * TypedArray.BYTES_PER_ELEMENT > buffer.byteLength\f[R].
.RE
.RE
.SH Static properties
.PP
These properties are defined on the \f[V]TypedArray\f[R] constructor
object and are thus shared by all \f[V]TypedArray\f[R] subclass
constructors.
.IP \[bu] 2
\f[V]TypedArray[\[at]\[at]species]\f[R]
.RS 2
.IP \[bu] 2
The constructor function used to create derived objects.
.RE
.PP
All \f[V]TypedArray\f[R] subclasses also have the following static
properties:
.IP \[bu] 2
\f[V]TypedArray.BYTES_PER_ELEMENT\f[R]
.RS 2
.IP \[bu] 2
Returns a number value of the element size for the different
\f[V]TypedArray\f[R] objects.
.RE
.SH Static methods
.PP
These methods are defined on the \f[V]TypedArray\f[R] constructor object
and are thus shared by all \f[V]TypedArray\f[R] subclass constructors.
.IP \[bu] 2
\f[V]TypedArray.from()\f[R]
.RS 2
.IP \[bu] 2
Creates a new \f[V]TypedArray\f[R] from an array-like or iterable
object.
See also \f[V]Array.from()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.of()\f[R]
.RS 2
.IP \[bu] 2
Creates a new \f[V]TypedArray\f[R] with a variable number of arguments.
See also \f[V]Array.of()\f[R].
.RE
.SH Instance properties
.PP
These properties are defined on \f[V]TypedArray.prototype\f[R] and
shared by all \f[V]TypedArray\f[R] subclass instances.
.IP \[bu] 2
\f[V]TypedArray.prototype.buffer\f[R]
.RS 2
.IP \[bu] 2
Returns the \f[V]ArrayBuffer\f[R] referenced by the typed array.
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.byteLength\f[R]
.RS 2
.IP \[bu] 2
Returns the length (in bytes) of the typed array.
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.byteOffset\f[R]
.RS 2
.IP \[bu] 2
Returns the offset (in bytes) of the typed array from the start of its
\f[V]ArrayBuffer\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.constructor\f[R]
.RS 2
.IP \[bu] 2
The constructor function that created the instance object.
\f[V]TypedArray.prototype.constructor\f[R] is the hidden
\f[V]TypedArray\f[R] constructor function, but each typed array subclass
also defines its own \f[V]constructor\f[R] property.
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.length\f[R]
.RS 2
.IP \[bu] 2
Returns the number of elements held in the typed array.
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype[\[at]\[at]toStringTag]\f[R]
.RS 2
.IP \[bu] 2
The initial value of the
\f[V]TypedArray.prototype[\[at]\[at]toStringTag]\f[R] property is a
getter that returns the same string as the typed array constructor\[cq]s
name.
It returns \f[V]undefined\f[R] if the \f[V]this\f[R] value is not one of
the typed array subclasses.
This property is used in \f[V]Object.prototype.toString()\f[R].
However, because \f[V]TypedArray\f[R] also has its own
\f[V]toString()\f[R] method, this property is not used unless you call
\f[V]Object.prototype.toString.call()\f[R] with a typed array as
\f[V]thisArg\f[R].
.RE
.PP
All \f[V]TypedArray\f[R] subclasses also have the following instance
properties:
.IP \[bu] 2
\f[V]TypedArray.prototype.BYTES_PER_ELEMENT\f[R]
.RS 2
.IP \[bu] 2
Returns a number value of the element size for the different
\f[V]TypedArray\f[R] objects.
.RE
.SH Instance methods
.PP
These methods are defined on the \f[V]TypedArray\f[R] prototype object
and are thus shared by all \f[V]TypedArray\f[R] subclass instances.
.IP \[bu] 2
\f[V]TypedArray.prototype.at()\f[R]
.RS 2
.IP \[bu] 2
Takes an integer value and returns the item at that index.
This method allows for negative integers, which count back from the last
item.
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.copyWithin()\f[R]
.RS 2
.IP \[bu] 2
Copies a sequence of array elements within the array.
See also \f[V]Array.prototype.copyWithin()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.entries()\f[R]
.RS 2
.IP \[bu] 2
Returns a new \f[I]array iterator\f[R] object that contains the
key/value pairs for each index in the array.
See also \f[V]Array.prototype.entries()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.every()\f[R]
.RS 2
.IP \[bu] 2
Tests whether all elements in the array pass the test provided by a
function.
See also \f[V]Array.prototype.every()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.fill()\f[R]
.RS 2
.IP \[bu] 2
Fills all the elements of an array from a start index to an end index
with a static value.
See also \f[V]Array.prototype.fill()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.filter()\f[R]
.RS 2
.IP \[bu] 2
Creates a new array with all of the elements of this array for which the
provided filtering function returns \f[V]true\f[R].
See also \f[V]Array.prototype.filter()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.find()\f[R]
.RS 2
.IP \[bu] 2
Returns the first \f[V]element\f[R] in the array that satisfies a
provided testing function, or \f[V]undefined\f[R] if no appropriate
element is found.
See also \f[V]Array.prototype.find()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.findIndex()\f[R]
.RS 2
.IP \[bu] 2
Returns the first index value in the array that has an element that
satisfies a provided testing function, or \f[V]-1\f[R] if no appropriate
element was found.
See also \f[V]Array.prototype.findIndex()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.findLast()\f[R]
.RS 2
.IP \[bu] 2
Returns the value of the last element in the array that satisfies a
provided testing function, or \f[V]undefined\f[R] if no appropriate
element is found.
See also \f[V]Array.prototype.findLast()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.findLastIndex()\f[R]
.RS 2
.IP \[bu] 2
Returns the index of the last element in the array that satisfies a
provided testing function, or \f[V]-1\f[R] if no appropriate element was
found.
See also \f[V]Array.prototype.findLastIndex()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.forEach()\f[R]
.RS 2
.IP \[bu] 2
Calls a function for each element in the array.
See also \f[V]Array.prototype.forEach()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.includes()\f[R]
.RS 2
.IP \[bu] 2
Determines whether a typed array includes a certain element, returning
\f[V]true\f[R] or \f[V]false\f[R] as appropriate.
See also \f[V]Array.prototype.includes()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.indexOf()\f[R]
.RS 2
.IP \[bu] 2
Returns the first (least) index of an element within the array equal to
the specified value, or \f[V]-1\f[R] if none is found.
See also \f[V]Array.prototype.indexOf()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.join()\f[R]
.RS 2
.IP \[bu] 2
Joins all elements of an array into a string.
See also \f[V]Array.prototype.join()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.keys()\f[R]
.RS 2
.IP \[bu] 2
Returns a new array iterator that contains the keys for each index in
the array.
See also \f[V]Array.prototype.keys()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.lastIndexOf()\f[R]
.RS 2
.IP \[bu] 2
Returns the last (greatest) index of an element within the array equal
to the specified value, or \f[V]-1\f[R] if none is found.
See also \f[V]Array.prototype.lastIndexOf()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.map()\f[R]
.RS 2
.IP \[bu] 2
Creates a new array with the results of calling a provided function on
every element in this array.
See also \f[V]Array.prototype.map()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.reduce()\f[R]
.RS 2
.IP \[bu] 2
Apply a function against an accumulator and each value of the array
(from left-to-right) as to reduce it to a single value.
See also \f[V]Array.prototype.reduce()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.reduceRight()\f[R]
.RS 2
.IP \[bu] 2
Apply a function against an accumulator and each value of the array
(from right-to-left) as to reduce it to a single value.
See also \f[V]Array.prototype.reduceRight()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.reverse()\f[R]
.RS 2
.IP \[bu] 2
Reverses the order of the elements of an array \[em] the first becomes
the last, and the last becomes the first.
See also \f[V]Array.prototype.reverse()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.set()\f[R]
.RS 2
.IP \[bu] 2
Stores multiple values in the typed array, reading input values from a
specified array.
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.slice()\f[R]
.RS 2
.IP \[bu] 2
Extracts a section of an array and returns a new array.
See also \f[V]Array.prototype.slice()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.some()\f[R]
.RS 2
.IP \[bu] 2
Returns \f[V]true\f[R] if at least one element in this array satisfies
the provided testing function.
See also \f[V]Array.prototype.some()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.sort()\f[R]
.RS 2
.IP \[bu] 2
Sorts the elements of an array in place and returns the array.
See also \f[V]Array.prototype.sort()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.subarray()\f[R]
.RS 2
.IP \[bu] 2
Returns a new \f[V]TypedArray\f[R] from the given start and end element
index.
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.toLocaleString()\f[R]
.RS 2
.IP \[bu] 2
Returns a localized string representing the array and its elements.
See also \f[V]Array.prototype.toLocaleString()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.toReversed()\f[R]
.RS 2
.IP \[bu] 2
Returns a new array with the elements in reversed order, without
modifying the original array.
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.toSorted()\f[R]
.RS 2
.IP \[bu] 2
Returns a new array with the elements sorted in ascending order, without
modifying the original array.
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.toString()\f[R]
.RS 2
.IP \[bu] 2
Returns a string representing the array and its elements.
See also \f[V]Array.prototype.toString()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.values()\f[R]
.RS 2
.IP \[bu] 2
Returns a new \f[I]array iterator\f[R] object that contains the values
for each index in the array.
See also \f[V]Array.prototype.values()\f[R].
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype.with()\f[R]
.RS 2
.IP \[bu] 2
Returns a new array with the element at the given index replaced with
the given value, without modifying the original array.
.RE
.IP \[bu] 2
\f[V]TypedArray.prototype[\[at]\[at]iterator]()\f[R]
.RS 2
.IP \[bu] 2
Returns a new \f[I]array iterator\f[R] object that contains the values
for each index in the array.
.RE
.SH Examples
.SS Property access
.PP
You can reference elements in the array using standard array index
syntax (that is, using bracket notation).
However, getting or setting indexed properties on typed arrays will not
search in the prototype chain for this property, even when the indices
are out of bound.
Indexed properties will consult the \f[V]ArrayBuffer\f[R] and will never
look at object properties.
You can still use named properties, just like with all objects.
.IP
.nf
\f[C]
// Setting and getting using standard array syntax
const int16 = new Int16Array(2);
int16[0] = 42;
console.log(int16[0]); // 42

// Indexed properties on prototypes are not consulted (Fx 25)
Int8Array.prototype[20] = \[dq]foo\[dq];
new Int8Array(32)[20]; // 0
// even when out of bound
Int8Array.prototype[20] = \[dq]foo\[dq];
new Int8Array(8)[20]; // undefined
// or with negative integers
Int8Array.prototype[-1] = \[dq]foo\[dq];
new Int8Array(8)[-1]; // undefined

// Named properties are allowed, though (Fx 30)
Int8Array.prototype.foo = \[dq]bar\[dq];
new Int8Array(32).foo; // \[dq]bar\[dq]
\f[R]
.fi
.SS Cannot be frozen
.PP
\f[V]TypedArray\f[R]s that aren\[cq]t empty cannot be frozen, as their
underlying \f[V]ArrayBuffer\f[R] could be mutated through another
\f[V]TypedArray\f[R] view of the buffer.
This would mean that the object would never genuinely be frozen.
.PP
\f[B]Bad\f[R]
.IP
.nf
\f[C]
const i8 = Int8Array.of(1, 2, 3);
Object.freeze(i8);
// TypeError: Cannot freeze array buffer views with elements
\f[R]
.fi
.SS ByteOffset must be aligned
.PP
When constructing a \f[V]TypedArray\f[R] as a view onto an
\f[V]ArrayBuffer\f[R], the \f[V]byteOffset\f[R] argument must be aligned
to its element size; in other words, the offset must be a multiple of
\f[V]BYTES_PER_ELEMENT\f[R].
.PP
\f[B]Bad\f[R]
.IP
.nf
\f[C]
const i32 = new Int32Array(new ArrayBuffer(4), 1);
// RangeError: start offset of Int32Array should be a multiple of 4
\f[R]
.fi
.PP
\f[B]Good\f[R]
.IP
.nf
\f[C]
const i32 = new Int32Array(new ArrayBuffer(4), 0);
\f[R]
.fi
.SS ByteLength must be aligned
.PP
Like the \f[V]byteOffset\f[R] parameter, the \f[V]byteLength\f[R]
property of an \f[V]ArrayBuffer\f[R] passed to a
\f[V]TypedArray\f[R]\[cq]s constructor must be a multiple of the
constructor\[cq]s \f[V]BYTES_PER_ELEMENT\f[R].
.PP
\f[B]Bad\f[R]
.IP
.nf
\f[C]
const i32 = new Int32Array(new ArrayBuffer(3));
// RangeError: byte length of Int32Array should be a multiple of 4
\f[R]
.fi
.PP
\f[B]Good\f[R]
.IP
.nf
\f[C]
const i32 = new Int32Array(new ArrayBuffer(4));
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of typed arrays in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-typed-arrays)
.IP \[bu] 2
JavaScript typed arrays
.IP \[bu] 2
\f[V]ArrayBuffer\f[R]
.IP \[bu] 2
\f[V]DataView\f[R]
.IP \[bu] 2
TextDecoder \[em] Helper that decode strings from numerical data
