.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Math.hypot" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Math.hypot - Math.hypot()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]Math.hypot()\f[B]\f[R] static method returns the square
root of the sum of squares of its arguments.
That is,
.PP
𝙼𝚊𝚝𝚑.𝚑𝚢𝚙𝚘𝚝(v1,v2,\&...,vn)=∑i=1nvi2=v12+v22+\&...+vn2 = =
.SH SYNTAX
.IP
.nf
\f[C]
Math.hypot()
Math.hypot(value0)
Math.hypot(value0, value1)
Math.hypot(value0, value1, /* \&... ,*/ valueN)
\f[R]
.fi
.SS Parameters
.TP
\f[B]value1\f[R], \&..., \f[B]valueN\f[R]
Numbers.
.SS Return value
.PP
The square root of the sum of squares of the given arguments.
Returns \f[V]Infinity\f[R] if any of the arguments is ±Infinity.
Otherwise, if at least one of the arguments is or is converted to
\f[V]NaN\f[R], returns \f[V]NaN\f[R].
Returns \f[V]0\f[R] if no arguments are given or all arguments are ±0.
.SH DESCRIPTION
.PP
Calculating the hypotenuse of a right triangle, or the magnitude of a
complex number, uses the formula \f[V]Math.sqrt(v1*v1 + v2*v2)\f[R],
where v1 and v2 are the lengths of the triangle\[cq]s legs, or the
complex number\[cq]s real and complex components.
The corresponding distance in 2 or more dimensions can be calculated by
adding more squares under the square root:
\f[V]Math.sqrt(v1*v1 + v2*v2 + v3*v3 + v4*v4)\f[R].
.PP
This function makes this calculation easier and faster; you call
\f[V]Math.hypot(v1, v2)\f[R], or
\f[V]Math.hypot(v1, /* \&... ,*/, vN)\f[R].
.PP
\f[V]Math.hypot\f[R] also avoids overflow/underflow problems if the
magnitude of your numbers is very large.
The largest number you can represent in JS is
\f[V]Number.MAX_VALUE\f[R], which is around 10308.
If your numbers are larger than about 10154, taking the square of them
will result in Infinity.
For example, \f[V]Math.sqrt(1e200*1e200 + 1e200*1e200) = Infinity\f[R].
If you use \f[V]hypot()\f[R] instead, you get a better answer:
\f[V]Math.hypot(1e200, 1e200) = 1.4142...e+200\f[R] .
This is also true with very small numbers.
\f[V]Math.sqrt(1e-200*1e-200 + 1e-200*1e-200) = 0\f[R], but
\f[V]Math.hypot(1e-200, 1e-200) = 1.4142...e-200\f[R].
.PP
With one argument, \f[V]Math.hypot()\f[R] is equivalent to
\f[V]Math.abs()\f[R].
\f[V]Math.hypot.length\f[R] is 2, which weakly signals that it\[cq]s
designed to handle at least two parameters.
.PP
Because \f[V]hypot()\f[R] is a static method of \f[V]Math\f[R], you
always use it as \f[V]Math.hypot()\f[R], rather than as a method of a
\f[V]Math\f[R] object you created (\f[V]Math\f[R] is not a constructor).
.SH EXAMPLES
.SS Using Math.hypot()
.IP
.nf
\f[C]
Math.hypot(3, 4); // 5
Math.hypot(3, 4, 5); // 7.0710678118654755
Math.hypot(); // 0
Math.hypot(NaN); // NaN
Math.hypot(NaN, Infinity); // Infinity
Math.hypot(3, 4, \[dq]foo\[dq]); // NaN, since +\[aq]foo\[aq] => NaN
Math.hypot(3, 4, \[dq]5\[dq]); // 7.0710678118654755, +\[aq]5\[aq] => 5
Math.hypot(-3); // 3, the same as Math.abs(-3)
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]Math.hypot\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-math)
.IP \[bu] 2
\f[V]Math.abs()\f[R]
.IP \[bu] 2
\f[V]Math.pow()\f[R]
.IP \[bu] 2
\f[V]Math.sqrt()\f[R]
