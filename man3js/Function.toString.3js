.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Function.toString" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]toString()\f[B]\f[R] method returns a string representing
the source code of the specified \f[V]Function\f[R].
.SH Syntax
.IP
.nf
\f[C]
toString()
\f[R]
.fi
.SS Return value
.PP
A string representing the source code of the function.
.SH Description
.PP
The \f[V]Function\f[R] object overrides the \f[V]toString()\f[R] method
inherited from \f[V]Object\f[R]; it does not inherit
\f[V]Object.prototype.toString\f[R].
For user-defined \f[V]Function\f[R] objects, the \f[V]toString\f[R]
method returns a string containing the source text segment which was
used to define the function.
.PP
JavaScript calls the \f[V]toString\f[R] method automatically when a
\f[V]Function\f[R] is to be represented as a text value, e.g.\ when a
function is concatenated with a string.
.PP
The \f[V]toString()\f[R] method will throw a \f[V]TypeError\f[R]
exception (\[lq]Function.prototype.toString called on incompatible
object\[rq]), if its \f[V]this\f[R] value object is not a
\f[V]Function\f[R] object.
.PP
\f[B]Bad\f[R]
.IP
.nf
\f[C]
Function.prototype.toString.call(\[dq]foo\[dq]); // throws TypeError
\f[R]
.fi
.PP
If the \f[V]toString()\f[R] method is called on built-in function
objects, a function created by \f[V]Function.prototype.bind()\f[R], or
other non-JavaScript functions, then \f[V]toString()\f[R] returns a
\f[I]native function string\f[R] which looks like
.IP
.nf
\f[C]
function someName() { [native code] }
\f[R]
.fi
.PP
For intrinsic object methods and functions, \f[V]someName\f[R] is the
initial name of the function; otherwise its content may be
implementation-defined, but will always be in property name syntax, like
\f[V][1 + 1]\f[R], \f[V]someName\f[R], or \f[V]1\f[R].
.RS
.PP
\f[B]Note:\f[R] This means using \f[V]eval()\f[R] on native function
strings is a guaranteed syntax error.
.RE
.PP
If the \f[V]toString()\f[R] method is called on a function created by
the \f[V]Function\f[R] constructor, \f[V]toString()\f[R] returns the
source code of a synthesized function declaration named
\[lq]anonymous\[rq] using the provided parameters and function body.
For example,
\f[V]Function(\[dq]a\[dq], \[dq]b\[dq], \[dq]return a + b\[dq]).toString()\f[R]
will return:
.IP
.nf
\f[C]
function anonymous(a,b
) {
return a + b
}
\f[R]
.fi
.PP
Since ES2018, the spec requires the return value of \f[V]toString()\f[R]
to be the exact same source code as it was declared, including any
whitespace and/or comments \[em] or, if the host doesn\[cq]t have the
source code available for some reason, requires returning a native
function string.
Support for this revised behavior can be found in the compatibility
table.
.SH Examples
.SS Comparing actual source code and toString results
.IP
.nf
\f[C]
function test(fn) {
  console.log(fn.toString());
}

function f() {}
class A {
  a() {}
}
function* g() {}

test(f); // \[dq]function f() {}\[dq]
test(A); // \[dq]class A { a() {} }\[dq]
test(g); // \[dq]function* g() {}\[dq]
test((a) => a); // \[dq](a) => a\[dq]
test({ a() {} }.a); // \[dq]a() {}\[dq]
test({ *a() {} }.a); // \[dq]*a() {}\[dq]
test({ [0]() {} }[0]); // \[dq][0]() {}\[dq]
test(Object.getOwnPropertyDescriptor({ get a() {} }, \[dq]a\[dq]).get); // \[dq]get a() {}\[dq]
test(Object.getOwnPropertyDescriptor({ set a(x) {} }, \[dq]a\[dq]).set); // \[dq]set a(x) {}\[dq]
test(Function.prototype.toString); // \[dq]function toString() { [native code] }\[dq]
test(function f() {}.bind(0)); // \[dq]function () { [native code] }\[dq]
test(Function(\[dq]a\[dq], \[dq]b\[dq])); // function anonymous(a\[rs]n) {\[rs]nb\[rs]n}
\f[R]
.fi
.PP
Note that after the \f[V]Function.prototype.toString()\f[R] revision,
when \f[V]toString()\f[R] is called, implementations are never allowed
to synthesize a function\[cq]s source that is not a native function
string.
The method always returns the exact source code used to create the
function \[em] including the getter and setter examples above.
The \f[V]Function\f[R] constructor itself has the capability of
synthesizing the source code for the function (and is therefore a form
of implicit \f[V]eval()\f[R]).
.SS Getting source text of a function
.PP
It is possible to get the source text of a function by coercing it to a
string \[em] for example, by wrapping it in a template literal:
.IP
.nf
\f[C]
function foo() {
  return \[dq]bar\[dq];
}
console.log(\[ga]${foo}\[ga]);
// function foo() {
//   return \[dq]bar\[dq];
// }
\f[R]
.fi
.PP
This source text is \f[I]exact\f[R], including any interspersed comments
(which won\[cq]t be stored by the engine\[cq]s internal representation
otherwise).
.IP
.nf
\f[C]
function foo /* a comment */() {
  return \[dq]bar\[dq];
}
console.log(foo.toString());
// function foo /* a comment */() {
//   return \[dq]bar\[dq];
// }
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]Object.prototype.toString()\f[R]
