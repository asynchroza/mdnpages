'\" t
.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Error.cause" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Error.cause - Error: cause
.SH SYNOPSIS
.PP
The \f[B]\f[VB]cause\f[B]\f[R] data property of an \f[V]Error\f[R]
instance indicates the specific original cause of the error.
.PP
It is used when catching and re-throwing an error with a more-specific
or useful error message in order to still have access to the original
error.
.SH VALUE
.PP
The value that was passed to the \f[V]Error()\f[R] constructor in the
\f[V]options.cause\f[R] argument.
It may not be present.
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
yes
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
yes
T}
.TE
.SH DESCRIPTION
.PP
The value of \f[V]cause\f[R] can be of any type.
You should not make assumptions that the error you caught has an
\f[V]Error\f[R] as its \f[V]cause\f[R], in the same way that you cannot
be sure the variable bound in the \f[V]catch\f[R] statement is an
\f[V]Error\f[R] either.
The \[lq]Providing structured data as the error cause\[rq] example below
shows a case where a non-error is deliberately provided as the cause.
.SH EXAMPLES
.SS Rethrowing an error with a cause
.PP
It is sometimes useful to catch an error and re-throw it with a new
message.
In this case you should pass the original error into the constructor for
the new \f[V]Error\f[R], as shown.
.IP
.nf
\f[C]
try {
  connectToDatabase();
} catch (err) {
  throw new Error(\[dq]Connecting to database failed.\[dq], { cause: err });
}
\f[R]
.fi
.PP
For a more detailed example see Error > Differentiate between similar
errors.
.SS Providing structured data as the error cause
.PP
Error messages written for human consumption may be inappropriate for
machine parsing \[em] since they\[cq]re subject to rewording or
punctuation changes that may break any existing parsing written to
consume them.
So when throwing an error from a function, as an alternative to a
human-readable error message, you can instead provide the cause as
structured data, for machine parsing.
.IP
.nf
\f[C]
function makeRSA(p, q) {
  if (!Number.isInteger(p) || !Number.isInteger(q)) {
    throw new Error(\[dq]RSA key generation requires integer inputs.\[dq], {
      cause: { code: \[dq]NonInteger\[dq], values: [p, q] },
    });
  }
  if (!areCoprime(p, q)) {
    throw new Error(\[dq]RSA key generation requires two co-prime integers.\[dq], {
      cause: { code: \[dq]NonCoprime\[dq], values: [p, q] },
    });
  }
  // rsa algorithm\&...
}
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
\f[V]Error.prototype.message\f[R]
.IP \[bu] 2
\f[V]Error.prototype.toString()\f[R]
