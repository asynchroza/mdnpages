.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "String.substr" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
String.substr - String.prototype.substr()
.SH SYNOPSIS
.PP
\f[I](deprecated)\f[R]
.PP
The \f[B]\f[VB]substr()\f[B]\f[R] method returns a portion of the
string, starting at the specified index and extending for a given number
of characters afterwards.
.RS
.PP
\f[B]Note:\f[R] \f[V]substr()\f[R] is not part of the main ECMAScript
specification \[em] it\[cq]s defined in Annex B: Additional ECMAScript
Features for Web
Browsers (https://tc39.es/ecma262/#sec-additional-ecmascript-features-for-web-browsers),
which is normative optional for non-browser runtimes.
Therefore, people are advised to use the standard
\f[V]String.prototype.substring()\f[R] and
\f[V]String.prototype.slice()\f[R] methods instead to make their code
maximally cross-platform friendly.
The \f[V]String.prototype.substring()\f[R] page has some comparisons
between the three methods.
.RE
.SH SYNTAX
.IP
.nf
\f[C]
substr(start)
substr(start, length)
\f[R]
.fi
.SS Parameters
.TP
\f[B]start\f[R]
The index of the first character to include in the returned substring.
.TP
\f[B]length\f[R] \f[I](optional)\f[R]
The number of characters to extract.
.SS Return value
.PP
A new string containing the specified part of the given string.
.SH DESCRIPTION
.PP
A string\[cq]s \f[V]substr()\f[R] method extracts \f[V]length\f[R]
characters from the string, counting from the \f[V]start\f[R] index.
.IP \[bu] 2
If \f[V]start >= str.length\f[R], an empty string is returned.
.IP \[bu] 2
If \f[V]start < 0\f[R], the index starts counting from the end of the
string.
More formally, in this case the substring starts at
\f[V]max(start + str.length, 0)\f[R].
.IP \[bu] 2
If \f[V]start\f[R] is omitted or \f[V]undefined\f[R], it\[cq]s treated
as \f[V]0\f[R].
.IP \[bu] 2
If \f[V]length\f[R] is omitted or \f[V]undefined\f[R], or if
\f[V]start + length >= str.length\f[R], \f[V]substr()\f[R] extracts
characters to the end of the string.
.IP \[bu] 2
If \f[V]length < 0\f[R], an empty string is returned.
.IP \[bu] 2
For both \f[V]start\f[R] and \f[V]length\f[R], \f[V]NaN\f[R] is treated
as \f[V]0\f[R].
.PP
Although you are encouraged to avoid using \f[V]substr()\f[R], there is
no trivial way to migrate \f[V]substr()\f[R] to either \f[V]slice()\f[R]
or \f[V]substring()\f[R] in legacy code without essentially writing a
polyfill for \f[V]substr()\f[R].
For example, \f[V]str.substr(a, l)\f[R], \f[V]str.slice(a, a + l)\f[R],
and \f[V]str.substring(a, a + l)\f[R] all have different results when
\f[V]str = \[dq]01234\[dq], a = 1, l = -2\f[R] \[em] \f[V]substr()\f[R]
returns an empty string, \f[V]slice()\f[R] returns
\f[V]\[dq]123\[dq]\f[R], while \f[V]substring()\f[R] returns
\f[V]\[dq]0\[dq]\f[R].
The actual refactoring path depends on the knowledge of the range of
\f[V]a\f[R] and \f[V]l\f[R].
.SH EXAMPLES
.SS Using substr()
.IP
.nf
\f[C]
const aString = \[dq]Mozilla\[dq];

console.log(aString.substr(0, 1)); // \[aq]M\[aq]
console.log(aString.substr(1, 0)); // \[aq]\[aq]
console.log(aString.substr(-1, 1)); // \[aq]a\[aq]
console.log(aString.substr(1, -1)); // \[aq]\[aq]
console.log(aString.substr(-3)); // \[aq]lla\[aq]
console.log(aString.substr(1)); // \[aq]ozilla\[aq]
console.log(aString.substr(-20, 2)); // \[aq]Mo\[aq]
console.log(aString.substr(20, 2)); // \[aq]\[aq]
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]String.prototype.substr\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-string-and-regexp)
.IP \[bu] 2
\f[V]String.prototype.slice()\f[R]
.IP \[bu] 2
\f[V]String.prototype.substring()\f[R]
