.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "String.substr" "JS" "September 12, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.substr - String.prototype.substr()
.SH SYNOPSIS
\f[I](deprecated)\f[R]
.PP
The \f[B]\f[CB]substr()\f[B]\f[R] method of \f[CR]String\f[R] values
returns a portion of this string, starting at the specified index and
extending for a given number of characters afterwards.
.RS
.PP
\f[B]Note:\f[R] \f[CR]substr()\f[R] is not part of the main ECMAScript
specification \[em] it\[cq]s defined in Annex B: Additional ECMAScript
Features for Web
Browsers (https://tc39.es/ecma262/multipage/additional-ecmascript-features-for-web-browsers.html),
which is normative optional for non-browser runtimes.
Therefore, people are advised to use the standard
\f[CR]String.prototype.substring()\f[R] and
\f[CR]String.prototype.slice()\f[R] methods instead to make their code
maximally cross-platform friendly.
The \f[CR]String.prototype.substring()\f[R] page has some comparisons
between the three methods.
.RE
.SH SYNTAX
.IP
.EX
substr(start)
substr(start, length)
.EE
.SS Parameters
.TP
\f[B]start\f[R]
The index of the first character to include in the returned substring.
.TP
\f[B]length\f[R] \f[I](optional)\f[R]
The number of characters to extract.
.SS Return value
A new string containing the specified part of the given string.
.SH DESCRIPTION
A string\[cq]s \f[CR]substr()\f[R] method extracts \f[CR]length\f[R]
characters from the string, counting from the \f[CR]start\f[R] index.
.IP \[bu] 2
If \f[CR]start >= str.length\f[R], an empty string is returned.
.IP \[bu] 2
If \f[CR]start < 0\f[R], the index starts counting from the end of the
string.
More formally, in this case the substring starts at
\f[CR]max(start + str.length, 0)\f[R].
.IP \[bu] 2
If \f[CR]start\f[R] is omitted or \f[CR]undefined\f[R], it\[cq]s treated
as \f[CR]0\f[R].
.IP \[bu] 2
If \f[CR]length\f[R] is omitted or \f[CR]undefined\f[R], or if
\f[CR]start + length >= str.length\f[R], \f[CR]substr()\f[R] extracts
characters to the end of the string.
.IP \[bu] 2
If \f[CR]length < 0\f[R], an empty string is returned.
.IP \[bu] 2
For both \f[CR]start\f[R] and \f[CR]length\f[R], \f[CR]NaN\f[R] is
treated as \f[CR]0\f[R].
.PP
Although you are encouraged to avoid using \f[CR]substr()\f[R], there is
no trivial way to migrate \f[CR]substr()\f[R] to either
\f[CR]slice()\f[R] or \f[CR]substring()\f[R] in legacy code without
essentially writing a polyfill for \f[CR]substr()\f[R].
For example, \f[CR]str.substr(a, l)\f[R],
\f[CR]str.slice(a, a + l)\f[R], and \f[CR]str.substring(a, a + l)\f[R]
all have different results when
\f[CR]str = \[dq]01234\[dq], a = 1, l = -2\f[R] \[em]
\f[CR]substr()\f[R] returns an empty string, \f[CR]slice()\f[R] returns
\f[CR]\[dq]123\[dq]\f[R], while \f[CR]substring()\f[R] returns
\f[CR]\[dq]0\[dq]\f[R].
The actual refactoring path depends on the knowledge of the range of
\f[CR]a\f[R] and \f[CR]l\f[R].
.SH EXAMPLES
.SS Using substr()
.IP
.EX
const aString = \[dq]Mozilla\[dq];

console.log(aString.substr(0, 1)); // \[aq]M\[aq]
console.log(aString.substr(1, 0)); // \[aq]\[aq]
console.log(aString.substr(-1, 1)); // \[aq]a\[aq]
console.log(aString.substr(1, -1)); // \[aq]\[aq]
console.log(aString.substr(-3)); // \[aq]lla\[aq]
console.log(aString.substr(1)); // \[aq]ozilla\[aq]
console.log(aString.substr(-20, 2)); // \[aq]Mo\[aq]
console.log(aString.substr(20, 2)); // \[aq]\[aq]
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]String.prototype.substr\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-string-and-regexp)
.IP \[bu] 2
\f[CR]String.prototype.slice()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.substring()\f[R]
