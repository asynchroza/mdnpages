.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "HTMLMediaElement.srcObject" "JS" "August 25, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
HTMLMediaElement.srcObject \- HTMLMediaElement: srcObject property
.SH SYNOPSIS
The \f[B]\f[CB]srcObject\f[B]\f[R] property of the
\f[CR]HTMLMediaElement\f[R] interface sets or returns the object which
serves as the source of the media associated with the
\f[CR]HTMLMediaElement\f[R].
.PP
The object can be a \f[CR]MediaStream\f[R], a \f[CR]MediaSource\f[R], a
\f[CR]Blob\f[R], or a \f[CR]File\f[R] (which inherits from
\f[CR]Blob\f[R]).
.RS
.PP
\f[B]Note:\f[R] As of March 2020, only Safari has full support for
\f[CR]srcObject\f[R], i.e.\ using \f[CR]MediaSource\f[R],
\f[CR]MediaStream\f[R], \f[CR]Blob\f[R], and \f[CR]File\f[R] objects as
values.
Other browsers support \f[CR]MediaStream\f[R] objects; until they catch
up, consider falling back to creating a URL with
\f[CR]URL.createObjectURL()\f[R] and assigning it to
\f[CR]HTMLMediaElement.src\f[R] (see below for an example).
In addition, as of version 108 Chromium supports attaching a dedicated
worker \f[CR]MediaSource\f[R] object by assigning that object\[cq]s
\f[CR]MediaSourceHandle\f[R] instance (transferred from the worker) to
\f[CR]srcObject\f[R].
.RE
.SH VALUE
A \f[CR]MediaStream\f[R], \f[CR]MediaSource\f[R], \f[CR]Blob\f[R], or
\f[CR]File\f[R] object (though see the compatibility table for what is
actually supported).
.SH USAGE NOTES
Older versions of the Media Source specification required using
\f[CR]URL.createObjectURL()\f[R] to create an object URL then setting
\f[CR]src\f[R] to that URL.
Now you can just set \f[CR]srcObject\f[R] to the \f[CR]MediaStream\f[R]
directly.
.SH EXAMPLES
.SS Basic example
In this example, a \f[CR]MediaStream\f[R] from a camera is assigned to a
newly\-created \f[CR]<video>\f[R] element.
.IP
.EX
const mediaStream = await navigator.mediaDevices.getUserMedia({ video: true });
const video = document.createElement(\[dq]video\[dq]);
video.srcObject = mediaStream;
.EE
.PP
In this example, a new \f[CR]MediaSource\f[R] is assigned to a
newly\-created \f[CR]<video>\f[R] element.
.IP
.EX
const mediaSource = new MediaSource();
const video = document.createElement(\[dq]video\[dq]);
video.srcObject = mediaSource;
.EE
.SS Supporting fallback to the src property
The examples below support older browser versions that require you to
create an object URL and assign it to \f[CR]src\f[R] if
\f[CR]srcObject\f[R] isn\[cq]t supported.
.PP
First, a \f[CR]MediaStream\f[R] from a camera is assigned to a
newly\-created \f[CR]<video>\f[R] element, with fallback for older
browsers.
.IP
.EX
const mediaStream = await navigator.mediaDevices.getUserMedia({ video: true });
const video = document.createElement(\[dq]video\[dq]);
if (\[dq]srcObject\[dq] in video) {
  video.srcObject = mediaStream;
} else {
  // Avoid using this in new browsers, as it is going away.
  video.src = URL.createObjectURL(mediaStream);
}
.EE
.PP
Second, a new \f[CR]MediaSource\f[R] is assigned to a newly\-created
\f[CR]<video>\f[R] element, with fallback for older browsers and
browsers that don\[cq]t yet support assignment of \f[CR]MediaSource\f[R]
directly.
.IP
.EX
const mediaSource = new MediaSource();
const video = document.createElement(\[dq]video\[dq]);
// Older browsers may not have srcObject
if (\[dq]srcObject\[dq] in video) {
  try {
    video.srcObject = mediaSource;
  } catch (err) {
    if (err.name !== \[dq]TypeError\[dq]) {
      throw err;
    }
    // Even if they do, they may only support MediaStream
    video.src = URL.createObjectURL(mediaSource);
  }
} else {
  video.src = URL.createObjectURL(mediaSource);
}
.EE
.SS Constructing a \f[CR]MediaSource\f[R] in a worker and passing it to the main thread to play
The \f[CR]MediaSource.handle\f[R] property can be accessed inside a
dedicated worker and the resulting \f[CR]MediaSourceHandle\f[R] object
is then transferred over to the thread that created the worker (in this
case the main thread) via a \f[CR]postMessage()\f[R] call:
.IP
.EX
// Inside dedicated worker
let mediaSource = new MediaSource();
let handle = mediaSource.handle;
// Transfer the handle to the context that created the worker
postMessage({ arg: handle }, [handle]);

mediaSource.addEventListener(\[dq]sourceopen\[dq], () => {
  // Await sourceopen on MediaSource before creating SourceBuffers
  // and populating them with fetched media \[em] MediaSource won\[aq]t
  // accept creation of SourceBuffers until it is attached to the
  // HTMLMediaElement and its readyState is \[dq]open\[dq]
});
.EE
.PP
Over in the main thread, we receive the handle via a \f[CR]message\f[R]
event handler, attach it to a \f[CR]<video>\f[R] via its
\f[CR]HTMLMediaElement.srcObject\f[R] property, and \f[CR]play\f[R] the
video:
.IP
.EX
worker.addEventListener(\[dq]message\[dq], (msg) => {
  let mediaSourceHandle = msg.data.arg;
  video.srcObject = mediaSourceHandle;
  video.play();
});
.EE
.RS
.PP
\f[B]Note:\f[R] \f[CR]MediaSourceHandle\f[R]s cannot be successfully
transferred into or via a shared worker or service worker.
.RE
