.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Promise.race" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Promise.race - Promise.race()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]Promise.race()\f[B]\f[R] static method takes an iterable
of promises as input and returns a single \f[V]Promise\f[R].
This returned promise settles with the eventual state of the first
promise that settles.
.SH SYNTAX
.IP
.nf
\f[C]
Promise.race(iterable)
\f[R]
.fi
.SS Parameters
.TP
\f[B]iterable\f[R]
An iterable (such as an \f[V]Array\f[R]) of promises.
.SS Return value
.PP
A \f[V]Promise\f[R] that \f[B]asynchronously settles\f[R] with the
eventual state of the first promise in the \f[V]iterable\f[R] to settle.
In other words, it fulfills if the first promise to settle is fulfilled,
and rejects if the first promise to settle is rejected.
The returned promise remains pending forever if the \f[V]iterable\f[R]
passed is empty.
If the \f[V]iterable\f[R] passed is non-empty but contains no pending
promises, the returned promise is still asynchronously (instead of
synchronously) settled.
.SH DESCRIPTION
.PP
The \f[V]Promise.race()\f[R] method is one of the promise concurrency
methods.
It\[cq]s useful when you want the first async task to complete, but do
not care about its eventual state (i.e.\ it can either succeed or fail).
.PP
If the iterable contains one or more non-promise values and/or an
already settled promise, then \f[V]Promise.race()\f[R] will settle to
the first of these values found in the iterable.
.SH EXAMPLES
.SS Using Promise.race()
.PP
This example shows how \f[V]Promise.race()\f[R] can be used to race
several timers implemented with \f[V]setTimeout()\f[R].
The timer with the shortest time always wins the race and becomes the
resulting promise\[cq]s state.
.IP
.nf
\f[C]
function sleep(time, value, state) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (state === \[dq]fulfill\[dq]) {
        return resolve(value);
      } else {
        return reject(new Error(value));
      }
    }, time);
  });
}

const p1 = sleep(500, \[dq]one\[dq], \[dq]fulfill\[dq]);
const p2 = sleep(100, \[dq]two\[dq], \[dq]fulfill\[dq]);

Promise.race([p1, p2]).then((value) => {
  console.log(value); // \[dq]two\[dq]
  // Both fulfill, but p2 is faster
});

const p3 = sleep(100, \[dq]three\[dq], \[dq]fulfill\[dq]);
const p4 = sleep(500, \[dq]four\[dq], \[dq]reject\[dq]);

Promise.race([p3, p4]).then(
  (value) => {
    console.log(value); // \[dq]three\[dq]
    // p3 is faster, so it fulfills
  },
  (error) => {
    // Not called
  },
);

const p5 = sleep(500, \[dq]five\[dq], \[dq]fulfill\[dq]);
const p6 = sleep(100, \[dq]six\[dq], \[dq]reject\[dq]);

Promise.race([p5, p6]).then(
  (value) => {
    // Not called
  },
  (error) => {
    console.error(error.message); // \[dq]six\[dq]
    // p6 is faster, so it rejects
  },
);
\f[R]
.fi
.SS Asynchronicity of Promise.race
.PP
This following example demonstrates the asynchronicity of
\f[V]Promise.race\f[R].
Unlike other promise concurrency methods, \f[V]Promise.race\f[R] is
always asynchronous: it never settles synchronously, even when the
\f[V]iterable\f[R] is empty.
.IP
.nf
\f[C]
// Passing an array of promises that are already resolved,
// to trigger Promise.race as soon as possible
const resolvedPromisesArray = [Promise.resolve(33), Promise.resolve(44)];

const p = Promise.race(resolvedPromisesArray);
// Immediately logging the value of p
console.log(p);

// Using setTimeout, we can execute code after the stack is empty
setTimeout(() => {
  console.log(\[dq]the stack is now empty\[dq]);
  console.log(p);
});

// Logs, in order:
// Promise { <state>: \[dq]pending\[dq] }
// the stack is now empty
// Promise { <state>: \[dq]fulfilled\[dq], <value>: 33 }
\f[R]
.fi
.PP
An empty iterable causes the returned promise to be forever pending:
.IP
.nf
\f[C]
const foreverPendingPromise = Promise.race([]);
console.log(foreverPendingPromise);
setTimeout(() => {
  console.log(\[dq]the stack is now empty\[dq]);
  console.log(foreverPendingPromise);
});

// Logs, in order:
// Promise { <state>: \[dq]pending\[dq] }
// the stack is now empty
// Promise { <state>: \[dq]pending\[dq] }
\f[R]
.fi
.PP
If the iterable contains one or more non-promise value and/or an already
settled promise, then \f[V]Promise.race\f[R] will settle to the first of
these values found in the array:
.IP
.nf
\f[C]
const foreverPendingPromise = Promise.race([]);
const alreadyFulfilledProm = Promise.resolve(100);

const arr = [foreverPendingPromise, alreadyFulfilledProm, \[dq]non-Promise value\[dq]];
const arr2 = [foreverPendingPromise, \[dq]non-Promise value\[dq], Promise.resolve(100)];
const p = Promise.race(arr);
const p2 = Promise.race(arr2);

console.log(p);
console.log(p2);
setTimeout(() => {
  console.log(\[dq]the stack is now empty\[dq]);
  console.log(p);
  console.log(p2);
});

// Logs, in order:
// Promise { <state>: \[dq]pending\[dq] }
// Promise { <state>: \[dq]pending\[dq] }
// the stack is now empty
// Promise { <state>: \[dq]fulfilled\[dq], <value>: 100 }
// Promise { <state>: \[dq]fulfilled\[dq], <value>: \[dq]non-Promise value\[dq] }
\f[R]
.fi
.SS Using Promise.race() to implement request timeout
.PP
You can race a potentially long-lasting request with a timer that
rejects, so that when the time limit has elapsed, the resulting promise
automatically rejects.
.IP
.nf
\f[C]
const data = Promise.race([
  fetch(\[dq]/api\[dq]),
  new Promise((resolve, reject) => {
    // Reject after 5 seconds
    setTimeout(() => reject(new Error(\[dq]Request timed out\[dq])), 5000);
  }),
])
  .then((res) => res.json())
  .catch((err) => displayError(err));
\f[R]
.fi
.PP
If the \f[V]data\f[R] promise fulfills, it will contain the data fetched
from \f[V]/api\f[R]; otherwise, it will reject if \f[V]fetch\f[R]
remains pending for 5 seconds and loses the race with the
\f[V]setTimeout\f[R] timer.
.SS Using Promise.race() to detect the status of a promise
.PP
Because \f[V]Promise.race()\f[R] resolves to the first non-pending
promise in the iterable, we can check a promise\[cq]s state, including
if it\[cq]s pending.
This example is adapted from
\f[V]promise-status-async\f[R] (https://github.com/kudla/promise-status-async/blob/master/lib/promiseState.js).
.IP
.nf
\f[C]
function promiseState(promise) {
  const pendingState = { status: \[dq]pending\[dq] };

  return Promise.race([promise, pendingState]).then(
    (value) =>
      value === pendingState ? value : { status: \[dq]fulfilled\[dq], value },
    (reason) => ({ status: \[dq]rejected\[dq], reason }),
  );
}
\f[R]
.fi
.PP
In this function, if \f[V]promise\f[R] is pending, the second value,
\f[V]pendingState\f[R], which is a non-promise, becomes the result of
the race; otherwise, if \f[V]promise\f[R] is already settled, we may
know its state through the \f[V]onFulfilled\f[R] and
\f[V]onRejected\f[R] handlers.
For example:
.IP
.nf
\f[C]
const p1 = new Promise((res) => setTimeout(() => res(100), 100));
const p2 = new Promise((res) => setTimeout(() => res(200), 200));
const p3 = new Promise((res, rej) => setTimeout(() => rej(300), 100));

async function getStates() {
  console.log(await promiseState(p1));
  console.log(await promiseState(p2));
  console.log(await promiseState(p3));
}

console.log(\[dq]Immediately after initiation:\[dq]);
getStates();
setTimeout(() => {
  console.log(\[dq]After waiting for 100ms:\[dq]);
  getStates();
}, 100);

// Logs:
// Immediately after initiation:
// { status: \[aq]pending\[aq] }
// { status: \[aq]pending\[aq] }
// { status: \[aq]pending\[aq] }
// After waiting for 100ms:
// { status: \[aq]fulfilled\[aq], value: 100 }
// { status: \[aq]pending\[aq] }
// { status: \[aq]rejected\[aq], reason: 300 }
\f[R]
.fi
.RS
.PP
\f[B]Note:\f[R] The \f[V]promiseState\f[R] function still runs
asynchronously, because there is no way to synchronously get a
promise\[cq]s value (i.e.\ without \f[V]then()\f[R] or \f[V]await\f[R]),
even when it is already settled.
However, \f[V]promiseState()\f[R] always fulfills within one tick and
never actually waits for any promise\[cq]s settlement.
.RE
.SS Comparison with Promise.any()
.PP
\f[V]Promise.race\f[R] takes the first settled \f[V]Promise\f[R].
.IP
.nf
\f[C]
const promise1 = new Promise((resolve, reject) => {
  setTimeout(resolve, 500, \[dq]one\[dq]);
});

const promise2 = new Promise((resolve, reject) => {
  setTimeout(reject, 100, \[dq]two\[dq]);
});

Promise.race([promise1, promise2])
  .then((value) => {
    console.log(\[dq]succeeded with value:\[dq], value);
  })
  .catch((reason) => {
    // Only promise1 is fulfilled, but promise2 is faster
    console.error(\[dq]failed with reason:\[dq], reason);
  });
// failed with reason: two
\f[R]
.fi
.PP
\f[V]Promise.any\f[R] takes the first fulfilled \f[V]Promise\f[R].
.IP
.nf
\f[C]
const promise1 = new Promise((resolve, reject) => {
  setTimeout(resolve, 500, \[dq]one\[dq]);
});

const promise2 = new Promise((resolve, reject) => {
  setTimeout(reject, 100, \[dq]two\[dq]);
});

Promise.any([promise1, promise2])
  .then((value) => {
    // Only promise1 is fulfilled, even though promise2 settled sooner
    console.log(\[dq]succeeded with value:\[dq], value);
  })
  .catch((reason) => {
    console.error(\[dq]failed with reason:\[dq], reason);
  });
// succeeded with value: one
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
\f[V]Promise\f[R]
.IP \[bu] 2
\f[V]Promise.all()\f[R]
.IP \[bu] 2
\f[V]Promise.allSettled()\f[R]
.IP \[bu] 2
\f[V]Promise.any()\f[R]
