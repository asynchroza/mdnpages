.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Function.\[at]\[at]hasInstance" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB][\[at]\[at]hasInstance]()\f[B]\f[R] method of
\f[V]Function\f[R] instances specifies the default procedure for
determining if a constructor function recognizes an object as one of the
constructor\[cq]s instances.
It is called by the \f[V]instanceof\f[R] operator.
.SH Syntax
.IP
.nf
\f[C]
func[Symbol.hasInstance](value)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]value\f[R]
.RS 2
.IP \[bu] 2
The object to test.
Primitive values always return \f[V]false\f[R].
.RE
.SS Return value
.PP
\f[V]true\f[R] if \f[V]func.prototype\f[R] is in the prototype chain of
\f[V]value\f[R]; otherwise, \f[V]false\f[R].
Always returns \f[V]false\f[R] if \f[V]value\f[R] is not an object or
\f[V]this\f[R] is not a function.
If \f[V]this\f[R] is a bound function, returns the result of a
\f[V]instanceof\f[R] test on \f[V]value\f[R] and the underlying target
function.
.SS Exceptions
.IP \[bu] 2
\f[V]TypeError\f[R]
.RS 2
.IP \[bu] 2
Thrown if \f[V]this\f[R] is not a bound function and
\f[V]this.prototype\f[R] is not an object.
.RE
.SH Description
.PP
The \f[V]instanceof\f[R] operator calls the
\f[V][\[at]\[at]hasInstance]()\f[R] method of the right-hand side
whenever such a method exists.
Because all functions inherit from \f[V]Function.prototype\f[R] by
default, they would all have the \f[V][\[at]\[at]hasInstance]()\f[R]
method, so most of the time, the
\f[V]Function.prototype[\[at]\[at]hasInstance]\f[R] method specifies the
behavior of \f[V]instanceof\f[R] when the right-hand side is a function.
This method implements the default behavior of the \f[V]instanceof\f[R]
operator (the same algorithm when \f[V]constructor\f[R] has no
\f[V]\[at]\[at]hasInstance\f[R] method).
.PP
Unlike most methods, the
\f[V]Function.prototype[\[at]\[at]hasInstance]()\f[R] property is
non-configurable and non-writable.
This is a security feature to prevent the underlying target function of
a bound function from being obtainable.
See this StackOverflow
answer (https://stackoverflow.com/questions/38215027/trying-to-understand-the-official-es6-spec-regarding-symbol-hasinstance/38215392#38215392)
for an example.
.SH Examples
.SS Reverting to default instanceof behavior
.PP
You would rarely need to call this method directly.
Instead, this method is called by the \f[V]instanceof\f[R] operator.
You should expect the two results to usually be equivalent.
.IP
.nf
\f[C]
class Foo {}
const foo = new Foo();
console.log(foo instanceof Foo === Foo[Symbol.hasInstance](foo)); // true
\f[R]
.fi
.PP
You may want to use this method if you want to invoke the default
\f[V]instanceof\f[R] behavior, but you don\[cq]t know if a constructor
has a overridden \f[V][\[at]\[at]hasInstance]()\f[R] method.
.IP
.nf
\f[C]
class Foo {
  static [Symbol.hasInstance](value) {
    // A custom implementation
    return false;
  }
}

const foo = new Foo();
console.log(foo instanceof Foo); // false
console.log(Function.prototype[Symbol.hasInstance].call(Foo, foo)); // true
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]instanceof\f[R]
.IP \[bu] 2
\f[V]Symbol.hasInstance\f[R]
