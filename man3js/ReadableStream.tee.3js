.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "ReadableStream.tee" "JS" "May 10, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
ReadableStream.tee \- ReadableStream: tee() method
.SH SYNOPSIS
The \f[B]\f[CB]tee()\f[B]\f[R] method of the \f[CR]ReadableStream\f[R]
interface \c
.UR https://streams.spec.whatwg.org/#tee-a-readable-stream
tees
.UE \c
\ the current readable stream, returning a two\-element array containing
the two resulting branches as new \f[CR]ReadableStream\f[R] instances.
.PP
This is useful for allowing two readers to read a stream sequentially or
simultaneously, perhaps at different speeds.
For example, you might do this in a ServiceWorker if you want to fetch a
response from the server and stream it to the browser, but also stream
it to the ServiceWorker cache.
Since a response body cannot be consumed more than once, you\[cq]d need
two copies to do this.
.PP
A teed stream will partially signal backpressure at the rate of the
\f[I]faster\f[R] consumer of the two \f[CR]ReadableStream\f[R] branches,
and unread data is enqueued internally on the slower consumed
\f[CR]ReadableStream\f[R] without any limit or backpressure.
That is, when \f[I]both\f[R] branches have an unread element in their
internal queue, then the original \f[CR]ReadableStream\f[R]\[cq]s
controller\[cq]s internal queue will start to fill up, and once its
\f[CR]desiredSize\f[R] ≤ 0 or byte stream controller
\f[CR]desiredSize\f[R] ≤ 0, then the controller will stop calling
\f[CR]pull(controller)\f[R] on the underlying source passed to
\f[CR]new ReadableStream()\f[R].
If only one branch is consumed, then the entire body will be enqueued in
memory.
Therefore, you should not use the built\-in \f[CR]tee()\f[R] to read
very large streams in parallel at different speeds.
Instead, search for an implementation that fully backpressures to the
speed of the \f[I]slower\f[R] consumed branch.
.PP
To cancel the stream you then need to cancel both resulting branches.
Teeing a stream will generally lock it for the duration, preventing
other readers from locking it.
.SH SYNTAX
.IP
.EX
tee()
.EE
.SS Parameters
None.
.SS Return value
An \f[CR]Array\f[R] containing two \f[CR]ReadableStream\f[R] instances.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if the source stream is not a \f[CR]ReadableStream\f[R].
.SH EXAMPLES
In the following simple example, a previously\-created stream is teed,
then both resulting streams (contained in two members of a generated
array) are passed to a function that reads the data out of the two
streams and prints each stream\[cq]s chunks sequentially to a different
part of the UI.
See \c
.UR https://mdn.github.io/dom-examples/streams/simple-tee-example/
Simple tee example
.UE \c
\ for the full code.
.IP
.EX
function teeStream() {
  const teedOff = stream.tee();
  fetchStream(teedOff[0], list2);
  fetchStream(teedOff[1], list3);
}

function fetchStream(stream, list) {
  const reader = stream.getReader();
  let charsReceived = 0;

  // read() returns a promise that resolves
  // when a value has been received
  reader.read().then(function processText({ done, value }) {
    // Result objects contain two properties:
    // done  \- true if the stream has already given you all its data.
    // value \- some data. Always undefined when done is true.
    if (done) {
      console.log(\[dq]Stream complete\[dq]);
      return;
    }

    // value for fetch streams is a Uint8Array
    charsReceived += value.length;
    const chunk = value;
    let listItem = document.createElement(\[dq]li\[dq]);
    listItem.textContent = \[ga]Read ${charsReceived} characters so far. Current chunk = ${chunk}\[ga];
    list.appendChild(listItem);

    // Read some more, and call this function again
    return reader.read().then(processText);
  });
}
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]ReadableStream()\f[R] constructor
.IP \[bu] 2
Teeing a stream
