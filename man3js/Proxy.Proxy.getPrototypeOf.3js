.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Proxy.Proxy.getPrototypeOf" "JS" "August 11, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Proxy.Proxy.getPrototypeOf - handler.getPrototypeOf()
.SH SYNOPSIS
The \f[B]\f[CB]handler.getPrototypeOf()\f[B]\f[R] method is a trap for
the \f[CR][[GetPrototypeOf]]\f[R] object internal method, which is used
by operations such as \f[CR]Object.getPrototypeOf()\f[R].
.SH SYNTAX
.IP
.EX
new Proxy(obj, {
  getPrototypeOf(target) {
    // \&...
  }
});
.EE
.SS Parameters
The following parameter is passed to the \f[CR]getPrototypeOf()\f[R]
method.
\f[CR]this\f[R] is bound to the handler.
.TP
\f[B]target\f[R]
The target object.
.SS Return value
The \f[CR]getPrototypeOf()\f[R] method must return an object or
\f[CR]null\f[R].
.SH DESCRIPTION
.SS Interceptions
This trap can intercept these operations:
.IP \[bu] 2
\f[CR]Object.getPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]Reflect.getPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]__proto__\f[R]
.IP \[bu] 2
\f[CR]Object.prototype.isPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]instanceof\f[R]
.PP
Or any other operation that invokes the \f[CR][[GetPrototypeOf]]\f[R]
internal method.
.SS Invariants
If the following invariants are violated, the trap throws a
\f[CR]TypeError\f[R] when invoked.
.IP \[bu] 2
\f[CR]getPrototypeOf()\f[R] method must return an object or
\f[CR]null\f[R].
.IP \[bu] 2
If \f[CR]target\f[R] is not extensible,
\f[CR]Object.getPrototypeOf(proxy)\f[R] method must return the same
value as \f[CR]Object.getPrototypeOf(target)\f[R].
.SH EXAMPLES
.SS Basic usage
.IP
.EX
const obj = {};
const proto = {};
const handler = {
  getPrototypeOf(target) {
    console.log(target === obj); // true
    console.log(this === handler); // true
    return proto;
  },
};

const p = new Proxy(obj, handler);
console.log(Object.getPrototypeOf(p) === proto); // true
.EE
.SS Five ways to trigger the getPrototypeOf trap
.IP
.EX
const obj = {};
const p = new Proxy(obj, {
  getPrototypeOf(target) {
    return Array.prototype;
  },
});
console.log(
  Object.getPrototypeOf(p) === Array.prototype, // true
  Reflect.getPrototypeOf(p) === Array.prototype, // true
  p.__proto__ === Array.prototype, // true
  Array.prototype.isPrototypeOf(p), // true
  p instanceof Array, // true
);
.EE
.SS Two kinds of exceptions
\f[B]Bad\f[R]
.IP
.EX
const obj = {};
const p = new Proxy(obj, {
  getPrototypeOf(target) {
    return \[dq]foo\[dq];
  },
});
Object.getPrototypeOf(p); // TypeError: \[dq]foo\[dq] is not an object or null

const obj2 = Object.preventExtensions({});
const p2 = new Proxy(obj2, {
  getPrototypeOf(target) {
    return {};
  },
});
Object.getPrototypeOf(p2); // TypeError: expected same prototype value
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Proxy\f[R]
.IP \[bu] 2
\f[CR]Proxy()\f[R] constructor
.IP \[bu] 2
\f[CR]Object.getPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]Reflect.getPrototypeOf()\f[R]
