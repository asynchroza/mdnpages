.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "URLSearchParams" "JS" "December 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
URLSearchParams \- URLSearchParams
.SH SYNOPSIS
The \f[B]\f[CB]URLSearchParams\f[B]\f[R] interface defines utility
methods to work with the query string of a URL.
.PP
An object implementing \f[CR]URLSearchParams\f[R] can directly be used
in a \f[CR]for...of\f[R] structure to iterate over key/value pairs in
the same order as they appear in the query string, for example the
following two lines are equivalent:
.IP
.EX
for (const [key, value] of mySearchParams) {
}
for (const [key, value] of mySearchParams.entries()) {
}
.EE
.PP
This feature is available in Web Workers.
.SH CONSTRUCTOR
.TP
\f[B]URLSearchParams()\f[R]
Returns a \f[CR]URLSearchParams\f[R] object instance.
.SH INSTANCE PROPERTIES
.TP
\f[B]size\f[R] \f[I](read\-only)\f[R]
Indicates the total number of search parameter entries.
.SH INSTANCE METHODS
.TP
\f[B]URLSearchParams.[\[at]\[at]iterator]()\f[R]
Returns an \f[CR]iterator\f[R] allowing iteration through all key/value
pairs contained in this object in the same order as they appear in the
query string.
.TP
\f[B]URLSearchParams.append()\f[R]
Appends a specified key/value pair as a new search parameter.
.TP
\f[B]URLSearchParams.delete()\f[R]
Deletes search parameters that match a name, and optional value, from
the list of all search parameters.
.TP
\f[B]URLSearchParams.entries()\f[R]
Returns an \f[CR]iterator\f[R] allowing iteration through all key/value
pairs contained in this object in the same order as they appear in the
query string.
.TP
\f[B]URLSearchParams.forEach()\f[R]
Allows iteration through all values contained in this object via a
callback function.
.TP
\f[B]URLSearchParams.get()\f[R]
Returns the first value associated with the given search parameter.
.TP
\f[B]URLSearchParams.getAll()\f[R]
Returns all the values associated with a given search parameter.
.TP
\f[B]URLSearchParams.has()\f[R]
Returns a boolean value indicating if a given parameter, or parameter
and value pair, exists.
.TP
\f[B]URLSearchParams.keys()\f[R]
Returns an \f[CR]iterator\f[R] allowing iteration through all keys of
the key/value pairs contained in this object.
.TP
\f[B]URLSearchParams.set()\f[R]
Sets the value associated with a given search parameter to the given
value.
If there are several values, the others are deleted.
.TP
\f[B]URLSearchParams.sort()\f[R]
Sorts all key/value pairs, if any, by their keys.
.TP
\f[B]URLSearchParams.toString()\f[R]
Returns a string containing a query string suitable for use in a URL.
.TP
\f[B]URLSearchParams.values()\f[R]
Returns an \f[CR]iterator\f[R] allowing iteration through all values of
the key/value pairs contained in this object.
.SH EXAMPLES
.IP
.EX
const paramsString = \[dq]q=URLUtils.searchParams&topic=api\[dq];
const searchParams = new URLSearchParams(paramsString);

// Iterating the search parameters
for (const p of searchParams) {
  console.log(p);
}

console.log(searchParams.has(\[dq]topic\[dq])); // true
console.log(searchParams.has(\[dq]topic\[dq], \[dq]fish\[dq])); // false
console.log(searchParams.get(\[dq]topic\[dq]) === \[dq]api\[dq]); // true
console.log(searchParams.getAll(\[dq]topic\[dq])); // [\[dq]api\[dq]]
console.log(searchParams.get(\[dq]foo\[dq]) === null); // true
console.log(searchParams.append(\[dq]topic\[dq], \[dq]webdev\[dq]));
console.log(searchParams.toString()); // \[dq]q=URLUtils.searchParams&topic=api&topic=webdev\[dq]
console.log(searchParams.set(\[dq]topic\[dq], \[dq]More webdev\[dq]));
console.log(searchParams.toString()); // \[dq]q=URLUtils.searchParams&topic=More+webdev\[dq]
console.log(searchParams.delete(\[dq]topic\[dq]));
console.log(searchParams.toString()); // \[dq]q=URLUtils.searchParams\[dq]
.EE
.IP
.EX
// Search parameters can also be an object
const paramsObj = { foo: \[dq]bar\[dq], baz: \[dq]bar\[dq] };
const searchParams = new URLSearchParams(paramsObj);

console.log(searchParams.toString()); // \[dq]foo=bar&baz=bar\[dq]
console.log(searchParams.has(\[dq]foo\[dq])); // true
console.log(searchParams.get(\[dq]foo\[dq])); // \[dq]bar\[dq]
.EE
.SS Duplicate search parameters
.IP
.EX
const paramStr = \[dq]foo=bar&foo=baz\[dq];
const searchParams = new URLSearchParams(paramStr);

console.log(searchParams.toString()); // \[dq]foo=bar&foo=baz\[dq]
console.log(searchParams.has(\[dq]foo\[dq])); // true
console.log(searchParams.get(\[dq]foo\[dq])); // bar, only returns the first value
console.log(searchParams.getAll(\[dq]foo\[dq])); // [\[dq]bar\[dq], \[dq]baz\[dq]]
.EE
.SS No URL parsing
The \f[CR]URLSearchParams\f[R] constructor does \f[I]not\f[R] parse full
URLs.
However, it will strip an initial leading \f[CR]?\f[R] off of a string,
if present.
.IP
.EX
const paramsString1 = \[dq]http://example.com/search?query=%40\[dq];
const searchParams1 = new URLSearchParams(paramsString1);

console.log(searchParams1.has(\[dq]query\[dq])); // false
console.log(searchParams1.has(\[dq]http://example.com/search?query\[dq])); // true

console.log(searchParams1.get(\[dq]query\[dq])); // null
console.log(searchParams1.get(\[dq]http://example.com/search?query\[dq])); // \[dq]\[at]\[dq] (equivalent to decodeURIComponent(\[aq]%40\[aq]))

const paramsString2 = \[dq]?query=value\[dq];
const searchParams2 = new URLSearchParams(paramsString2);
console.log(searchParams2.has(\[dq]query\[dq])); // true

const url = new URL(\[dq]http://example.com/search?query=%40\[dq]);
const searchParams3 = new URLSearchParams(url.search);
console.log(searchParams3.has(\[dq]query\[dq])); // true
.EE
.SS Preserving plus signs
The \f[CR]URLSearchParams\f[R] constructor interprets plus signs
(\f[CR]+\f[R]) as spaces, which might cause problems.
In the example below, we use hexadecimal escape sequences to mimic a
string containing binary data (where every byte carries information)
that needs to be stored in the URL search params.
Note how the encoded string produced by \f[CR]btoa()\f[R] contains
\f[CR]+\f[R] and isn\[cq]t preserved by \f[CR]URLSearchParams\f[R].
.IP
.EX
const rawData = \[dq]\[rs]x13à\[rs]x17\[at]\[rs]x1F\[rs]x80\[dq];
const base64Data = btoa(rawData); // \[aq]E+AXQB+A\[aq]

const searchParams = new URLSearchParams(\[ga]bin=${base64Data}\[ga]); // \[aq]bin=E+AXQB+A\[aq]
const binQuery = searchParams.get(\[dq]bin\[dq]); // \[aq]E AXQB A\[aq], \[aq]+\[aq] is replaced by spaces

console.log(atob(binQuery) === rawData); // false
.EE
.PP
You can avoid this by encoding the data with the
\f[CR]encodeURIComponent()\f[R].
.IP
.EX
const rawData = \[dq]\[rs]x13à\[rs]x17\[at]\[rs]x1F\[rs]x80\[dq];
const base64Data = btoa(rawData); // \[aq]E+AXQB+A\[aq]
const encodedBase64Data = encodeURIComponent(base64Data); // \[aq]E%2BAXQB%2BA\[aq]

const searchParams = new URLSearchParams(\[ga]bin=${encodedBase64Data}\[ga]); // \[aq]bin=E%2BAXQB%2BA\[aq]
const binQuery = searchParams.get(\[dq]bin\[dq]); // \[aq]E+AXQB+A\[aq]

console.log(atob(binQuery) === rawData); // true
.EE
.SS Empty value vs.\ no value
\f[CR]URLSearchParams\f[R] doesn\[cq]t distinguish between a parameter
with nothing after the \f[CR]=\f[R], and a parameter that doesn\[cq]t
have a \f[CR]=\f[R] altogether.
.IP
.EX
const emptyVal = new URLSearchParams(\[dq]foo=&bar=baz\[dq]);
console.log(emptyVal.get(\[dq]foo\[dq])); // returns \[aq]\[aq]
const noEquals = new URLSearchParams(\[dq]foo&bar=baz\[dq]);
console.log(noEquals.get(\[dq]foo\[dq])); // also returns \[aq]\[aq]
console.log(noEquals.toString()); // \[aq]foo=&bar=baz\[aq]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#url-and-urlsearchparams
Polyfill of \f[CR]URLSearchParams\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
The \f[CR]URL\f[R] interface.
.IP \[bu] 2
\c
.UR https://developer.chrome.com/blog/urlsearchparams/
Google Developers: Easy URL manipulation with URLSearchParams
.UE \c
