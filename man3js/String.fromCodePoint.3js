.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "String.fromCodePoint" "JS" "April 6, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.fromCodePoint - String.fromCodePoint()
.SH SYNOPSIS
The \f[B]\f[CB]String.fromCodePoint()\f[B]\f[R] static method returns a
string created by using the specified sequence of code points.
.SH SYNTAX
.IP
.EX
String.fromCodePoint(num1)
String.fromCodePoint(num1, num2)
String.fromCodePoint(num1, num2, /* \&..., */ numN)
.EE
.SS Parameters
.TP
\f[B]num1, ..., numN\f[R]
A sequence of code points.
.SS Return value
A string created by using the specified sequence of code points.
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if an invalid Unicode code point is given.
.SH DESCRIPTION
This method returns a string (and \f[I]not\f[R] a \f[CR]String\f[R]
object).
.PP
Because \f[CR]fromCodePoint()\f[R] is a static method of
\f[CR]String\f[R], you must call it as
\f[CR]String.fromCodePoint()\f[R], rather than as a method of a
\f[CR]String\f[R] object you created.
.SH EXAMPLES
.SS Using fromCodePoint()
Valid input:
.IP
.EX
String.fromCodePoint(42); // \[dq]*\[dq]
String.fromCodePoint(65, 90); // \[dq]AZ\[dq]
String.fromCodePoint(0x404); // \[dq]\[rs]u0404\[dq] === \[dq]Ð„\[dq]
String.fromCodePoint(0x2f804); // \[dq]\[rs]uD87E\[rs]uDC04\[dq]
String.fromCodePoint(194564); // \[dq]\[rs]uD87E\[rs]uDC04\[dq]
String.fromCodePoint(0x1d306, 0x61, 0x1d307); // \[dq]\[rs]uD834\[rs]uDF06a\[rs]uD834\[rs]uDF07\[dq]
.EE
.PP
Invalid input:
.IP
.EX
String.fromCodePoint(\[dq]_\[dq]); // RangeError
String.fromCodePoint(Infinity); // RangeError
String.fromCodePoint(-1); // RangeError
String.fromCodePoint(3.14); // RangeError
String.fromCodePoint(3e-2); // RangeError
String.fromCodePoint(NaN); // RangeError
.EE
.SS Compared to fromCharCode()
\f[CR]String.fromCharCode()\f[R] cannot return supplementary characters
(i.e.\ code points \f[CR]0x010000\f[R] \[en] \f[CR]0x10FFFF\f[R]) by
specifying their code point.
Instead, it requires the UTF-16 surrogate pair in order to return a
supplementary character:
.IP
.EX
String.fromCharCode(0xd83c, 0xdf03); // Code Point U+1F303 \[dq]Night with
String.fromCharCode(55356, 57091); // Stars\[dq] === \[dq]\[rs]uD83C\[rs]uDF03\[dq]
.EE
.PP
\f[CR]String.fromCodePoint()\f[R], on the other hand, can return 4-byte
supplementary characters, as well as the more common 2-byte BMP
characters, by specifying their code point (which is equivalent to the
UTF-32 code unit):
.IP
.EX
String.fromCodePoint(0x1f303); // or 127747 in decimal
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]String.fromCodePoint\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-string-and-regexp)
.IP \[bu] 2
\f[CR]String.fromCharCode()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.charAt()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.codePointAt()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.charCodeAt()\f[R]
