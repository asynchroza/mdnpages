.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "String.fromCodePoint" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
String.fromCodePoint - String.fromCodePoint()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]String.fromCodePoint()\f[B]\f[R] static method returns a
string created by using the specified sequence of code points.
.SH SYNTAX
.IP
.nf
\f[C]
String.fromCodePoint(num1)
String.fromCodePoint(num1, num2)
String.fromCodePoint(num1, num2, /* \&..., */ numN)
\f[R]
.fi
.SS Parameters
.TP
\f[B]num1, ..., numN\f[R]
A sequence of code points.
.SS Return value
.PP
A string created by using the specified sequence of code points.
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if an invalid Unicode code point is given.
.SH DESCRIPTION
.PP
This method returns a string (and \f[I]not\f[R] a \f[V]String\f[R]
object).
.PP
Because \f[V]fromCodePoint()\f[R] is a static method of
\f[V]String\f[R], you must call it as \f[V]String.fromCodePoint()\f[R],
rather than as a method of a \f[V]String\f[R] object you created.
.SH EXAMPLES
.SS Using fromCodePoint()
.PP
Valid input:
.IP
.nf
\f[C]
String.fromCodePoint(42); // \[dq]*\[dq]
String.fromCodePoint(65, 90); // \[dq]AZ\[dq]
String.fromCodePoint(0x404); // \[dq]\[rs]u0404\[dq] === \[dq]Ð„\[dq]
String.fromCodePoint(0x2f804); // \[dq]\[rs]uD87E\[rs]uDC04\[dq]
String.fromCodePoint(194564); // \[dq]\[rs]uD87E\[rs]uDC04\[dq]
String.fromCodePoint(0x1d306, 0x61, 0x1d307); // \[dq]\[rs]uD834\[rs]uDF06a\[rs]uD834\[rs]uDF07\[dq]
\f[R]
.fi
.PP
Invalid input:
.IP
.nf
\f[C]
String.fromCodePoint(\[dq]_\[dq]); // RangeError
String.fromCodePoint(Infinity); // RangeError
String.fromCodePoint(-1); // RangeError
String.fromCodePoint(3.14); // RangeError
String.fromCodePoint(3e-2); // RangeError
String.fromCodePoint(NaN); // RangeError
\f[R]
.fi
.SS Compared to fromCharCode()
.PP
\f[V]String.fromCharCode()\f[R] cannot return supplementary characters
(i.e.\ code points \f[V]0x010000\f[R] \[en] \f[V]0x10FFFF\f[R]) by
specifying their code point.
Instead, it requires the UTF-16 surrogate pair in order to return a
supplementary character:
.IP
.nf
\f[C]
String.fromCharCode(0xd83c, 0xdf03); // Code Point U+1F303 \[dq]Night with
String.fromCharCode(55356, 57091); // Stars\[dq] === \[dq]\[rs]uD83C\[rs]uDF03\[dq]
\f[R]
.fi
.PP
\f[V]String.fromCodePoint()\f[R], on the other hand, can return 4-byte
supplementary characters, as well as the more common 2-byte BMP
characters, by specifying their code point (which is equivalent to the
UTF-32 code unit):
.IP
.nf
\f[C]
String.fromCodePoint(0x1f303); // or 127747 in decimal
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]String.fromCodePoint\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-string-and-regexp)
.IP \[bu] 2
\f[V]String.fromCharCode()\f[R]
.IP \[bu] 2
\f[V]String.prototype.charAt()\f[R]
.IP \[bu] 2
\f[V]String.prototype.codePointAt()\f[R]
.IP \[bu] 2
\f[V]String.prototype.charCodeAt()\f[R]
