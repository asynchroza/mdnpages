.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.values" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]values()\f[B]\f[R] method returns a new \f[I]array
iterator\f[R] object that iterates the value of each item in the array.
.SH Syntax
.IP
.nf
\f[C]
values()
\f[R]
.fi
.SS Return value
.PP
A new iterable iterator object.
.SH Description
.PP
\f[V]Array.prototype.values()\f[R] is the default implementation of
\f[V]Array.prototype[\[at]\[at]iterator]()\f[R].
.IP
.nf
\f[C]
Array.prototype.values === Array.prototype[Symbol.iterator]; // true
\f[R]
.fi
.PP
When used on sparse arrays, the \f[V]values()\f[R] method iterates empty
slots as if they have the value \f[V]undefined\f[R].
.PP
The \f[V]values()\f[R] method is generic.
It only expects the \f[V]this\f[R] value to have a \f[V]length\f[R]
property and integer-keyed properties.
.SH Examples
.SS Iteration using for\&...of loop
.PP
Because \f[V]values()\f[R] returns an iterable iterator, you can use a
\f[V]for...of\f[R] loop to iterate it.
.IP
.nf
\f[C]
const arr = [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq], \[dq]d\[dq], \[dq]e\[dq]];
const iterator = arr.values();

for (const letter of iterator) {
  console.log(letter);
} // \[dq]a\[dq] \[dq]b\[dq] \[dq]c\[dq] \[dq]d\[dq] \[dq]e\[dq]
\f[R]
.fi
.SS Iteration using next()
.PP
Because the return value is also an iterator, you can directly call its
\f[V]next()\f[R] method.
.IP
.nf
\f[C]
const arr = [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq], \[dq]d\[dq], \[dq]e\[dq]];
const iterator = arr.values();
iterator.next(); // { value: \[dq]a\[dq], done: false }
iterator.next(); // { value: \[dq]b\[dq], done: false }
iterator.next(); // { value: \[dq]c\[dq], done: false }
iterator.next(); // { value: \[dq]d\[dq], done: false }
iterator.next(); // { value: \[dq]e\[dq], done: false }
iterator.next(); // { value: undefined, done: true }
console.log(iterator.next().value); // undefined
\f[R]
.fi
.SS Reusing the iterable
.RS
.PP
\f[B]Warning:\f[R] The array iterator object should be a one-time use
object.
Do not reuse it.
.RE
.PP
The iterable returned from \f[V]values()\f[R] is not reusable.
When \f[V]next().done = true\f[R] or \f[V]currentIndex > length\f[R],
the \f[V]for...of\f[R] loop ends, and further iterating it has no
effect.
.IP
.nf
\f[C]
const arr = [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq], \[dq]d\[dq], \[dq]e\[dq]];
const values = arr.values();
for (const letter of values) {
  console.log(letter);
}
// \[dq]a\[dq] \[dq]b\[dq] \[dq]c\[dq] \[dq]d\[dq] \[dq]e\[dq]
for (const letter of values) {
  console.log(letter);
}
// undefined
\f[R]
.fi
.PP
If you use a \f[V]break\f[R] statement to end the iteration early, the
iterator can resume from the current position when continuing to iterate
it.
.IP
.nf
\f[C]
const arr = [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq], \[dq]d\[dq], \[dq]e\[dq]];
const values = arr.values();
for (const letter of values) {
  console.log(letter);
  if (letter === \[dq]b\[dq]) {
    break;
  }
}
// \[dq]a\[dq] \[dq]b\[dq]

for (const letter of values) {
  console.log(letter);
}
// \[dq]c\[dq] \[dq]d\[dq] \[dq]e\[dq]
\f[R]
.fi
.SS Mutations during iteration
.PP
There are no values stored in the array iterator object returned from
\f[V]values()\f[R]; instead, it stores the address of the array used in
its creation, and reads the currently visited index on each iteration.
Therefore, its iteration output depends on the value stored in that
index at the time of stepping.
If the values in the array changed, the array iterator object\[cq]s
values change too.
.IP
.nf
\f[C]
const arr = [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq], \[dq]d\[dq], \[dq]e\[dq]];
const iterator = arr.values();
console.log(iterator); // Array Iterator { }
console.log(iterator.next().value); // \[dq]a\[dq]
arr[1] = \[dq]n\[dq];
console.log(iterator.next().value); // \[dq]n\[dq]
\f[R]
.fi
.SS Iterating sparse arrays
.PP
\f[V]values()\f[R] will visit empty slots as if they are
\f[V]undefined\f[R].
.IP
.nf
\f[C]
for (const element of [, \[dq]a\[dq]].values()) {
  console.log(element);
}
// undefined
// \[aq]a\[aq]
\f[R]
.fi
.SS Calling values() on non-array objects
.PP
The \f[V]values()\f[R] method reads the \f[V]length\f[R] property of
\f[V]this\f[R] and then accesses each integer index.
.IP
.nf
\f[C]
const arrayLike = {
  length: 3,
  0: \[dq]a\[dq],
  1: \[dq]b\[dq],
  2: \[dq]c\[dq],
};
for (const entry of Array.prototype.values.call(arrayLike)) {
  console.log(entry);
}
// a
// b
// c
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]Array.prototype.values\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-array)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[V]Array\f[R]
.IP \[bu] 2
\f[V]Array.prototype.entries()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.keys()\f[R]
.IP \[bu] 2
\f[V]Array.prototype[\[at]\[at]iterator]()\f[R]
.IP \[bu] 2
\f[V]TypedArray.prototype.values()\f[R]
.IP \[bu] 2
Iteration protocols
