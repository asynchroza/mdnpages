.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "CanvasRenderingContext2D.globalCompositeOperation" "JS" "November 3, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
CanvasRenderingContext2D.globalCompositeOperation \-
CanvasRenderingContext2D: globalCompositeOperation property
.SH SYNOPSIS
The
\f[B]\f[CB]CanvasRenderingContext2D.globalCompositeOperation\f[B]\f[R]
property of the Canvas 2D API sets the type of compositing operation to
apply when drawing new shapes.
.PP
See also Compositing and clipping in the Canvas Tutorial.
.SH VALUE
A string identifying which of the compositing or blending mode
operations to use.
This may be any of the following values:
.TP
\f[B]\[dq]source\-over\[dq]\f[R]
This is the default setting and draws new shapes on top of the existing
canvas content.
.TP
\f[B]\[dq]source\-in\[dq]\f[R]
The new shape is drawn only where both the new shape and the destination
canvas overlap.
Everything else is made transparent.
.TP
\f[B]\[dq]source\-out\[dq]\f[R]
The new shape is drawn where it doesn\[cq]t overlap the existing canvas
content.
.TP
\f[B]\[dq]source\-atop\[dq]\f[R]
The new shape is only drawn where it overlaps the existing canvas
content.
.TP
\f[B]\[dq]destination\-over\[dq]\f[R]
New shapes are drawn behind the existing canvas content.
.TP
\f[B]\[dq]destination\-in\[dq]\f[R]
The existing canvas content is kept where both the new shape and
existing canvas content overlap.
Everything else is made transparent.
.TP
\f[B]\[dq]destination\-out\[dq]\f[R]
The existing content is kept where it doesn\[cq]t overlap the new shape.
.TP
\f[B]\[dq]destination\-atop\[dq]\f[R]
The existing canvas is only kept where it overlaps the new shape.
The new shape is drawn behind the canvas content.
.TP
\f[B]\[dq]lighter\[dq]\f[R]
Where both shapes overlap, the color is determined by adding color
values.
.TP
\f[B]\[dq]copy\[dq]\f[R]
Only the new shape is shown.
.TP
\f[B]\[dq]xor\[dq]\f[R]
Shapes are made transparent where both overlap and drawn normal
everywhere else.
.TP
\f[B]\[dq]multiply\[dq]\f[R]
The pixels of the top layer are multiplied with the corresponding pixels
of the bottom layer.
A darker picture is the result.
.TP
\f[B]\[dq]screen\[dq]\f[R]
The pixels are inverted, multiplied, and inverted again.
A lighter picture is the result (opposite of \f[CR]multiply\f[R])
.TP
\f[B]\[dq]overlay\[dq]\f[R]
A combination of \f[CR]multiply\f[R] and \f[CR]screen\f[R].
Dark parts on the base layer become darker, and light parts become
lighter.
.TP
\f[B]\[dq]darken\[dq]\f[R]
Retains the darkest pixels of both layers.
.TP
\f[B]\[dq]lighten\[dq]\f[R]
Retains the lightest pixels of both layers.
.TP
\f[B]\[dq]color\-dodge\[dq]\f[R]
Divides the bottom layer by the inverted top layer.
.TP
\f[B]\[dq]color\-burn\[dq]\f[R]
Divides the inverted bottom layer by the top layer, and then inverts the
result.
.TP
\f[B]\[dq]hard\-light\[dq]\f[R]
Like \f[CR]overlay\f[R], a combination of \f[CR]multiply\f[R] and
\f[CR]screen\f[R] \[em] but instead with the top layer and bottom layer
swapped.
.TP
\f[B]\[dq]soft\-light\[dq]\f[R]
A softer version of \f[CR]hard\-light\f[R].
Pure black or white does not result in pure black or white.
.TP
\f[B]\[dq]difference\[dq]\f[R]
Subtracts the bottom layer from the top layer \[em] or the other way
round \[em] to always get a positive value.
.TP
\f[B]\[dq]exclusion\[dq]\f[R]
Like \f[CR]difference\f[R], but with lower contrast.
.TP
\f[B]\[dq]hue\[dq]\f[R]
Preserves the luma and chroma of the bottom layer, while adopting the
hue of the top layer.
.TP
\f[B]\[dq]saturation\[dq]\f[R]
Preserves the luma and hue of the bottom layer, while adopting the
chroma of the top layer.
.TP
\f[B]\[dq]color\[dq]\f[R]
Preserves the luma of the bottom layer, while adopting the hue and
chroma of the top layer.
.TP
\f[B]\[dq]luminosity\[dq]\f[R]
Preserves the hue and chroma of the bottom layer, while adopting the
luma of the top layer.
.SH EXAMPLES
.SS Changing the composite operation
This example uses the \f[CR]globalCompositeOperation\f[R] property to
draw two rectangles that exclude themselves where they overlap.
.SS HTML
.IP
.EX
<canvas id=\[dq]canvas\[dq]></canvas>
.EE
.SS JavaScript
.IP
.EX
const canvas = document.getElementById(\[dq]canvas\[dq]);
const ctx = canvas.getContext(\[dq]2d\[dq]);

ctx.globalCompositeOperation = \[dq]xor\[dq];

ctx.fillStyle = \[dq]blue\[dq];
ctx.fillRect(10, 10, 100, 100);

ctx.fillStyle = \[dq]red\[dq];
ctx.fillRect(50, 50, 100, 100);
.EE
.SS Result
.SS Demonstration of all values
.SS Global values
This code sets up the global values used by the rest of the program.
.IP
.EX
const canvas1 = document.createElement(\[dq]canvas\[dq]);
const canvas2 = document.createElement(\[dq]canvas\[dq]);
const gco = [
  \[dq]source\-over\[dq],
  \[dq]source\-in\[dq],
  \[dq]source\-out\[dq],
  \[dq]source\-atop\[dq],
  \[dq]destination\-over\[dq],
  \[dq]destination\-in\[dq],
  \[dq]destination\-out\[dq],
  \[dq]destination\-atop\[dq],
  \[dq]lighter\[dq],
  \[dq]copy\[dq],
  \[dq]xor\[dq],
  \[dq]multiply\[dq],
  \[dq]screen\[dq],
  \[dq]overlay\[dq],
  \[dq]darken\[dq],
  \[dq]lighten\[dq],
  \[dq]color\-dodge\[dq],
  \[dq]color\-burn\[dq],
  \[dq]hard\-light\[dq],
  \[dq]soft\-light\[dq],
  \[dq]difference\[dq],
  \[dq]exclusion\[dq],
  \[dq]hue\[dq],
  \[dq]saturation\[dq],
  \[dq]color\[dq],
  \[dq]luminosity\[dq],
].reverse();
const gcoText = [
  \[dq]This is the default setting and draws new shapes on top of the existing canvas content.\[dq],
  \[dq]The new shape is drawn only where both the new shape and the destination canvas overlap. Everything else is made transparent.\[dq],
  \[dq]The new shape is drawn where it doesn\[aq]t overlap the existing canvas content.\[dq],
  \[dq]The new shape is only drawn where it overlaps the existing canvas content.\[dq],
  \[dq]New shapes are drawn behind the existing canvas content.\[dq],
  \[dq]The existing canvas content is kept where both the new shape and existing canvas content overlap. Everything else is made transparent.\[dq],
  \[dq]The existing content is kept where it doesn\[aq]t overlap the new shape.\[dq],
  \[dq]The existing canvas is only kept where it overlaps the new shape. The new shape is drawn behind the canvas content.\[dq],
  \[dq]Where both shapes overlap the color is determined by adding color values.\[dq],
  \[dq]Only the new shape is shown.\[dq],
  \[dq]Shapes are made transparent where both overlap and drawn normal everywhere else.\[dq],
  \[dq]The pixels of the top layer are multiplied with the corresponding pixel of the bottom layer. A darker picture is the result.\[dq],
  \[dq]The pixels are inverted, multiplied, and inverted again. A lighter picture is the result (opposite of multiply)\[dq],
  \[dq]A combination of multiply and screen. Dark parts on the base layer become darker, and light parts become lighter.\[dq],
  \[dq]Retains the darkest pixels of both layers.\[dq],
  \[dq]Retains the lightest pixels of both layers.\[dq],
  \[dq]Divides the bottom layer by the inverted top layer.\[dq],
  \[dq]Divides the inverted bottom layer by the top layer, and then inverts the result.\[dq],
  \[dq]A combination of multiply and screen like overlay, but with top and bottom layer swapped.\[dq],
  \[dq]A softer version of hard\-light. Pure black or white does not result in pure black or white.\[dq],
  \[dq]Subtracts the bottom layer from the top layer or the other way round to always get a positive value.\[dq],
  \[dq]Like difference, but with lower contrast.\[dq],
  \[dq]Preserves the luma and chroma of the bottom layer, while adopting the hue of the top layer.\[dq],
  \[dq]Preserves the luma and hue of the bottom layer, while adopting the chroma of the top layer.\[dq],
  \[dq]Preserves the luma of the bottom layer, while adopting the hue and chroma of the top layer.\[dq],
  \[dq]Preserves the hue and chroma of the bottom layer, while adopting the luma of the top layer.\[dq],
].reverse();
const width = 320;
const height = 340;
.EE
.SS Main program
When the page loads, this code runs to set up and run the example:
.IP
.EX
window.onload = () => {
  // lum in sRGB
  const lum = {
    r: 0.33,
    g: 0.33,
    b: 0.33,
  };
  // resize canvas
  canvas1.width = width;
  canvas1.height = height;
  canvas2.width = width;
  canvas2.height = height;
  lightMix();
  colorSphere();
  runComposite();
  return;
};
.EE
.PP
And this code, \f[CR]runComposite()\f[R], handles the bulk of the work,
relying on a number of utility functions to do the hard parts.
.IP
.EX
function createCanvas() {
  const canvas = document.createElement(\[dq]canvas\[dq]);
  canvas.style.background = \[ga]url(${op_8x8.data})\[ga];
  canvas.style.border = \[dq]1px solid #000\[dq];
  canvas.style.margin = \[dq]5px\[dq];
  canvas.width = width / 2;
  canvas.height = height / 2;
  return canvas;
}

function runComposite() {
  const dl = document.createElement(\[dq]dl\[dq]);
  document.body.appendChild(dl);
  while (gco.length) {
    const pop = gco.pop();
    const dt = document.createElement(\[dq]dt\[dq]);
    dt.textContent = pop;
    dl.appendChild(dt);
    const dd = document.createElement(\[dq]dd\[dq]);
    const p = document.createElement(\[dq]p\[dq]);
    p.textContent = gcoText.pop();
    dd.appendChild(p);

    const canvasToDrawOn = createCanvas();
    const canvasToDrawFrom = createCanvas();
    const canvasToDrawResult = createCanvas();

    let ctx = canvasToDrawResult.getContext(\[dq]2d\[dq]);
    ctx.clearRect(0, 0, width, height);
    ctx.save();
    ctx.drawImage(canvas1, 0, 0, width / 2, height / 2);
    ctx.globalCompositeOperation = pop;
    ctx.drawImage(canvas2, 0, 0, width / 2, height / 2);
    ctx.globalCompositeOperation = \[dq]source\-over\[dq];
    ctx.fillStyle = \[dq]rgba(0,0,0,0.8)\[dq];
    ctx.fillRect(0, height / 2 \- 20, width / 2, 20);
    ctx.fillStyle = \[dq]#FFF\[dq];
    ctx.font = \[dq]14px arial\[dq];
    ctx.fillText(pop, 5, height / 2 \- 5);
    ctx.restore();

    ctx = canvasToDrawOn.getContext(\[dq]2d\[dq]);
    ctx.clearRect(0, 0, width, height);
    ctx.save();
    ctx.drawImage(canvas1, 0, 0, width / 2, height / 2);
    ctx.fillStyle = \[dq]rgba(0,0,0,0.8)\[dq];
    ctx.fillRect(0, height / 2 \- 20, width / 2, 20);
    ctx.fillStyle = \[dq]#FFF\[dq];
    ctx.font = \[dq]14px arial\[dq];
    ctx.fillText(\[dq]existing content\[dq], 5, height / 2 \- 5);
    ctx.restore();

    ctx = canvasToDrawFrom.getContext(\[dq]2d\[dq]);
    ctx.clearRect(0, 0, width, height);
    ctx.save();
    ctx.drawImage(canvas2, 0, 0, width / 2, height / 2);
    ctx.fillStyle = \[dq]rgba(0,0,0,0.8)\[dq];
    ctx.fillRect(0, height / 2 \- 20, width / 2, 20);
    ctx.fillStyle = \[dq]#FFF\[dq];
    ctx.font = \[dq]14px arial\[dq];
    ctx.fillText(\[dq]new content\[dq], 5, height / 2 \- 5);
    ctx.restore();

    dd.appendChild(canvasToDrawOn);
    dd.appendChild(canvasToDrawFrom);
    dd.appendChild(canvasToDrawResult);

    dl.appendChild(dd);
  }
}
.EE
.SS Utility functions
The program relies on a number of utility functions.
.IP
.EX
const lightMix = () => {
  const ctx = canvas2.getContext(\[dq]2d\[dq]);
  ctx.save();
  ctx.globalCompositeOperation = \[dq]lighter\[dq];
  ctx.beginPath();
  ctx.fillStyle = \[dq]rgba(255,0,0,1)\[dq];
  ctx.arc(100, 200, 100, Math.PI * 2, 0, false);
  ctx.fill();
  ctx.beginPath();
  ctx.fillStyle = \[dq]rgba(0,0,255,1)\[dq];
  ctx.arc(220, 200, 100, Math.PI * 2, 0, false);
  ctx.fill();
  ctx.beginPath();
  ctx.fillStyle = \[dq]rgba(0,255,0,1)\[dq];
  ctx.arc(160, 100, 100, Math.PI * 2, 0, false);
  ctx.fill();
  ctx.restore();
  ctx.beginPath();
  ctx.fillStyle = \[dq]#f00\[dq];
  ctx.fillRect(0, 0, 30, 30);
  ctx.fill();
};
.EE
.IP
.EX
const colorSphere = (element) => {
  const ctx = canvas1.getContext(\[dq]2d\[dq]);
  const width = 360;
  const halfWidth = width / 2;
  const rotate = (1 / 360) * Math.PI * 2; // per degree
  const offset = 0; // scrollbar offset
  const oleft = \-20;
  const otop = \-20;
  for (let n = 0; n <= 359; n++) {
    const gradient = ctx.createLinearGradient(
      oleft + halfWidth,
      otop,
      oleft + halfWidth,
      otop + halfWidth,
    );
    const color = Color.HSV_RGB({ H: (n + 300) % 360, S: 100, V: 100 });
    gradient.addColorStop(0, \[dq]rgba(0,0,0,0)\[dq]);
    gradient.addColorStop(0.7, \[ga]rgba(${color.R}, ${color.G}, ${color.B}, 1)\[ga]);
    gradient.addColorStop(1, \[dq]rgba(255,255,255,1)\[dq]);
    ctx.beginPath();
    ctx.moveTo(oleft + halfWidth, otop);
    ctx.lineTo(oleft + halfWidth, otop + halfWidth);
    ctx.lineTo(oleft + halfWidth + 6, otop);
    ctx.fillStyle = gradient;
    ctx.fill();
    ctx.translate(oleft + halfWidth, otop + halfWidth);
    ctx.rotate(rotate);
    ctx.translate(\-(oleft + halfWidth), \-(otop + halfWidth));
  }
  ctx.beginPath();
  ctx.fillStyle = \[dq]#00f\[dq];
  ctx.fillRect(15, 15, 30, 30);
  ctx.fill();
  return ctx.canvas;
};
.EE
.IP
.EX
// HSV (1978) = H: Hue / S: Saturation / V: Value
Color = {};
Color.HSV_RGB = (o) => {
  const S = o.S / 100;
  let H = o.H / 360,
    V = o.V / 100;
  let R, G;
  let A, B, C, D;
  if (S === 0) {
    R = G = B = Math.round(V * 255);
  } else {
    if (H >= 1) H = 0;
    H *= 6;
    D = H \- Math.floor(H);
    A = Math.round(255 * V * (1 \- S));
    B = Math.round(255 * V * (1 \- S * D));
    C = Math.round(255 * V * (1 \- S * (1 \- D)));
    V = Math.round(255 * V);
    switch (Math.floor(H)) {
      case 0:
        R = V;
        G = C;
        B = A;
        break;
      case 1:
        R = B;
        G = V;
        B = A;
        break;
      case 2:
        R = A;
        G = V;
        B = C;
        break;
      case 3:
        R = A;
        G = B;
        B = V;
        break;
      case 4:
        R = C;
        G = A;
        B = V;
        break;
      case 5:
        R = V;
        G = A;
        B = B;
        break;
    }
  }
  return { R, G, B };
};

const createInterlace = (size, color1, color2) => {
  const proto = document.createElement(\[dq]canvas\[dq]).getContext(\[dq]2d\[dq]);
  proto.canvas.width = size * 2;
  proto.canvas.height = size * 2;
  proto.fillStyle = color1; // top\-left
  proto.fillRect(0, 0, size, size);
  proto.fillStyle = color2; // top\-right
  proto.fillRect(size, 0, size, size);
  proto.fillStyle = color2; // bottom\-left
  proto.fillRect(0, size, size, size);
  proto.fillStyle = color1; // bottom\-right
  proto.fillRect(size, size, size, size);
  const pattern = proto.createPattern(proto.canvas, \[dq]repeat\[dq]);
  pattern.data = proto.canvas.toDataURL();
  return pattern;
};

const op_8x8 = createInterlace(8, \[dq]#FFF\[dq], \[dq]#eee\[dq]);
.EE
.SS Result
.SH SEE ALSO
.IP \[bu] 2
The interface defining this property:
\f[CR]CanvasRenderingContext2D\f[R]
.IP \[bu] 2
\f[CR]CanvasRenderingContext2D.globalAlpha\f[R]
