.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "TypedArray.map" "JS" "March 30, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
TypedArray.map - TypedArray.prototype.map()
.SH SYNOPSIS
The \f[B]\f[CB]map()\f[B]\f[R] method creates a new typed array with the
results of calling a provided function on every element in this typed
array.
This method has the same algorithm as \f[CR]Array.prototype.map()\f[R].
\f[I]TypedArray\f[R] is one of the typed array types here.
.SH SYNTAX
.IP
.EX
map(callbackFn)
map(callbackFn, thisArg)
.EE
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element in the typed array.
Its return value is added as a single element in the new typed array.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the typed array.
.TP
\f[B]index\f[R]
The index of the current element being processed in the typed array.
.TP
\f[B]array\f[R]
The typed array \f[CR]map()\f[R] was called upon.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
A value to use as \f[CR]this\f[R] when executing \f[CR]callbackFn\f[R].
See iterative methods.
.SS Return value
A new typed array.
.SH DESCRIPTION
The \f[CR]map()\f[R] method calls a provided callback function
(\f[CR]callbackFn\f[R]) once for each element in a typed array, in
order, and constructs a new typed array from the results.
.PP
\f[CR]callbackFn\f[R] is invoked only for indexes of the typed array
which have assigned values; it is not invoked for indexes that are
\f[CR]undefined\f[R], those which have been deleted, or which have never
been assigned values.
.PP
\f[CR]callbackFn\f[R] is invoked with three arguments: the value of the
element, the index of the element, and the typed array object being
traversed.
.PP
If a \f[CR]thisArg\f[R] parameter is provided to \f[CR]map()\f[R], it
will be passed to \f[CR]callbackFn\f[R] when invoked, for use as its
\f[CR]this\f[R] value.
Otherwise, the value \f[CR]undefined\f[R] will be passed for use as its
\f[CR]this\f[R] value.
The \f[CR]this\f[R] value ultimately observable by \f[CR]callbackFn\f[R]
is determined according to the usual rules for determining the
\f[CR]this\f[R] seen by a function.
.PP
\f[CR]map()\f[R] does not mutate the typed array on which it is called
(although \f[CR]callbackFn\f[R], if invoked, may do so).
.PP
The range of elements processed by \f[CR]map()\f[R] is set before the
first invocation of \f[CR]callbackFn\f[R].
Elements which are appended to the array after the call to
\f[CR]map()\f[R] begins will not be visited by \f[CR]callbackFn\f[R].
If existing elements of the typed array are changed, or deleted, their
value as passed to \f[CR]callbackFn\f[R] will be the value at the time
\f[CR]map()\f[R] visits them; elements that are deleted are not visited.
.SH EXAMPLES
.SS Mapping a typed array to a typed array of square roots
The following code takes a typed array and creates a new typed array
containing the square roots of the numbers in the first typed array.
.IP
.EX
const numbers = new Uint8Array([1, 4, 9]);
const roots = numbers.map(Math.sqrt);
// roots is now: Uint8Array [1, 2, 3],
// numbers is still Uint8Array [1, 4, 9]
.EE
.SS Mapping a typed array of numbers using a function containing an argument
The following code shows how \f[CR]map()\f[R] works when a function
requiring one argument is used with it.
The argument will automatically be assigned to each element of the typed
array as \f[CR]map()\f[R] loops through the original typed array.
.IP
.EX
const numbers = new Uint8Array([1, 4, 9]);
const doubles = numbers.map((num) => num * 2);
// doubles is now Uint8Array [2, 8, 18]
// numbers is still Uint8Array [1, 4, 9]
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]TypedArray.prototype.map\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-typed-arrays)
.IP \[bu] 2
\f[CR]TypedArray.prototype.filter()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.map()\f[R]
