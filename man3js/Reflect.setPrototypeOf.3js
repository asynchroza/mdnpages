.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Reflect.setPrototypeOf" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Reflect.setPrototypeOf - Reflect.setPrototypeOf()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]Reflect.setPrototypeOf()\f[B]\f[R] static method is like
\f[V]Object.setPrototypeOf()\f[R] but returns a \f[V]Boolean\f[R].
It sets the prototype (i.e., the internal \f[V][[Prototype]]\f[R]
property) of a specified object.
.SH SYNTAX
.IP
.nf
\f[C]
Reflect.setPrototypeOf(target, prototype)
\f[R]
.fi
.SS Parameters
.TP
\f[B]target\f[R]
The target object of which to set the prototype.
.TP
\f[B]prototype\f[R]
The object\[cq]s new prototype (an object or \f[V]null\f[R]).
.SS Return value
.PP
A \f[V]Boolean\f[R] indicating whether or not the prototype was
successfully set.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if \f[V]target\f[R] is not an object or if \f[V]prototype\f[R] is
neither an object nor \f[V]null\f[R].
.SH DESCRIPTION
.PP
\f[V]Reflect.setPrototypeOf()\f[R] provides the reflective semantic of
setting the prototype of an object.
At the very low level, setting the prototype returns a boolean (as is
the case with the proxy handler).
\f[V]Object.setPrototypeOf()\f[R] provides nearly the same semantic, but
it throws a \f[V]TypeError\f[R] if the status is \f[V]false\f[R] (the
operation was unsuccessful), while \f[V]Reflect.setPrototypeOf()\f[R]
directly returns the status.
.PP
\f[V]Reflect.setPrototypeOf()\f[R] invokes the
\f[V][[SetPrototypeOf]]\f[R] object internal method of \f[V]target\f[R].
.SH EXAMPLES
.SS Using Reflect.setPrototypeOf()
.IP
.nf
\f[C]
Reflect.setPrototypeOf({}, Object.prototype); // true

// It can change an object\[aq]s [[Prototype]] to null.
Reflect.setPrototypeOf({}, null); // true

// Returns false if target is not extensible.
Reflect.setPrototypeOf(Object.freeze({}), null); // false

// Returns false if it cause a prototype chain cycle.
const target = {};
const proto = Object.create(target);
Reflect.setPrototypeOf(target, proto); // false
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]Reflect.setPrototypeOf\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-reflect)
.IP \[bu] 2
\f[V]Reflect\f[R]
.IP \[bu] 2
\f[V]Object.setPrototypeOf()\f[R]
.IP \[bu] 2
\f[V]Proxy\f[R]\[cq]s \f[V]setPrototypeOf\f[R] handler
