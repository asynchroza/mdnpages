'\" t
.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Error.stack" "JS" "December 15, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Error.stack - Error.prototype.stack
.SH SYNOPSIS
\f[I](non-standard)\f[R]
.RS
.PP
\f[B]Note:\f[R] The \f[CR]stack\f[R] property is de facto implemented by
all major JavaScript engines, and the JavaScript standards committee is
looking to standardize
it (https://github.com/tc39/proposal-error-stacks).
You cannot rely on the precise content of the stack string due to
implementation inconsistencies, but you can generally assume it exists
and use it for debugging purposes.
.RE
.PP
The non-standard \f[B]\f[CB]stack\f[B]\f[R] property of an
\f[CR]Error\f[R] instance offers a trace of which functions were called,
in what order, from which line and file, and with what arguments.
The stack string proceeds from the most recent calls to earlier ones,
leading back to the original global scope call.
.SH VALUE
A string.
.PP
Because the \f[CR]stack\f[R] property is non-standard, implementations
differ about where it\[cq]s installed.
.IP \[bu] 2
In Firefox, it\[cq]s an accessor property on \f[CR]Error.prototype\f[R].
.IP \[bu] 2
In Chrome and Safari, it\[cq]s a data property on each \f[CR]Error\f[R]
instance, with the descriptor:
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
yes
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
yes
T}
.TE
.SH DESCRIPTION
Each JavaScript engine uses its own format for stack traces, but they
are fairly consistent in their high-level structure.
Every implementation uses a separate line in the stack to represent each
function call.
The call that directly caused the error is placed at the top, and the
call that started the whole call chain is placed at the bottom.
Below are some examples of stack traces:
.IP
.EX
function foo() {
  bar();
}

function bar() {
  baz();
}

function baz() {
  console.log(new Error().stack);
}

foo();
.EE
.IP
.EX
### JavaScriptCore
baz\[at]filename.js:10:24
bar\[at]filename.js:6:6
foo\[at]filename.js:2:6
global code\[at]filename.js:13:4

### SpiderMonkey
baz\[at]filename.js:10:15
bar\[at]filename.js:6:3
foo\[at]filename.js:2:3
\[at]filename.js:13:1

### V8
Error
    at baz (filename.js:10:15)
    at bar (filename.js:6:3)
    at foo (filename.js:2:3)
    at filename.js:13:1
.EE
.PP
Different engines set this value at different times.
Most modern engines set it when the \f[CR]Error\f[R] object is created.
This means you can get the full call stack information within a function
using the following:
.IP
.EX
function foo() {
  console.log(new Error().stack);
}
.EE
.PP
Without having to throw an error and then catch it.
.PP
In V8, the non-standard \f[CR]Error.captureStackTrace()\f[R],
\f[CR]Error.stackTraceLimit\f[R], and
\f[CR]Error.prepareStackTrace()\f[R] APIs can be used to customize the
stack trace.
Read the Stack trace API (https://v8.dev/docs/stack-trace-api) in the V8
docs for more information.
.PP
Stack frames can be things other than explicit function calls, too.
For example, event listeners, timeout jobs, and promise handlers all
begin their own call chain.
Source code within \f[CR]eval()\f[R] and \f[CR]Function\f[R] constructor
calls also appear in the stack:
.IP
.EX
console.log(new Function(\[dq]return new Error(\[aq]Function failed\[aq])\[dq])().stack);
console.log(\[dq]====\[dq]);
console.log(eval(\[dq]new Error(\[aq]eval failed\[aq])\[dq]).stack);
.EE
.IP
.EX
### JavaScriptCore
anonymous\[at]
global code\[at]filename.js:1:65
====
eval code\[at]
eval\[at][native code]
global code\[at]filename.js:3:17

### SpiderMonkey
anonymous\[at]filename.js line 1 > Function:1:8
\[at]filename.js:1:65

====
\[at]filename.js line 3 > eval:1:1
\[at]filename.js:3:13

### V8
Error: Function failed
    at eval (eval at <anonymous> (filename.js:1:13), <anonymous>:1:8)
    at filename.js:1:65
====
Error: eval failed
    at eval (eval at <anonymous> (filename.js:3:13), <anonymous>:1:1)
    at filename.js:3:13
.EE
.PP
In Firefox, you can use the \f[CR]//# sourceURL\f[R] directive to name
an eval source.
See the Firefox Debug eval
sources (https://firefox-source-docs.mozilla.org/devtools-user/debugger/how_to/debug_eval_sources/index.html)
docs and the Naming \f[CR]eval\f[R] Scripts with the
\f[CR]//# sourceURL\f[R]
Directive (https://fitzgeraldnick.com/2014/12/05/name-eval-scripts.html)
blog post for more details.
.SH EXAMPLES
.SS Using the stack property
The following script demonstrates how to use the \f[CR]stack\f[R]
property to output a stack trace into your browser window.
You can use this to check what your browser\[cq]s stack structure looks
like.
.PP
\f[CR]html hidden <div id=\[dq]output\[dq]></div>\f[R]
.PP
\f[CR]css hidden output {   white-space: pre;   font-family: monospace; }\f[R]
.IP
.EX
function trace() {
  throw new Error(\[dq]trace() failed\[dq]);
}
function b() {
  trace();
}
function a() {
  b(3, 4, \[dq]\[rs]n\[rs]n\[dq], undefined, {});
}
try {
  a(\[dq]first call, firstarg\[dq]);
} catch (e) {
  document.getElementById(\[dq]output\[dq]).textContent = e.stack;
}
.EE
