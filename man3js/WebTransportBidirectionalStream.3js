.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "WebTransportBidirectionalStream" "JS" "December 10, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
WebTransportBidirectionalStream \- WebTransportBidirectionalStream
.SH SYNOPSIS
\f[B]Secure context\f[R]: This feature is available only in secure
contexts (HTTPS).
.PP
The \f[B]\f[CB]WebTransportBidirectionalStream\f[B]\f[R] interface of
the WebTransport API represents a bidirectional stream created by a
server or a client that can be used for reliable transport.
Provides access to a \f[CR]WebTransportReceiveStream\f[R] for reading
incoming data, and a \f[CR]WebTransportSendStream\f[R] for writing
outgoing data.
.PP
This feature is available in Web Workers.
.SH INSTANCE PROPERTIES
.TP
\f[B]readable\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]WebTransportReceiveStream\f[R] instance that can be used
to read incoming data.
.TP
\f[B]writable\f[R] \f[I](read\-only)\f[R]
Returns a \f[CR]WebTransportSendStream\f[R] instance that can be used to
write outgoing data.
.SH EXAMPLES
.SS Bidirectional transmission initiated by the user agent
To open a bidirectional stream from a user agent, you use the
\f[CR]WebTransport.createBidirectionalStream()\f[R] method to get a
reference to a \f[CR]WebTransportBidirectionalStream\f[R].
The \f[CR]readable\f[R] and \f[CR]writable\f[R] properties return
references to \f[CR]WebTransportReceiveStream\f[R] and
\f[CR]WebTransportSendStream\f[R] instances.
These inherit from \f[CR]ReadableStream\f[R] and
\f[CR]WebTransportReceiveStream\f[R] respectively, and can be used to
read from and write to the server.
.IP
.EX
async function setUpBidirectional() {
  const stream = await transport.createBidirectionalStream();
  // stream is a WebTransportBidirectionalStream
  // stream.readable is a WebTransportReceiveStream
  const readable = stream.readable;
  // stream.writable is a WebTransportSendStream
  const writable = stream.writable;

  ...
}
.EE
.PP
Reading from the \f[CR]WebTransportReceiveStream\f[R] can be done in the
same way as you would read a \f[CR]ReadableStream\f[R]:
.IP
.EX
async function readData(readable) {
  const reader = readable.getReader();
  while (true) {
    const { value, done } = await reader.read();
    if (done) {
      break;
    }
    // value is a Uint8Array.
    console.log(value);
  }
}
.EE
.PP
And writing to the \f[CR]WebTransportSendStream\f[R] can be done like
this:
.IP
.EX
async function writeData(writable) {
  const writer = writable.getWriter();
  const data1 = new Uint8Array([65, 66, 67]);
  const data2 = new Uint8Array([68, 69, 70]);
  writer.write(data1);
  writer.write(data2);
}
.EE
.SS Bidirectional transmission initiated by the server
If the server opens a bidirectional stream to transmit data to and
receive it from the client, this can be accessed via the
\f[CR]WebTransport.incomingBidirectionalStreams\f[R] property, which
returns a \f[CR]ReadableStream\f[R] of
\f[CR]WebTransportBidirectionalStream\f[R] objects.
Each one can be used to read and write \f[CR]Uint8Array\f[R] instances
as shown above.
However, you need an initial function to read the bidirectional stream
in the first place:
.IP
.EX
async function receiveBidirectional() {
  const bds = transport.incomingBidirectionalStreams;
  const reader = bds.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    // value is an instance of WebTransportBidirectionalStream
    await readData(value.readable);
    await writeData(value.writable);
  }
}
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://developer.chrome.com/docs/capabilities/web-apis/webtransport
Using WebTransport
.UE \c
.IP \[bu] 2
WebSockets API
.IP \[bu] 2
Streams API
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-http3/
WebTransport over HTTP/3
.UE \c
