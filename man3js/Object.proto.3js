.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Object.proto" "JS" "October 20, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.proto - Object.prototype.__proto__
.SH SYNOPSIS
\f[I](deprecated)\f[R]
.RS
.PP
\f[B]Warning:\f[R] Changing the \f[CR][[Prototype]]\f[R] of an object
is, by the nature of how modern JavaScript engines optimize property
accesses, currently a very slow operation in every browser and
JavaScript engine.
In addition, the effects of altering inheritance are subtle and
far-flung, and are not limited to the time spent in the
\f[CR]obj.__proto__ = ...\f[R] statement, but may extend to
\f[B]\f[BI]any\f[B]\f[R] code that has access to any object whose
\f[CR][[Prototype]]\f[R] has been altered.
You can read more in JavaScript engine fundamentals: optimizing
prototypes (https://mathiasbynens.be/notes/prototypes).
.RE
.RS
.PP
\f[B]Note:\f[R] The use of \f[CR]__proto__\f[R] is controversial and
discouraged.
Its existence and exact behavior have only been standardized as a legacy
feature to ensure web compatibility, while it presents several security
issues and footguns.
For better support, prefer
\f[CR]Object.getPrototypeOf()\f[R]/\f[CR]Reflect.getPrototypeOf()\f[R]
and
\f[CR]Object.setPrototypeOf()\f[R]/\f[CR]Reflect.setPrototypeOf()\f[R]
instead.
.RE
.PP
The \f[B]\f[CB]__proto__\f[B]\f[R] accessor property of
\f[CR]Object\f[R] instances exposes the \f[CR][[Prototype]]\f[R] (either
an object or \f[CR]null\f[R]) of this object.
.PP
The \f[CR]__proto__\f[R] property can also be used in an object literal
definition to set the object \f[CR][[Prototype]]\f[R] on creation, as an
alternative to \f[CR]Object.create()\f[R].
See: object initializer / literal syntax.
That syntax is standard and optimized for in implementations, and quite
different from \f[CR]Object.prototype.__proto__\f[R].
.SH SYNTAX
.IP
.EX
obj.__proto__
.EE
.SS Return value
If used as a getter, returns the object\[cq]s \f[CR][[Prototype]]\f[R].
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if attempting to set the prototype of a non-extensible object or
an immutable prototype exotic
object (https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-immutable-prototype-exotic-objects),
such as \f[CR]Object.prototype\f[R] or \f[CR]window\f[R].
.SH DESCRIPTION
The \f[CR]__proto__\f[R] getter function exposes the value of the
internal \f[CR][[Prototype]]\f[R] of an object.
For objects created using an object literal (unless you use the
prototype setter syntax), this value is \f[CR]Object.prototype\f[R].
For objects created using array literals, this value is
\f[CR]Array.prototype\f[R].
For functions, this value is \f[CR]Function.prototype\f[R].
You can read more about the prototype chain in Inheritance and the
prototype chain.
.PP
The \f[CR]__proto__\f[R] setter allows the \f[CR][[Prototype]]\f[R] of
an object to be mutated.
The value provided must be an object or \f[CR]null\f[R].
Providing any other value will do nothing.
.PP
Unlike \f[CR]Object.getPrototypeOf()\f[R] and
\f[CR]Object.setPrototypeOf()\f[R], which are always available on
\f[CR]Object\f[R] as static properties and always reflect the
\f[CR][[Prototype]]\f[R] internal property, the \f[CR]__proto__\f[R]
property doesn\[cq]t always exist as a property on all objects, and as a
result doesn\[cq]t reflect \f[CR][[Prototype]]\f[R] reliably.
.PP
The \f[CR]__proto__\f[R] property is a simple accessor property on
\f[CR]Object.prototype\f[R] consisting of a getter and setter function.
A property access for \f[CR]__proto__\f[R] that eventually consults
\f[CR]Object.prototype\f[R] will find this property, but an access that
does not consult \f[CR]Object.prototype\f[R] will not.
If some other \f[CR]__proto__\f[R] property is found before
\f[CR]Object.prototype\f[R] is consulted, that property will hide the
one found on \f[CR]Object.prototype\f[R].
.PP
\f[CR]null\f[R]-prototype objects don\[cq]t inherit any property from
\f[CR]Object.prototype\f[R], including the \f[CR]__proto__\f[R] accessor
property, so if you try to read \f[CR]__proto__\f[R] on such an object,
the value is always \f[CR]undefined\f[R] regardless of the object\[cq]s
actual \f[CR][[Prototype]]\f[R], and any assignment to
\f[CR]__proto__\f[R] would create a new property called
\f[CR]__proto__\f[R] instead of setting the object\[cq]s prototype.
Furthermore, \f[CR]__proto__\f[R] can be redefined as an own property on
any object instance through \f[CR]Object.defineProperty()\f[R] without
triggering the setter.
In this case, \f[CR]__proto__\f[R] will no longer be an accessor for
\f[CR][[Prototype]]\f[R].
Therefore, always prefer \f[CR]Object.getPrototypeOf()\f[R] and
\f[CR]Object.setPrototypeOf()\f[R] for setting and getting the
\f[CR][[Prototype]]\f[R] of an object.
.SH EXAMPLES
.SS Using __proto__
.IP
.EX
function Circle() {}
const shape = {};
const circle = new Circle();

// Set the object prototype.
// DEPRECATED. This is for example purposes only. DO NOT DO THIS in real code.
shape.__proto__ = circle;

// Get the object prototype
console.log(shape.__proto__ === Circle); // false
.EE
.IP
.EX
const ShapeA = function () {};
const ShapeB = {
  a() {
    console.log(\[dq]aaa\[dq]);
  },
};

ShapeA.prototype.__proto__ = ShapeB;
console.log(ShapeA.prototype.__proto__); // { a: [Function: a] }

const shapeA = new ShapeA();
shapeA.a(); // aaa
console.log(ShapeA.prototype === shapeA.__proto__); // true
.EE
.IP
.EX
const ShapeC = function () {};
const ShapeD = {
  a() {
    console.log(\[dq]a\[dq]);
  },
};

const shapeC = new ShapeC();
shapeC.__proto__ = ShapeD;
shapeC.a(); // a
console.log(ShapeC.prototype === shapeC.__proto__); // false
.EE
.IP
.EX
function Test() {}
Test.prototype.myName = function () {
  console.log(\[dq]myName\[dq]);
};

const test = new Test();
console.log(test.__proto__ === Test.prototype); // true
test.myName(); // myName

const obj = {};
obj.__proto__ = Test.prototype;
obj.myName(); // myName
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Object.prototype.isPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]Object.getPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]Object.setPrototypeOf()\f[R]
