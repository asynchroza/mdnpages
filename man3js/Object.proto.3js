.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Object.proto" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
\f[I](deprecated)\f[R]
.RS
.PP
\f[B]Warning:\f[R] Changing the \f[V][[Prototype]]\f[R] of an object is,
by the nature of how modern JavaScript engines optimize property
accesses, currently a very slow operation in every browser and
JavaScript engine.
In addition, the effects of altering inheritance are subtle and
far-flung, and are not limited to the time spent in the
\f[V]obj.__proto__ = ...\f[R] statement, but may extend to
\f[B]\f[BI]any\f[B]\f[R] code that has access to any object whose
\f[V][[Prototype]]\f[R] has been altered.
You can read more in JavaScript engine fundamentals: optimizing
prototypes (https://mathiasbynens.be/notes/prototypes).
.RE
.RS
.PP
\f[B]Note:\f[R] The use of \f[V]__proto__\f[R] is controversial and
discouraged.
Its existence and exact behavior have only been standardized as a legacy
feature to ensure web compatibility, while it presents several security
issues and footguns.
For better support, prefer
\f[V]Object.getPrototypeOf()\f[R]/\f[V]Reflect.getPrototypeOf()\f[R] and
\f[V]Object.setPrototypeOf()\f[R]/\f[V]Reflect.setPrototypeOf()\f[R]
instead.
.RE
.PP
The \f[B]\f[VB]__proto__\f[B]\f[R] accessor property of \f[V]Object\f[R]
instances exposes the \f[V][[Prototype]]\f[R] (either an object or
\f[V]null\f[R]) of this object.
.PP
The \f[V]__proto__\f[R] property can also be used in an object literal
definition to set the object \f[V][[Prototype]]\f[R] on creation, as an
alternative to \f[V]Object.create()\f[R].
See: object initializer / literal syntax.
That syntax is standard and optimized for in implementations, and quite
different from \f[V]Object.prototype.__proto__\f[R].
.SH Syntax
.IP
.nf
\f[C]
obj.__proto__
\f[R]
.fi
.SS Return value
.PP
If used as a getter, returns the object\[cq]s \f[V][[Prototype]]\f[R].
.SS Exceptions
.IP \[bu] 2
\f[V]TypeError\f[R]
.RS 2
.IP \[bu] 2
Thrown if attempting to set the prototype of a non-extensible object or
an immutable prototype exotic
object (https://tc39.es/ecma262/#sec-immutable-prototype-exotic-objects),
such as \f[V]Object.prototype\f[R] or \f[V]window\f[R].
.RE
.SH Description
.PP
The \f[V]__proto__\f[R] getter function exposes the value of the
internal \f[V][[Prototype]]\f[R] of an object.
For objects created using an object literal, this value is
\f[V]Object.prototype\f[R].
For objects created using array literals, this value is
\f[V]Array.prototype\f[R].
For functions, this value is \f[V]Function.prototype\f[R].
You can read more about the prototype chain in Inheritance and the
prototype chain.
.PP
The \f[V]__proto__\f[R] setter allows the \f[V][[Prototype]]\f[R] of an
object to be mutated.
The value provided must be an object or \f[V]null\f[R].
Providing any other value will do nothing.
.PP
Unlike \f[V]Object.getPrototypeOf()\f[R] and
\f[V]Object.setPrototypeOf()\f[R], which are always available on
\f[V]Object\f[R] as static properties and always reflect the
\f[V][[Prototype]]\f[R] internal property, the \f[V]__proto__\f[R]
property doesn\[cq]t always exist as a property on all objects, and as a
result doesn\[cq]t reflect \f[V][[Prototype]]\f[R] reliably.
.PP
The \f[V]__proto__\f[R] property is a simple accessor property on
\f[V]Object.prototype\f[R] consisting of a getter and setter function.
A property access for \f[V]__proto__\f[R] that eventually consults
\f[V]Object.prototype\f[R] will find this property, but an access that
does not consult \f[V]Object.prototype\f[R] will not.
If some other \f[V]__proto__\f[R] property is found before
\f[V]Object.prototype\f[R] is consulted, that property will hide the one
found on \f[V]Object.prototype\f[R].
.PP
\f[V]null\f[R]-prototype objects don\[cq]t inherit any property from
\f[V]Object.prototype\f[R], including the \f[V]__proto__\f[R] accessor
property, so if you try to read \f[V]__proto__\f[R] on such an object,
the value is always \f[V]undefined\f[R] regardless of the object\[cq]s
actual \f[V][[Prototype]]\f[R], and any assignment to
\f[V]__proto__\f[R] would create a new property called
\f[V]__proto__\f[R] instead of setting the object\[cq]s prototype.
Furthermore, \f[V]__proto__\f[R] can be redefined as an own property on
any object instance through \f[V]Object.defineProperty()\f[R] without
triggering the setter.
In this case, \f[V]__proto__\f[R] will no longer be an accessor for
\f[V][[Prototype]]\f[R].
Therefore, always prefer \f[V]Object.getPrototypeOf()\f[R] and
\f[V]Object.setPrototypeOf()\f[R] for setting and getting the
\f[V][[Prototype]]\f[R] of an object.
.SH Examples
.SS Using __proto__
.IP
.nf
\f[C]
function Circle() {}
const shape = {};
const circle = new Circle();

// Set the object prototype.
// DEPRECATED. This is for example purposes only. DO NOT DO THIS in real code.
shape.__proto__ = circle;

// Get the object prototype
console.log(shape.__proto__ === Circle); // false
\f[R]
.fi
.IP
.nf
\f[C]
const ShapeA = function () {};
const ShapeB = {
  a() {
    console.log(\[dq]aaa\[dq]);
  },
};

ShapeA.prototype.__proto__ = ShapeB;
console.log(ShapeA.prototype.__proto__); // { a: [Function: a] }

const shapeA = new ShapeA();
shapeA.a(); // aaa
console.log(ShapeA.prototype === shapeA.__proto__); // true
\f[R]
.fi
.IP
.nf
\f[C]
const ShapeC = function () {};
const ShapeD = {
  a() {
    console.log(\[dq]a\[dq]);
  },
};

const shapeC = new ShapeC();
shapeC.__proto__ = ShapeD;
shapeC.a(); // a
console.log(ShapeC.prototype === shapeC.__proto__); // false
\f[R]
.fi
.IP
.nf
\f[C]
function Test() {}
Test.prototype.myName = function () {
  console.log(\[dq]myName\[dq]);
};

const test = new Test();
console.log(test.__proto__ === Test.prototype); // true
test.myName(); // myName

const obj = {};
obj.__proto__ = Test.prototype;
obj.myName(); // myName
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]Object.prototype.isPrototypeOf()\f[R]
.IP \[bu] 2
\f[V]Object.getPrototypeOf()\f[R]
.IP \[bu] 2
\f[V]Object.setPrototypeOf()\f[R]
