.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "Array.from" "JS" "September 25, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.from \- Array.from()
.SH SYNOPSIS
The \f[B]\f[CB]Array.from()\f[B]\f[R] static method creates a new,
shallow\-copied \f[CR]Array\f[R] instance from an iterable or
array\-like object.
.SH SYNTAX
.IP
.EX
Array.from(arrayLike)
Array.from(arrayLike, mapFn)
Array.from(arrayLike, mapFn, thisArg)
.EE
.SS Parameters
.TP
\f[B]arrayLike\f[R]
An iterable or array\-like object to convert to an array.
.TP
\f[B]mapFn\f[R] \f[I](optional)\f[R]
A function to call on every element of the array.
If provided, every value to be added to the array is first passed
through this function, and \f[CR]mapFn\f[R]\[cq]s return value is added
to the array instead.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the array.
.TP
\f[B]index\f[R]
The index of the current element being processed in the array.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
Value to use as \f[CR]this\f[R] when executing \f[CR]mapFn\f[R].
.SS Return value
A new \f[CR]Array\f[R] instance.
.SH DESCRIPTION
\f[CR]Array.from()\f[R] lets you create \f[CR]Array\f[R]s from:
.IP \[bu] 2
iterable objects (objects such as \f[CR]Map\f[R] and \f[CR]Set\f[R]);
or, if the object is not iterable,
.IP \[bu] 2
array\-like objects (objects with a \f[CR]length\f[R] property and
indexed elements).
.PP
To convert an ordinary object that\[cq]s not iterable or array\-like to
an array (by enumerating its property keys, values, or both), use
\f[CR]Object.keys()\f[R], \f[CR]Object.values()\f[R], or
\f[CR]Object.entries()\f[R].
To convert an async iterable to an array, use
\f[CR]Array.fromAsync()\f[R].
.PP
\f[CR]Array.from()\f[R] never creates a sparse array.
If the \f[CR]arrayLike\f[R] object is missing some index properties,
they become \f[CR]undefined\f[R] in the new array.
.PP
\f[CR]Array.from()\f[R] has an optional parameter \f[CR]mapFn\f[R],
which allows you to execute a function on each element of the array
being created, similar to \f[CR]map()\f[R].
More clearly, \f[CR]Array.from(obj, mapFn, thisArg)\f[R] has the same
result as \f[CR]Array.from(obj).map(mapFn, thisArg)\f[R], except that it
does not create an intermediate array, and \f[CR]mapFn\f[R] only
receives two arguments (\f[CR]element\f[R], \f[CR]index\f[R]) without
the whole array, because the array is still under construction.
.RS
.PP
\f[B]Note:\f[R] This behavior is more important for typed arrays, since
the intermediate array would necessarily have values truncated to fit
into the appropriate type.
\f[CR]Array.from()\f[R] is implemented to have the same signature as
\f[CR]TypedArray.from()\f[R].
.RE
.PP
The \f[CR]Array.from()\f[R] method is a generic factory method.
For example, if a subclass of \f[CR]Array\f[R] inherits the
\f[CR]from()\f[R] method, the inherited \f[CR]from()\f[R] method will
return new instances of the subclass instead of \f[CR]Array\f[R]
instances.
In fact, the \f[CR]this\f[R] value can be any constructor function that
accepts a single argument representing the length of the new array.
When an iterable is passed as \f[CR]arrayLike\f[R], the constructor is
called with no arguments; when an array\-like object is passed, the
constructor is called with the normalized length of the array\-like
object.
The final \f[CR]length\f[R] will be set again when iteration finishes.
If the \f[CR]this\f[R] value is not a constructor function, the plain
\f[CR]Array\f[R] constructor is used instead.
.SH EXAMPLES
.SS Array from a String
.IP
.EX
Array.from(\[dq]foo\[dq]);
// [ \[dq]f\[dq], \[dq]o\[dq], \[dq]o\[dq] ]
.EE
.SS Array from a Set
.IP
.EX
const set = new Set([\[dq]foo\[dq], \[dq]bar\[dq], \[dq]baz\[dq], \[dq]foo\[dq]]);
Array.from(set);
// [ \[dq]foo\[dq], \[dq]bar\[dq], \[dq]baz\[dq] ]
.EE
.SS Array from a Map
.IP
.EX
const map = new Map([
  [1, 2],
  [2, 4],
  [4, 8],
]);
Array.from(map);
// [[1, 2], [2, 4], [4, 8]]

const mapper = new Map([
  [\[dq]1\[dq], \[dq]a\[dq]],
  [\[dq]2\[dq], \[dq]b\[dq]],
]);
Array.from(mapper.values());
// [\[aq]a\[aq], \[aq]b\[aq]];

Array.from(mapper.keys());
// [\[aq]1\[aq], \[aq]2\[aq]];
.EE
.SS Array from a NodeList
.IP
.EX
// Create an array based on a property of DOM Elements
const images = document.querySelectorAll(\[dq]img\[dq]);
const sources = Array.from(images, (image) => image.src);
const insecureSources = sources.filter((link) => link.startsWith(\[dq]http://\[dq]));
.EE
.SS Array from an Array\-like object (arguments)
.IP
.EX
function f() {
  return Array.from(arguments);
}

f(1, 2, 3);

// [ 1, 2, 3 ]
.EE
.SS Using arrow functions and Array.from()
.IP
.EX
// Using an arrow function as the map function to
// manipulate the elements
Array.from([1, 2, 3], (x) => x + x);
// [2, 4, 6]

// Generate a sequence of numbers
// Since the array is initialized with \[ga]undefined\[ga] on each position,
// the value of \[ga]v\[ga] below will be \[ga]undefined\[ga]
Array.from({ length: 5 }, (v, i) => i);
// [0, 1, 2, 3, 4]
.EE
.SS Sequence generator (range)
.IP
.EX
// Sequence generator function (commonly referred to as \[dq]range\[dq], e.g. Clojure, PHP, etc.)
const range = (start, stop, step) =>
  Array.from({ length: (stop \- start) / step + 1 }, (_, i) => start + i * step);

// Generate numbers range 0..4
range(0, 4, 1);
// [0, 1, 2, 3, 4]

// Generate numbers range 1..10 with step of 2
range(1, 10, 2);
// [1, 3, 5, 7, 9]

// Generate the alphabet using Array.from making use of it being ordered as a sequence
range(\[dq]A\[dq].charCodeAt(0), \[dq]Z\[dq].charCodeAt(0), 1).map((x) =>
  String.fromCharCode(x),
);
// [\[dq]A\[dq], \[dq]B\[dq], \[dq]C\[dq], \[dq]D\[dq], \[dq]E\[dq], \[dq]F\[dq], \[dq]G\[dq], \[dq]H\[dq], \[dq]I\[dq], \[dq]J\[dq], \[dq]K\[dq], \[dq]L\[dq], \[dq]M\[dq], \[dq]N\[dq], \[dq]O\[dq], \[dq]P\[dq], \[dq]Q\[dq], \[dq]R\[dq], \[dq]S\[dq], \[dq]T\[dq], \[dq]U\[dq], \[dq]V\[dq], \[dq]W\[dq], \[dq]X\[dq], \[dq]Y\[dq], \[dq]Z\[dq]]
.EE
.SS Calling from() on non\-array constructors
The \f[CR]from()\f[R] method can be called on any constructor function
that accepts a single argument representing the length of the new array.
.IP
.EX
function NotArray(len) {
  console.log(\[dq]NotArray called with length\[dq], len);
}

// Iterable
console.log(Array.from.call(NotArray, new Set([\[dq]foo\[dq], \[dq]bar\[dq], \[dq]baz\[dq]])));
// NotArray called with length undefined
// NotArray { \[aq]0\[aq]: \[aq]foo\[aq], \[aq]1\[aq]: \[aq]bar\[aq], \[aq]2\[aq]: \[aq]baz\[aq], length: 3 }

// Array\-like
console.log(Array.from.call(NotArray, { length: 1, 0: \[dq]foo\[dq] }));
// NotArray called with length 1
// NotArray { \[aq]0\[aq]: \[aq]foo\[aq], length: 1 }
.EE
.PP
When the \f[CR]this\f[R] value is not a constructor, a plain
\f[CR]Array\f[R] object is returned.
.IP
.EX
console.log(Array.from.call({}, { length: 1, 0: \[dq]foo\[dq] })); // [ \[aq]foo\[aq] ]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-array
Polyfill of \f[CR]Array.from\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
Indexed collections guide
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]Array()\f[R]
.IP \[bu] 2
\f[CR]Array.of()\f[R]
.IP \[bu] 2
\f[CR]Array.fromAsync()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.map()\f[R]
.IP \[bu] 2
\f[CR]TypedArray.from()\f[R]
