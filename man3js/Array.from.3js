.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.from" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]Array.from()\f[B]\f[R] static method creates a new,
shallow-copied \f[V]Array\f[R] instance from an iterable or array-like
object.
.SH Syntax
.IP
.nf
\f[C]
Array.from(arrayLike)
Array.from(arrayLike, mapFn)
Array.from(arrayLike, mapFn, thisArg)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]arrayLike\f[R]
.RS 2
.IP \[bu] 2
An iterable or array-like object to convert to an array.
.RE
.IP \[bu] 2
\f[V]mapFn\f[R] \f[I](optional)\f[R]
.RS 2
.IP \[bu] 2
A function to call on every element of the array.
If provided, every value to be added to the array is first passed
through this function, and \f[V]mapFn\f[R]\[cq]s return value is added
to the array instead.
The function is called with the following arguments:
.RS 2
.IP \[bu] 2
\f[V]element\f[R]
.RS 2
.IP \[bu] 2
The current element being processed in the array.
.RE
.IP \[bu] 2
\f[V]index\f[R]
.RS 2
.IP \[bu] 2
The index of the current element being processed in the array.
.RE
.RE
.RE
.IP \[bu] 2
\f[V]thisArg\f[R] \f[I](optional)\f[R]
.RS 2
.IP \[bu] 2
Value to use as \f[V]this\f[R] when executing \f[V]mapFn\f[R].
.RE
.SS Return value
.PP
A new \f[V]Array\f[R] instance.
.SH Description
.PP
\f[V]Array.from()\f[R] lets you create \f[V]Array\f[R]s from:
.IP \[bu] 2
iterable objects (objects such as \f[V]Map\f[R] and \f[V]Set\f[R]); or,
if the object is not iterable,
.IP \[bu] 2
array-like objects (objects with a \f[V]length\f[R] property and indexed
elements).
.PP
To convert an ordinary object that\[cq]s not iterable or array-like to
an array (by enumerating its property keys, values, or both), use
\f[V]Object.keys()\f[R], \f[V]Object.values()\f[R], or
\f[V]Object.entries()\f[R].
To convert an async iterable to an array, use
\f[V]Array.fromAsync()\f[R].
.PP
\f[V]Array.from()\f[R] never creates a sparse array.
If the \f[V]arrayLike\f[R] object is missing some index properties, they
become \f[V]undefined\f[R] in the new array.
.PP
\f[V]Array.from()\f[R] has an optional parameter \f[V]mapFn\f[R], which
allows you to execute a function on each element of the array being
created, similar to \f[V]map()\f[R].
More clearly, \f[V]Array.from(obj, mapFn, thisArg)\f[R] has the same
result as \f[V]Array.from(obj).map(mapFn, thisArg)\f[R], except that it
does not create an intermediate array, and \f[V]mapFn\f[R] only receives
two arguments (\f[V]element\f[R], \f[V]index\f[R]) without the whole
array, because the array is still under construction.
.RS
.PP
\f[B]Note:\f[R] This behavior is more important for typed arrays, since
the intermediate array would necessarily have values truncated to fit
into the appropriate type.
\f[V]Array.from()\f[R] is implemented to have the same signature as
\f[V]TypedArray.from()\f[R].
.RE
.PP
The \f[V]Array.from()\f[R] method is a generic factory method.
For example, if a subclass of \f[V]Array\f[R] inherits the
\f[V]from()\f[R] method, the inherited \f[V]from()\f[R] method will
return new instances of the subclass instead of \f[V]Array\f[R]
instances.
In fact, the \f[V]this\f[R] value can be any constructor function that
accepts a single argument representing the length of the new array.
When an iterable is passed as \f[V]arrayLike\f[R], the constructor is
called with no arguments; when an array-like object is passed, the
constructor is called with the normalized length of the array-like
object.
The final \f[V]length\f[R] will be set again when iteration finishes.
If the \f[V]this\f[R] value is not a constructor function, the plain
\f[V]Array\f[R] constructor is used instead.
.SH Examples
.SS Array from a String
.IP
.nf
\f[C]
Array.from(\[dq]foo\[dq]);
// [ \[dq]f\[dq], \[dq]o\[dq], \[dq]o\[dq] ]
\f[R]
.fi
.SS Array from a Set
.IP
.nf
\f[C]
const set = new Set([\[dq]foo\[dq], \[dq]bar\[dq], \[dq]baz\[dq], \[dq]foo\[dq]]);
Array.from(set);
// [ \[dq]foo\[dq], \[dq]bar\[dq], \[dq]baz\[dq] ]
\f[R]
.fi
.SS Array from a Map
.IP
.nf
\f[C]
const map = new Map([
  [1, 2],
  [2, 4],
  [4, 8],
]);
Array.from(map);
// [[1, 2], [2, 4], [4, 8]]

const mapper = new Map([
  [\[dq]1\[dq], \[dq]a\[dq]],
  [\[dq]2\[dq], \[dq]b\[dq]],
]);
Array.from(mapper.values());
// [\[aq]a\[aq], \[aq]b\[aq]];

Array.from(mapper.keys());
// [\[aq]1\[aq], \[aq]2\[aq]];
\f[R]
.fi
.SS Array from a NodeList
.IP
.nf
\f[C]
// Create an array based on a property of DOM Elements
const images = document.querySelectorAll(\[dq]img\[dq]);
const sources = Array.from(images, (image) => image.src);
const insecureSources = sources.filter((link) => link.startsWith(\[dq]http://\[dq]));
\f[R]
.fi
.SS Array from an Array-like object (arguments)
.IP
.nf
\f[C]
function f() {
  return Array.from(arguments);
}

f(1, 2, 3);

// [ 1, 2, 3 ]
\f[R]
.fi
.SS Using arrow functions and Array.from()
.IP
.nf
\f[C]
// Using an arrow function as the map function to
// manipulate the elements
Array.from([1, 2, 3], (x) => x + x);
// [2, 4, 6]

// Generate a sequence of numbers
// Since the array is initialized with \[ga]undefined\[ga] on each position,
// the value of \[ga]v\[ga] below will be \[ga]undefined\[ga]
Array.from({ length: 5 }, (v, i) => i);
// [0, 1, 2, 3, 4]
\f[R]
.fi
.SS Sequence generator (range)
.IP
.nf
\f[C]
// Sequence generator function (commonly referred to as \[dq]range\[dq], e.g. Clojure, PHP, etc.)
const range = (start, stop, step) =>
  Array.from({ length: (stop - start) / step + 1 }, (_, i) => start + i * step);

// Generate numbers range 0..4
range(0, 4, 1);
// [0, 1, 2, 3, 4]

// Generate numbers range 1..10 with step of 2
range(1, 10, 2);
// [1, 3, 5, 7, 9]

// Generate the alphabet using Array.from making use of it being ordered as a sequence
range(\[dq]A\[dq].charCodeAt(0), \[dq]Z\[dq].charCodeAt(0), 1).map((x) =>
  String.fromCharCode(x),
);
// [\[dq]A\[dq], \[dq]B\[dq], \[dq]C\[dq], \[dq]D\[dq], \[dq]E\[dq], \[dq]F\[dq], \[dq]G\[dq], \[dq]H\[dq], \[dq]I\[dq], \[dq]J\[dq], \[dq]K\[dq], \[dq]L\[dq], \[dq]M\[dq], \[dq]N\[dq], \[dq]O\[dq], \[dq]P\[dq], \[dq]Q\[dq], \[dq]R\[dq], \[dq]S\[dq], \[dq]T\[dq], \[dq]U\[dq], \[dq]V\[dq], \[dq]W\[dq], \[dq]X\[dq], \[dq]Y\[dq], \[dq]Z\[dq]]
\f[R]
.fi
.SS Calling from() on non-array constructors
.PP
The \f[V]from()\f[R] method can be called on any constructor function
that accepts a single argument representing the length of the new array.
.IP
.nf
\f[C]
function NotArray(len) {
  console.log(\[dq]NotArray called with length\[dq], len);
}

// Iterable
console.log(Array.from.call(NotArray, new Set([\[dq]foo\[dq], \[dq]bar\[dq], \[dq]baz\[dq]])));
// NotArray called with length undefined
// NotArray { \[aq]0\[aq]: \[aq]foo\[aq], \[aq]1\[aq]: \[aq]bar\[aq], \[aq]2\[aq]: \[aq]baz\[aq], length: 3 }

// Array-like
console.log(Array.from.call(NotArray, { length: 1, 0: \[dq]foo\[dq] }));
// NotArray called with length 1
// NotArray { \[aq]0\[aq]: \[aq]foo\[aq], length: 1 }
\f[R]
.fi
.PP
When the \f[V]this\f[R] value is not a constructor, a plain
\f[V]Array\f[R] object is returned.
.IP
.nf
\f[C]
console.log(Array.from.call({}, { length: 1, 0: \[dq]foo\[dq] })); // [ \[aq]foo\[aq] ]
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]Array.from\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-array)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[V]Array\f[R]
.IP \[bu] 2
\f[V]Array()\f[R]
.IP \[bu] 2
\f[V]Array.of()\f[R]
.IP \[bu] 2
\f[V]Array.fromAsync()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.map()\f[R]
.IP \[bu] 2
\f[V]TypedArray.from()\f[R]
