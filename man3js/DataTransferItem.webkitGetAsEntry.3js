.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "DataTransferItem.webkitGetAsEntry" "JS" "October 20, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
DataTransferItem.webkitGetAsEntry \- DataTransferItem:
webkitGetAsEntry() method
.SH SYNOPSIS
If the item described by the \f[CR]DataTransferItem\f[R] is a file,
\f[CR]webkitGetAsEntry()\f[R] returns a \f[CR]FileSystemFileEntry\f[R]
or \f[CR]FileSystemDirectoryEntry\f[R] representing it.
If the item isn\[cq]t a file, \f[CR]null\f[R] is returned.
.RS
.PP
\f[B]Note:\f[R] This function is implemented as
\f[CR]webkitGetAsEntry()\f[R] in non\-WebKit browsers including Firefox
at this time; it may be renamed to \f[CR]getAsEntry()\f[R] in the
future, so you should code defensively, looking for both.
.RE
.SH SYNTAX
.IP
.EX
webkitGetAsEntry()
.EE
.SS Parameters
None.
.SS Return value
A \f[CR]FileSystemEntry\f[R]\-based object describing the dropped item.
This will be either \f[CR]FileSystemFileEntry\f[R] or
\f[CR]FileSystemDirectoryEntry\f[R].
The method aborts and returns \f[CR]null\f[R] if the dropped item
isn\[cq]t a file, or if the \f[CR]DataTransferItem\f[R] object is not in
read or read/write mode.
.SH EXAMPLES
In this example, a drop zone is created, which responds to the
\f[CR]drop\f[R] event by scanning through the dropped files and
directories, outputting a hierarchical directory listing.
.SS HTML
The HTML establishes the drop zone itself, which is a \f[CR]<div>\f[R]
element with the ID \f[CR]\[dq]dropzone\[dq]\f[R], and an unordered list
element with the ID \f[CR]\[dq]listing\[dq]\f[R].
.IP
.EX
<p>Drag files and/or directories to the box below!</p>

<div id=\[dq]dropzone\[dq]>
  <div id=\[dq]boxtitle\[dq]>Drop Files Here</div>
</div>

<h2>Directory tree:</h2>

<ul id=\[dq]listing\[dq]></ul>
.EE
.SS CSS
The styles used by the example are shown here.
.IP
.EX
dropzone {
  text\-align: center;
  width: 300px;
  height: 100px;
  margin: 10px;
  padding: 10px;
  border: 4px dashed red;
  border\-radius: 10px;
}

boxtitle {
  display: table\-cell;
  vertical\-align: middle;
  text\-align: center;
  color: black;
  font:
    bold 2em \[dq]Arial\[dq],
    sans\-serif;
  width: 300px;
  height: 100px;
}

body {
  font:
    14px \[dq]Arial\[dq],
    sans\-serif;
}
.EE
.SS JavaScript
First, let\[cq]s look at the recursive \f[CR]scanFiles()\f[R] function.
This function takes as input a \f[CR]FileSystemEntry\f[R] representing
an entry in the file system to be scanned and processed (the
\f[CR]item\f[R] parameter), and an element into which to insert the list
of contents (the \f[CR]container\f[R] parameter).
.RS
.PP
\f[B]Note:\f[R] To read all files in a directory, \f[CR]readEntries\f[R]
needs to be called repeatedly until it returns an empty array.
In Chromium\-based browsers, the following example will only return a
max of 100 entries.
.RE
.IP
.EX
let dropzone = document.getElementById(\[dq]dropzone\[dq]);
let listing = document.getElementById(\[dq]listing\[dq]);

function scanFiles(item, container) {
  let elem = document.createElement(\[dq]li\[dq]);
  elem.textContent = item.name;
  container.appendChild(elem);

  if (item.isDirectory) {
    let directoryReader = item.createReader();
    let directoryContainer = document.createElement(\[dq]ul\[dq]);
    container.appendChild(directoryContainer);
    directoryReader.readEntries((entries) => {
      entries.forEach((entry) => {
        scanFiles(entry, directoryContainer);
      });
    });
  }
}
.EE
.PP
\f[CR]scanFiles()\f[R] begins by creating a new \f[CR]<li>\f[R] element
to represent the item being scanned, inserts the name of the item into
it as its text content, and then appends it to the container.
The container is always a list element in this example, as you\[cq]ll
see shortly.
.PP
Once the current item is in the list, the item\[cq]s
\f[CR]isDirectory\f[R] property is checked.
If the item is a directory, we need to recurse into that directory.
The first step is to create a \f[CR]FileSystemDirectoryReader\f[R] to
handle fetching the directory\[cq]s contents.
That\[cq]s done by calling the item\[cq]s \f[CR]createReader()\f[R]
method.
Then a new \f[CR]<ul>\f[R] is created and appended to the parent list;
this will contain the directory\[cq]s contents in the next level down in
the list\[cq]s hierarchy.
.PP
After that, \f[CR]directoryReader.readEntries()\f[R] is called to read
in all the entries in the directory.
These are each, in turn, passed into a recursive call to
\f[CR]scanFiles()\f[R] to process them.
Any of them which are files are inserted into the list; any which are
directories are inserted into the list and a new level of the list\[cq]s
hierarchy is added below, and so forth.
.PP
Then come the event handlers.
First, we prevent the \f[CR]dragover\f[R] event from being handled by
the default handler, so that our drop zone can receive the drop:
.IP
.EX
dropzone.addEventListener(
  \[dq]dragover\[dq],
  (event) => {
    event.preventDefault();
  },
  false,
);
.EE
.PP
The event handler that kicks everything off, of course, is the handler
for the \f[CR]drop\f[R] event:
.IP
.EX
dropzone.addEventListener(
  \[dq]drop\[dq],
  (event) => {
    let items = event.dataTransfer.items;

    event.preventDefault();
    listing.textContent = \[dq]\[dq];

    for (let i = 0; i < items.length; i++) {
      let item = items[i].webkitGetAsEntry();

      if (item) {
        scanFiles(item, listing);
      }
    }
  },
  false,
);
.EE
.PP
This fetches the list of \f[CR]DataTransferItem\f[R] objects
representing the items dropped from \f[CR]event.dataTransfer.items\f[R].
Then we call \f[CR]Event.preventDefault()\f[R] to prevent the event from
being handled further after we\[cq]re done.
.PP
Now it\[cq]s time to start building the list.
First, the list is emptied by setting \f[CR]listing.textContent\f[R] to
be empty.
That leaves us with an empty \f[CR]<ul>\f[R] to begin inserting
directory entries into.
.PP
Then we iterate over the items in the list of dropped items.
For each one, we call its \f[CR]webkitGetAsEntry()\f[R] method to obtain
a \f[CR]FileSystemEntry\f[R] representing the file.
If that\[cq]s successful, we call \f[CR]scanFiles()\f[R] to process the
item\[em]either by adding it to the list if it\[cq]s just a file or by
adding it and walking down into it if it\[cq]s a directory.
.SS Result
You can see how this works by trying it out below.
Find some files and directories and drag them in, and take a look at the
resulting output.
.SH SEE ALSO
.IP \[bu] 2
File and Directory Entries API
.IP \[bu] 2
Introduction to the File and Directory Entries API
.IP \[bu] 2
\f[CR]DataTransferItem\f[R]
.IP \[bu] 2
\f[CR]FileSystemEntry\f[R], \f[CR]FileSystemFileEntry\f[R], and
\f[CR]FileSystemDirectoryEntry\f[R]
.IP \[bu] 2
Events: \f[CR]dragover\f[R] and \f[CR]drop\f[R]
