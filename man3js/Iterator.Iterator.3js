.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Iterator.Iterator" "JS" "August 26, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Iterator.Iterator - Iterator() constructor
.SH SYNOPSIS
The \f[B]\f[CB]Iterator()\f[B]\f[R] constructor is intended to be used
as the superclass of other classes that create iterators.
It throws an error when constructed by itself.
.SH SYNTAX
.IP
.EX
new Iterator()
.EE
.RS
.PP
\f[B]Note:\f[R] \f[CR]Iterator()\f[R] can only be constructed with
\f[CR]new\f[R].
Attempting to call it without \f[CR]new\f[R] throws a
\f[CR]TypeError\f[R].
In addition, \f[CR]Iterator()\f[R] cannot actually be constructed itself
\[em] it\[cq]s usually implicitly constructed through \f[CR]super()\f[R]
calls inside the constructor of a subclass.
.RE
.SS Parameters
None.
.SS Return value
A new \f[CR]Iterator\f[R] object.
.SS Exceptions
.TP
\f[B]TypeError\f[R]
When \f[CR]new.target\f[R] is the \f[CR]Iterator\f[R] function itself,
i.e.\ when the \f[CR]Iterator\f[R] constructor itself is constructed.
.SH DESCRIPTION
\f[CR]Iterator\f[R] represents an \f[I]abstract class\f[R] \[em] a class
that provides common utilities for its subclasses, but is not intended
to be instantiated itself.
It is the superclass of all other iterator classes, and is used to
create subclasses that implement specific iteration algorithms \[em]
namely, all subclasses of \f[CR]Iterator\f[R] must implement a
\f[CR]next()\f[R] method as required by the iterator protocol.
Because \f[CR]Iterator\f[R] doesn\[cq]t actually provide the
\f[CR]next()\f[R] method, it doesn\[cq]t make sense to construct an
\f[CR]Iterator\f[R] directly.
.PP
You can also use \f[CR]Iterator.from()\f[R] to create an
\f[CR]Iterator\f[R] instance from an existing iterable or iterator
object.
.SH EXAMPLES
.SS Subclassing Iterator
The following example defines a custom data structure, \f[CR]Range\f[R],
which allows iteration.
The simplest way to make an object iterable is to provide an
\f[CR][\[at]\[at]iterator]()\f[R] method in the form of a generator
function:
.IP
.EX
class Range {
  #start;
  #end;
  #step;

  constructor(start, end, step = 1) {
    this.#start = start;
    this.#end = end;
    this.#step = step;
  }

  *[Symbol.iterator]() {
    for (let value = this.#start; value <= this.#end; value += this.#step) {
      yield value;
    }
  }
}

const range = new Range(1, 5);
for (const num of range) {
  console.log(num);
}
.EE
.PP
This works, but it isn\[cq]t as nice as how built-in iterators work.
There are two problems:
.IP \[bu] 2
The returned iterator inherits from \f[CR]Generator\f[R], which means
modifications to \f[CR]Generator.prototype\f[R] are going to affect the
returned iterator, which is a leak of abstraction.
.IP \[bu] 2
The returned iterator does not inherit from a custom prototype, which
makes it harder if we intend to add extra methods to the iterator.
.PP
We can mimic the implementation of built-in iterators, such as map
iterators, by subclassing \f[CR]Iterator\f[R].
This enables us to define extra properties, such as
\f[CR]\[at]\[at]toStringTag\f[R], while making the iterator helper
methods available on the returned iterator.
.IP
.EX
class Range {
  #start;
  #end;
  #step;

  constructor(start, end, step = 1) {
    this.#start = start;
    this.#end = end;
    this.#step = step;
  }

  static #RangeIterator = class extends Iterator {
    #cur;
    #s;
    #e;
    constructor(range) {
      super();
      this.#cur = range.#start;
      this.#s = range.#step;
      this.#e = range.#end;
    }
    static {
      Object.defineProperty(this.prototype, Symbol.toStringTag, {
        value: \[dq]Range Iterator\[dq],
        configurable: true,
        enumerable: false,
        writable: false,
      });

      // Avoid #RangeIterator from being accessible outside
      delete this.prototype.constructor;
    }
    next() {
      if (this.#cur > this.#e) {
        return { value: undefined, done: true };
      }
      const res = { value: this.#cur, done: false };
      this.#cur += this.#s;
      return res;
    }
  };

  [Symbol.iterator]() {
    return new Range.#RangeIterator(this);
  }
}

const range = new Range(1, 5);
for (const num of range) {
  console.log(num);
}
.EE
.PP
The subclassing pattern is useful if you want to create many custom
iterators.
If you have an existing iterable or iterator object which doesn\[cq]t
inherit from \f[CR]Iterator\f[R], and you just want to call iterator
helper methods on it, you can use \f[CR]Iterator.from()\f[R] to create a
one-time \f[CR]Iterator\f[R] instance.
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]Iterator\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#iterator-helpers)
.IP \[bu] 2
\f[CR]Iterator\f[R]
.IP \[bu] 2
\f[CR]Iterator.from()\f[R]
