.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "Object.propertyIsEnumerable" "JS" "August 9, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.propertyIsEnumerable \- Object.prototype.propertyIsEnumerable()
.SH SYNOPSIS
The \f[B]\f[CB]propertyIsEnumerable()\f[B]\f[R] method of
\f[CR]Object\f[R] instances returns a boolean indicating whether the
specified property is this object\[cq]s enumerable own property.
.SH SYNTAX
.IP
.EX
propertyIsEnumerable(prop)
.EE
.SS Parameters
.TP
\f[B]prop\f[R]
The name of the property to test.
Can be a string or a \f[CR]Symbol\f[R].
.SS Return value
A boolean value indicating whether the specified property is enumerable
and is the object\[cq]s own property.
.SH DESCRIPTION
All objects that inherit from \f[CR]Object.prototype\f[R] (that is, all
except \f[CR]null\f[R]\-prototype objects) inherit the
\f[CR]propertyIsEnumerable()\f[R] method.
This method determines if the specified property, string or symbol, is
an enumerable own property of the object.
If the object does not have the specified property, this method returns
\f[CR]false\f[R].
.PP
This method is equivalent to
\f[CR]Object.getOwnPropertyDescriptor(obj, prop)?.enumerable ?? false\f[R].
.SH EXAMPLES
.SS Using propertyIsEnumerable()
The following example shows the use of \f[CR]propertyIsEnumerable()\f[R]
on objects and arrays.
.IP
.EX
const o = {};
const a = [];
o.prop = \[dq]is enumerable\[dq];
a[0] = \[dq]is enumerable\[dq];

o.propertyIsEnumerable(\[dq]prop\[dq]); // true
a.propertyIsEnumerable(0); // true
.EE
.SS User\-defined vs.\ built\-in objects
Most built\-in properties are non\-enumerable by default, while
user\-created object properties are often enumerable, unless explicitly
designated otherwise.
.IP
.EX
const a = [\[dq]is enumerable\[dq]];

a.propertyIsEnumerable(0); // true
a.propertyIsEnumerable(\[dq]length\[dq]); // false

Math.propertyIsEnumerable(\[dq]random\[dq]); // false
globalThis.propertyIsEnumerable(\[dq]Math\[dq]); // false
.EE
.SS Direct vs.\ inherited properties
Only enumerable own properties cause \f[CR]propertyIsEnumerable()\f[R]
to return \f[CR]true\f[R], although all enumerable properties, including
inherited ones, are visited by the \f[CR]for...in\f[R] loop.
.IP
.EX
const o1 = {
  enumerableInherited: \[dq]is enumerable\[dq],
};
Object.defineProperty(o1, \[dq]nonEnumerableInherited\[dq], {
  value: \[dq]is non\-enumerable\[dq],
  enumerable: false,
});
const o2 = {
  // o1 is the prototype of o2
  __proto__: o1,
  enumerableOwn: \[dq]is enumerable\[dq],
};
Object.defineProperty(o2, \[dq]nonEnumerableOwn\[dq], {
  value: \[dq]is non\-enumerable\[dq],
  enumerable: false,
});

o2.propertyIsEnumerable(\[dq]enumerableInherited\[dq]); // false
o2.propertyIsEnumerable(\[dq]nonEnumerableInherited\[dq]); // false
o2.propertyIsEnumerable(\[dq]enumerableOwn\[dq]); // true
o2.propertyIsEnumerable(\[dq]nonEnumerableOwn\[dq]); // false
.EE
.SS Testing symbol properties
\f[CR]Symbol\f[R] properties are also supported by
\f[CR]propertyIsEnumerable()\f[R].
Note that most enumeration methods only visit string properties;
enumerability of symbol properties is only useful when using
\f[CR]Object.assign()\f[R] or spread syntax.
For more information, see Enumerability and ownership of properties.
.IP
.EX
const sym = Symbol(\[dq]enumerable\[dq]);
const sym2 = Symbol(\[dq]non\-enumerable\[dq]);
const o = {
  [sym]: \[dq]is enumerable\[dq],
};
Object.defineProperty(o, sym2, {
  value: \[dq]is non\-enumerable\[dq],
  enumerable: false,
});

o.propertyIsEnumerable(sym); // true
o.propertyIsEnumerable(sym2); // false
.EE
.SS Usage with null\-prototype objects
Because \f[CR]null\f[R]\-prototype objects do not inherit from
\f[CR]Object.prototype\f[R], they do not inherit the
\f[CR]propertyIsEnumerable()\f[R] method.
You must call \f[CR]Object.prototype.propertyIsEnumerable\f[R] with the
object as \f[CR]this\f[R] instead.
.IP
.EX
const o = {
  __proto__: null,
  enumerableOwn: \[dq]is enumerable\[dq],
};

o.propertyIsEnumerable(\[dq]enumerableOwn\[dq]); // TypeError: o.propertyIsEnumerable is not a function
Object.prototype.propertyIsEnumerable.call(o, \[dq]enumerableOwn\[dq]); // true
.EE
.PP
Alternatively, you may use \f[CR]Object.getOwnPropertyDescriptor()\f[R]
instead, which also helps to distinguish between non\-existent
properties and actually non\-enumerable properties.
.IP
.EX
const o = {
  __proto__: null,
  enumerableOwn: \[dq]is enumerable\[dq],
};

Object.getOwnPropertyDescriptor(o, \[dq]enumerableOwn\[dq])?.enumerable; // true
Object.getOwnPropertyDescriptor(o, \[dq]nonExistent\[dq])?.enumerable; // undefined
.EE
.SH SEE ALSO
.IP \[bu] 2
Enumerability and ownership of properties
.IP \[bu] 2
\f[CR]for...in\f[R]
.IP \[bu] 2
\f[CR]Object.keys()\f[R]
.IP \[bu] 2
\f[CR]Object.defineProperty()\f[R]
