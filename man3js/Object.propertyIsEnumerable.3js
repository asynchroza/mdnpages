.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Object.propertyIsEnumerable" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Object.propertyIsEnumerable - Object.prototype.propertyIsEnumerable()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]propertyIsEnumerable()\f[B]\f[R] method returns a boolean
indicating whether the specified property is the object\[cq]s enumerable
own property.
.SH SYNTAX
.IP
.nf
\f[C]
propertyIsEnumerable(prop)
\f[R]
.fi
.SS Parameters
.TP
\f[B]prop\f[R]
The name of the property to test.
Can be a string or a \f[V]Symbol\f[R].
.SS Return value
.PP
A boolean value indicating whether the specified property is enumerable
and is the object\[cq]s own property.
.SH DESCRIPTION
.PP
All objects that inherit from \f[V]Object.prototype\f[R] (that is, all
except \f[V]null\f[R]-prototype objects) inherit the
\f[V]propertyIsEnumerable()\f[R] method.
This method determines if the specified property, string or symbol, is
an enumerable own property of the object.
If the object does not have the specified property, this method returns
\f[V]false\f[R].
.PP
This method is equivalent to
\f[V]Object.getOwnPropertyDescriptor(obj, prop)?.enumerable ?? false\f[R].
.SH EXAMPLES
.SS Using propertyIsEnumerable()
.PP
The following example shows the use of \f[V]propertyIsEnumerable()\f[R]
on objects and arrays.
.IP
.nf
\f[C]
const o = {};
const a = [];
o.prop = \[dq]is enumerable\[dq];
a[0] = \[dq]is enumerable\[dq];

o.propertyIsEnumerable(\[dq]prop\[dq]); // true
a.propertyIsEnumerable(0); // true
\f[R]
.fi
.SS User-defined vs.\ built-in objects
.PP
Most built-in properties are non-enumerable by default, while
user-created object properties are often enumerable, unless explicitly
designated otherwise.
.IP
.nf
\f[C]
const a = [\[dq]is enumerable\[dq]];

a.propertyIsEnumerable(0); // true
a.propertyIsEnumerable(\[dq]length\[dq]); // false

Math.propertyIsEnumerable(\[dq]random\[dq]); // false
globalThis.propertyIsEnumerable(\[dq]Math\[dq]); // false
\f[R]
.fi
.SS Direct vs.\ inherited properties
.PP
Only enumerable own properties cause \f[V]propertyIsEnumerable()\f[R] to
return \f[V]true\f[R], although all enumerable properties, including
inherited ones, are visited by the \f[V]for...in\f[R] loop.
.IP
.nf
\f[C]
const o1 = {
  enumerableInherited: \[dq]is enumerable\[dq],
};
Object.defineProperty(o1, \[dq]nonEnumerableInherited\[dq], {
  value: \[dq]is non-enumerable\[dq],
  enumerable: false,
});
const o2 = {
  // o1 is the prototype of o2
  __proto__: o1,
  enumerableOwn: \[dq]is enumerable\[dq],
};
Object.defineProperty(o2, \[dq]nonEnumerableOwn\[dq], {
  value: \[dq]is non-enumerable\[dq],
  enumerable: false,
});

o2.propertyIsEnumerable(\[dq]enumerableInherited\[dq]); // false
o2.propertyIsEnumerable(\[dq]nonEnumerableInherited\[dq]); // false
o2.propertyIsEnumerable(\[dq]enumerableOwn\[dq]); // true
o2.propertyIsEnumerable(\[dq]nonEnumerableOwn\[dq]); // false
\f[R]
.fi
.SS Testing symbol properties
.PP
\f[V]Symbol\f[R] properties are also supported by
\f[V]propertyIsEnumerable()\f[R].
Note that most enumeration methods only visit string properties;
enumerability of symbol properties is only useful when using
\f[V]Object.assign()\f[R] or spread syntax.
For more information, see Enumerability and ownership of properties.
.IP
.nf
\f[C]
const sym = Symbol(\[dq]enumerable\[dq]);
const sym2 = Symbol(\[dq]non-enumerable\[dq]);
const o = {
  [sym]: \[dq]is enumerable\[dq],
};
Object.defineProperty(o, sym2, {
  value: \[dq]is non-enumerable\[dq],
  enumerable: false,
});

o.propertyIsEnumerable(sym); // true
o.propertyIsEnumerable(sym2); // false
\f[R]
.fi
.SS Usage with null-prototype objects
.PP
Because \f[V]null\f[R]-prototype objects do not inherit from
\f[V]Object.prototype\f[R], they do not inherit the
\f[V]propertyIsEnumerable()\f[R] method.
You must call \f[V]Object.prototype.propertyIsEnumerable\f[R] with the
object as \f[V]this\f[R] instead.
.IP
.nf
\f[C]
const o = {
  __proto__: null,
  enumerableOwn: \[dq]is enumerable\[dq],
};

o.propertyIsEnumerable(\[dq]enumerableOwn\[dq]); // TypeError: o.propertyIsEnumerable is not a function
Object.prototype.propertyIsEnumerable.call(o, \[dq]enumerableOwn\[dq]); // true
\f[R]
.fi
.PP
Alternatively, you may use \f[V]Object.getOwnPropertyDescriptor()\f[R]
instead, which also helps to distinguish between non-existent properties
and actually non-enumerable properties.
.IP
.nf
\f[C]
const o = {
  __proto__: null,
  enumerableOwn: \[dq]is enumerable\[dq],
};

Object.getOwnPropertyDescriptor(o, \[dq]enumerableOwn\[dq])?.enumerable; // true
Object.getOwnPropertyDescriptor(o, \[dq]nonExistent\[dq])?.enumerable; // undefined
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Enumerability and ownership of properties
.IP \[bu] 2
\f[V]for...in\f[R]
.IP \[bu] 2
\f[V]Object.keys()\f[R]
.IP \[bu] 2
\f[V]Object.defineProperty()\f[R]
