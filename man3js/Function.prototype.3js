'\" t
.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Function.prototype" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]prototype\f[B]\f[R] data property of a \f[V]Function\f[R]
instance is used when the function is used as a constructor with the
\f[V]new\f[R] operator.
It will become the new object\[cq]s prototype.
.RS
.PP
\f[B]Note:\f[R] Not all \f[V]Function\f[R] objects have the
\f[V]prototype\f[R] property \[em] see description.
.RE
.SH Value
.PP
An object.
.PP
.TS
tab(@);
l l.
T{
Writable
T}@T{
yes
T}
T{
Enumerable
T}@T{
no
T}
T{
Configurable
T}@T{
no
T}
.TE
.RS
.PP
\f[B]Note:\f[R] The \f[V]prototype\f[R] property of classes is not
writable.
.RE
.SH Description
.PP
When a function is called with \f[V]new\f[R], the constructor\[cq]s
\f[V]prototype\f[R] property will become the resulting object\[cq]s
prototype.
.IP
.nf
\f[C]
function Ctor() {}
const inst = new Ctor();
console.log(Object.getPrototypeOf(inst) === Ctor.prototype); // true
\f[R]
.fi
.PP
You can read Inheritance and the prototype chain for more information
about the interactions between a constructor function\[cq]s
\f[V]prototype\f[R] property and the resulting object\[cq]s prototype.
.PP
A function having a \f[V]prototype\f[R] property is not sufficient for
it to be eligible as a constructor.
Generator functions have a \f[V]prototype\f[R] property, but cannot be
called with \f[V]new\f[R]:
.IP
.nf
\f[C]
async function* asyncGeneratorFunction() {}
function* generatorFunction() {}
\f[R]
.fi
.PP
Instead, generator functions\[cq] \f[V]prototype\f[R] property is used
when they are called \f[I]without\f[R] \f[V]new\f[R].
The \f[V]prototype\f[R] property will become the returned
\f[V]Generator\f[R] object\[cq]s prototype.
.PP
In addition, some functions may have a \f[V]prototype\f[R] but throw
unconditionally when called with \f[V]new\f[R].
For example, the \f[V]Symbol()\f[R] and \f[V]BigInt()\f[R] functions
throw when called with \f[V]new\f[R], because \f[V]Symbol.prototype\f[R]
and \f[V]BigInt.prototype\f[R] are only intended to provide methods for
the primitive values, but the wrapper objects should not be directly
constructed.
.PP
The following functions do not have \f[V]prototype\f[R], and are
therefore ineligible as constructors, even if a \f[V]prototype\f[R]
property is later manually assigned:
.IP
.nf
\f[C]
const method = { foo() {} }.foo;
const arrowFunction = () => {};
async function asyncFunction() {}
\f[R]
.fi
.PP
The following are valid constructors that have \f[V]prototype\f[R]:
.IP
.nf
\f[C]
class Class {}
function fn() {}
\f[R]
.fi
.PP
A bound function does not have a \f[V]prototype\f[R] property, but may
be constructable.
When it\[cq]s constructed, the target function is constructed instead,
and if the target function is constructable, it would return a normal
instance.
.IP
.nf
\f[C]
const boundFunction = function () {}.bind(null);
\f[R]
.fi
.PP
A function\[cq]s \f[V]prototype\f[R] property, by default, is a plain
object with one property: \f[V]constructor\f[R], which is a reference to
the function itself.
The \f[V]constructor\f[R] property is writable, non-enumerable, and
configurable.
.PP
If the \f[V]prototype\f[R] of a function is reassigned with something
other than an \f[V]Object\f[R], when the function is called with
\f[V]new\f[R], the returned object\[cq]s prototype would be
\f[V]Object.prototype\f[R] instead.
(In other words, \f[V]new\f[R] ignores the \f[V]prototype\f[R] property
and constructs a plain object.)
.IP
.nf
\f[C]
function Ctor() {}
Ctor.prototype = 3;
console.log(Object.getPrototypeOf(new Ctor()) === Object.prototype); // true
\f[R]
.fi
.SH Examples
.SS Changing the prototype of all instances by mutating the prototype property
.IP
.nf
\f[C]
function Ctor() {}
const p1 = new Ctor();
const p2 = new Ctor();
Ctor.prototype.prop = 1;
console.log(p1.prop); // 1
console.log(p2.prop); // 1
\f[R]
.fi
.SS Adding a non-method property to a class\[cq]s prototype property
.PP
Class fields add properties to each instance.
Class methods declare \f[I]function\f[R] properties on the prototype.
However, there\[cq]s no way to add a non-function property to the
prototype.
In case you want to share static data between all instances (for
example, \f[V]Error.prototype.name\f[R] is the same between all error
instances), you can manually assign it on the \f[V]prototype\f[R] of a
class.
.IP
.nf
\f[C]
class Dog {
  constructor(name) {
    this.name = name;
  }
}

Dog.prototype.species = \[dq]dog\[dq];

console.log(new Dog(\[dq]Jack\[dq]).species); // \[dq]dog\[dq]
\f[R]
.fi
.PP
This can be made more ergonomic using static initialization blocks,
which are called when the class is initialized.
.IP
.nf
\f[C]
class Dog {
  static {
    Dog.prototype.species = \[dq]dog\[dq];
  }
  constructor(name) {
    this.name = name;
  }
}

console.log(new Dog(\[dq]Jack\[dq]).species); // \[dq]dog\[dq]
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]Function\f[R]
.IP \[bu] 2
Inheritance and the prototype chain
