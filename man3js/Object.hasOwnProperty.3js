.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Object.hasOwnProperty" "JS" "September 25, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Object.hasOwnProperty - Object.prototype.hasOwnProperty()
.SH SYNOPSIS
The \f[B]\f[CB]hasOwnProperty()\f[B]\f[R] method of \f[CR]Object\f[R]
instances returns a boolean indicating whether this object has the
specified property as its own property (as opposed to inheriting it).
.RS
.PP
\f[B]Note:\f[R] \f[CR]Object.hasOwn()\f[R] is recommended over
\f[CR]hasOwnProperty()\f[R], in browsers where it is supported.
.RE
.SH SYNTAX
.IP
.EX
hasOwnProperty(prop)
.EE
.SS Parameters
.TP
\f[B]prop\f[R]
The \f[CR]String\f[R] name or Symbol of the property to test.
.SS Return value
Returns \f[CR]true\f[R] if the object has the specified property as own
property; \f[CR]false\f[R] otherwise.
.SH DESCRIPTION
The \f[B]\f[CB]hasOwnProperty()\f[B]\f[R] method returns \f[CR]true\f[R]
if the specified property is a direct property of the object \[em] even
if the value is \f[CR]null\f[R] or \f[CR]undefined\f[R].
The method returns \f[CR]false\f[R] if the property is inherited, or has
not been declared at all.
Unlike the \f[CR]in\f[R] operator, this method does not check for the
specified property in the object\[cq]s prototype chain.
.PP
The method can be called on \f[I]most\f[R] JavaScript objects, because
most objects descend from \f[CR]Object\f[R], and hence inherit its
methods.
For example \f[CR]Array\f[R] is an \f[CR]Object\f[R], so you can use
\f[CR]hasOwnProperty()\f[R] method to check whether an index exists:
.IP
.EX
const fruits = [\[dq]Apple\[dq], \[dq]Banana\[dq], \[dq]Watermelon\[dq], \[dq]Orange\[dq]];
fruits.hasOwnProperty(3); // true (\[aq]Orange\[aq])
fruits.hasOwnProperty(4); // false - not defined
.EE
.PP
The method will not be available in objects where it is reimplemented,
or on \f[CR]null\f[R]-prototype objects (as these don\[cq]t inherit from
\f[CR]Object.prototype\f[R]).
Examples for these cases are given below.
.SH EXAMPLES
.SS Using hasOwnProperty to test for an own property\[cq]s existence
The following code shows how to determine whether the \f[CR]example\f[R]
object contains a property named \f[CR]prop\f[R].
.IP
.EX
const example = {};
example.hasOwnProperty(\[dq]prop\[dq]); // false

example.prop = \[dq]exists\[dq];
example.hasOwnProperty(\[dq]prop\[dq]); // true - \[aq]prop\[aq] has been defined

example.prop = null;
example.hasOwnProperty(\[dq]prop\[dq]); // true - own property exists with value of null

example.prop = undefined;
example.hasOwnProperty(\[dq]prop\[dq]); // true - own property exists with value of undefined
.EE
.SS Direct vs.\ inherited properties
The following example differentiates between direct properties and
properties inherited through the prototype chain:
.IP
.EX
const example = {};
example.prop = \[dq]exists\[dq];

// \[ga]hasOwnProperty\[ga] will only return true for direct properties:
example.hasOwnProperty(\[dq]prop\[dq]); // true
example.hasOwnProperty(\[dq]toString\[dq]); // false
example.hasOwnProperty(\[dq]hasOwnProperty\[dq]); // false

// The \[ga]in\[ga] operator will return true for direct or inherited properties:
\[dq]prop\[dq] in example; // true
\[dq]toString\[dq] in example; // true
\[dq]hasOwnProperty\[dq] in example; // true
.EE
.SS Iterating over the properties of an object
The following example shows how to iterate over the enumerable
properties of an object without executing on inherited properties.
.IP
.EX
const buz = {
  fog: \[dq]stack\[dq],
};

for (const name in buz) {
  if (buz.hasOwnProperty(name)) {
    console.log(\[ga]this is fog (${name}) for sure. Value: ${buz[name]}\[ga]);
  } else {
    console.log(name); // toString or something else
  }
}
.EE
.PP
Note that the \f[CR]for...in\f[R] loop only iterates enumerable items:
the absence of non-enumerable properties emitted from the loop does not
imply that \f[CR]hasOwnProperty\f[R] itself is confined strictly to
enumerable items (as with \f[CR]Object.getOwnPropertyNames()\f[R]).
.SS Using hasOwnProperty as a property name
JavaScript does not protect the property name \f[CR]hasOwnProperty\f[R];
an object that has a property with this name may return incorrect
results:
.IP
.EX
const foo = {
  hasOwnProperty() {
    return false;
  },
  bar: \[dq]Here be dragons\[dq],
};

foo.hasOwnProperty(\[dq]bar\[dq]); // re-implementation always returns false
.EE
.PP
The recommended way to overcome this problem is to instead use
\f[CR]Object.hasOwn()\f[R] (in browsers that support it).
Other alternatives include using an \f[I]external\f[R]
\f[CR]hasOwnProperty\f[R]:
.IP
.EX
const foo = { bar: \[dq]Here be dragons\[dq] };

// Use Object.hasOwn() method - recommended
Object.hasOwn(foo, \[dq]bar\[dq]); // true

// Use the hasOwnProperty property from the Object prototype
Object.prototype.hasOwnProperty.call(foo, \[dq]bar\[dq]); // true

// Use another Object\[aq]s hasOwnProperty
// and call it with \[aq]this\[aq] set to foo
({}).hasOwnProperty.call(foo, \[dq]bar\[dq]); // true
.EE
.PP
Note that in the first two cases there are no newly created objects.
.SS Objects created with Object.create(null)
\f[CR]null\f[R]-prototype objects do not inherit from
\f[CR]Object.prototype\f[R], making \f[CR]hasOwnProperty()\f[R]
inaccessible.
.IP
.EX
const foo = Object.create(null);
foo.prop = \[dq]exists\[dq];
foo.hasOwnProperty(\[dq]prop\[dq]); // Uncaught TypeError: foo.hasOwnProperty is not a function
.EE
.PP
The solutions in this case are the same as for the previous section: use
\f[CR]Object.hasOwn()\f[R] by preference, otherwise use an external
object\[cq]s \f[CR]hasOwnProperty()\f[R].
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Object.hasOwn()\f[R]
.IP \[bu] 2
Enumerability and ownership of properties
.IP \[bu] 2
\f[CR]Object.getOwnPropertyNames()\f[R]
.IP \[bu] 2
\f[CR]for...in\f[R]
.IP \[bu] 2
\f[CR]in\f[R]
.IP \[bu] 2
Inheritance and the prototype chain
