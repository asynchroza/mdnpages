.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Object.hasOwnProperty" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Object.hasOwnProperty - Object.prototype.hasOwnProperty()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]hasOwnProperty()\f[B]\f[R] method returns a boolean
indicating whether the object has the specified property as its own
property (as opposed to inheriting it).
.RS
.PP
\f[B]Note:\f[R] \f[V]Object.hasOwn()\f[R] is recommended over
\f[V]hasOwnProperty()\f[R], in browsers where it is supported.
.RE
.SH SYNTAX
.IP
.nf
\f[C]
hasOwnProperty(prop)
\f[R]
.fi
.SS Parameters
.TP
\f[B]prop\f[R]
The \f[V]String\f[R] name or Symbol of the property to test.
.SS Return value
.PP
Returns \f[V]true\f[R] if the object has the specified property as own
property; \f[V]false\f[R] otherwise.
.SH DESCRIPTION
.PP
The \f[B]\f[VB]hasOwnProperty()\f[B]\f[R] method returns \f[V]true\f[R]
if the specified property is a direct property of the object \[em] even
if the value is \f[V]null\f[R] or \f[V]undefined\f[R].
The method returns \f[V]false\f[R] if the property is inherited, or has
not been declared at all.
Unlike the \f[V]in\f[R] operator, this method does not check for the
specified property in the object\[cq]s prototype chain.
.PP
The method can be called on \f[I]most\f[R] JavaScript objects, because
most objects descend from \f[V]Object\f[R], and hence inherit its
methods.
For example \f[V]Array\f[R] is an \f[V]Object\f[R], so you can use
\f[V]hasOwnProperty()\f[R] method to check whether an index exists:
.IP
.nf
\f[C]
const fruits = [\[dq]Apple\[dq], \[dq]Banana\[dq], \[dq]Watermelon\[dq], \[dq]Orange\[dq]];
fruits.hasOwnProperty(3); // true (\[aq]Orange\[aq])
fruits.hasOwnProperty(4); // false - not defined
\f[R]
.fi
.PP
The method will not be available in objects where it is reimplemented,
or on objects created using \f[V]Object.create(null)\f[R] (as these
don\[cq]t inherit from \f[V]Object.prototype\f[R]).
Examples for these cases are given below.
.SH EXAMPLES
.SS Using hasOwnProperty to test for an own property\[cq]s existence
.PP
The following code shows how to determine whether the \f[V]example\f[R]
object contains a property named \f[V]prop\f[R].
.IP
.nf
\f[C]
const example = {};
example.hasOwnProperty(\[dq]prop\[dq]); // false

example.prop = \[dq]exists\[dq];
example.hasOwnProperty(\[dq]prop\[dq]); // true - \[aq]prop\[aq] has been defined

example.prop = null;
example.hasOwnProperty(\[dq]prop\[dq]); // true - own property exists with value of null

example.prop = undefined;
example.hasOwnProperty(\[dq]prop\[dq]); // true - own property exists with value of undefined
\f[R]
.fi
.SS Direct vs.\ inherited properties
.PP
The following example differentiates between direct properties and
properties inherited through the prototype chain:
.IP
.nf
\f[C]
const example = {};
example.prop = \[dq]exists\[dq];

// \[ga]hasOwnProperty\[ga] will only return true for direct properties:
example.hasOwnProperty(\[dq]prop\[dq]); // true
example.hasOwnProperty(\[dq]toString\[dq]); // false
example.hasOwnProperty(\[dq]hasOwnProperty\[dq]); // false

// The \[ga]in\[ga] operator will return true for direct or inherited properties:
\[dq]prop\[dq] in example; // true
\[dq]toString\[dq] in example; // true
\[dq]hasOwnProperty\[dq] in example; // true
\f[R]
.fi
.SS Iterating over the properties of an object
.PP
The following example shows how to iterate over the enumerable
properties of an object without executing on inherited properties.
.IP
.nf
\f[C]
const buz = {
  fog: \[dq]stack\[dq],
};

for (const name in buz) {
  if (buz.hasOwnProperty(name)) {
    console.log(\[ga]this is fog (${name}) for sure. Value: ${buz[name]}\[ga]);
  } else {
    console.log(name); // toString or something else
  }
}
\f[R]
.fi
.PP
Note that the \f[V]for...in\f[R] loop only iterates enumerable items:
the absence of non-enumerable properties emitted from the loop does not
imply that \f[V]hasOwnProperty\f[R] itself is confined strictly to
enumerable items (as with \f[V]Object.getOwnPropertyNames()\f[R]).
.SS Using hasOwnProperty as a property name
.PP
JavaScript does not protect the property name \f[V]hasOwnProperty\f[R];
an object that has a property with this name may return incorrect
results:
.IP
.nf
\f[C]
const foo = {
  hasOwnProperty() {
    return false;
  },
  bar: \[dq]Here be dragons\[dq],
};

foo.hasOwnProperty(\[dq]bar\[dq]); // re-implementation always returns false
\f[R]
.fi
.PP
The recommended way to overcome this problem is to instead use
\f[V]Object.hasOwn()\f[R] (in browsers that support it).
Other alternatives include using an \f[I]external\f[R]
\f[V]hasOwnProperty\f[R]:
.IP
.nf
\f[C]
const foo = { bar: \[dq]Here be dragons\[dq] };

// Use Object.hasOwn() method - recommended
Object.hasOwn(foo, \[dq]bar\[dq]); // true

// Use the hasOwnProperty property from the Object prototype
Object.prototype.hasOwnProperty.call(foo, \[dq]bar\[dq]); // true

// Use another Object\[aq]s hasOwnProperty
// and call it with \[aq]this\[aq] set to foo
({}).hasOwnProperty.call(foo, \[dq]bar\[dq]); // true
\f[R]
.fi
.PP
Note that in the first two cases there are no newly created objects.
.SS Objects created with Object.create(null)
.PP
Objects created using \f[V]Object.create(null)\f[R] do not inherit from
\f[V]Object.prototype\f[R], making \f[V]hasOwnProperty()\f[R]
inaccessible.
.IP
.nf
\f[C]
const foo = Object.create(null);
foo.prop = \[dq]exists\[dq];
foo.hasOwnProperty(\[dq]prop\[dq]); // Uncaught TypeError: foo.hasOwnProperty is not a function
\f[R]
.fi
.PP
The solutions in this case are the same as for the previous section: use
\f[V]Object.hasOwn()\f[R] by preference, otherwise use an external
object\[cq]s \f[V]hasOwnProperty()\f[R].
.SH SEE ALSO
.IP \[bu] 2
\f[V]Object.hasOwn()\f[R]
.IP \[bu] 2
Enumerability and ownership of properties
.IP \[bu] 2
\f[V]Object.getOwnPropertyNames()\f[R]
.IP \[bu] 2
\f[V]for...in\f[R]
.IP \[bu] 2
\f[V]in\f[R]
.IP \[bu] 2
JavaScript Guide: Inheritance revisited
