.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Iterator.flatMap" "JS" "August 26, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Iterator.flatMap - Iterator.prototype.flatMap()
.SH SYNOPSIS
The \f[B]\f[CB]flatMap()\f[B]\f[R] method of \f[CR]Iterator\f[R]
instances returns a new iterator helper that takes each element in the
original iterator, runs it through a mapping function, and yields
elements returned by the mapping function (which are contained in
another iterator or iterable).
.SH SYNTAX
.IP
.EX
flatMap(callbackFn)
.EE
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element produced by the iterator.
It should return an iterator or iterable that yields elements to be
yielded by \f[CR]flatMap()\f[R], or a single non-iterator/iterable value
to be yielded.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the array.
.TP
\f[B]index\f[R]
The index of the current element being processed in the array.
.RE
.SS Return value
A new iterator helper.
The first time the iterator helper\[cq]s \f[CR]next()\f[R] method is
called, it calls \f[CR]callbackFn\f[R] on the first element produced by
the underlying iterator, and the return value, which should be an
iterator or iterable, is yielded one-by-one by the iterator helper (like
\f[CR]yield*\f[R]).
The next element is fetched from the underlying iterator when the
previous one returned by \f[CR]callbackFn\f[R] is completed.
When the underlying iterator is completed, the iterator helper is also
completed (the \f[CR]next()\f[R] method produces
\f[CR]{ value: undefined, done: true }\f[R]).
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if \f[CR]callbackFn\f[R] returns a non-iterator/iterable value or
a string primitive.
.SH DESCRIPTION
\f[CR]flatMap\f[R] accepts two kinds of return values from
\f[CR]callbackFn\f[R]: an iterator or iterable.
They are handled in the same way as \f[CR]Iterator.from()\f[R]: if the
return value is iterable, the \f[CR]\[at]\[at]iterator\f[R] method is
called and the return value is used; otherwise, the return value is
treated as an iterator and its \f[CR]next()\f[R] method is called.
.IP
.EX
[1, 2, 3]
  .values()
  .flatMap((x) => {
    let itDone = false;
    const it = {
      next() {
        if (itDone) {
          return { value: undefined, done: true };
        }
        itDone = true;
        return { value: x, done: false };
      },
    };
    switch (x) {
      case 1:
        // An iterable that\[aq]s not an iterator
        return { [Symbol.iterator]: () => it };
      case 2:
        // An iterator that\[aq]s not an iterable
        return it;
      case 3:
        // An iterable iterator is treated as an iterable
        return {
          ...it,
          [Symbol.iterator]() {
            console.log(\[dq]\[at]\[at]iterator called\[dq]);
            return it;
          },
        };
    }
  })
  .toArray();
// Logs \[dq]\[at]\[at]iterator called\[dq]
// Returns [1, 2, 3]
.EE
.SH EXAMPLES
.SS Merging maps
The following example merges two \f[CR]Map\f[R] objects into one:
.IP
.EX
const map1 = new Map([
  [\[dq]a\[dq], 1],
  [\[dq]b\[dq], 2],
  [\[dq]c\[dq], 3],
]);
const map2 = new Map([
  [\[dq]d\[dq], 4],
  [\[dq]e\[dq], 5],
  [\[dq]f\[dq], 6],
]);

const merged = new Map([map1, map2].values().flatMap((x) => x));
console.log(merged.get(\[dq]a\[dq])); // 1
console.log(merged.get(\[dq]e\[dq])); // 5
.EE
.PP
This avoids creating any temporary copies of the map\[cq]s content.
Note that the array \f[CR][map1, map2]\f[R] must first be converted to
an iterator (using \f[CR]Array.prototype.values()\f[R]), because
\f[CR]Array.prototype.flatMap()\f[R] only flattens arrays, not
iterables.
.IP
.EX
new Map([map1, map2].flatMap((x) => x)); // Map(1) {undefined => undefined}
.EE
.SS Returning strings
Strings are iterable, but \f[CR]flatMap()\f[R] specifically rejects
string primitives returned from \f[CR]callbackFn\f[R], this is because
the behavior of iterating by code points is often not what you want.
.PP
\f[B]Bad\f[R]
.IP
.EX
[1, 2, 3]
  .values()
  .flatMap((x) => String(x))
  .toArray(); // TypeError: Iterator.prototype.flatMap called on non-object
.EE
.PP
You may want to wrap it in an array instead so the entire string is
yielded as one:
.IP
.EX
[1, 2, 3]
  .values()
  .flatMap((x) => [String(x)])
  .toArray(); // [\[aq]1\[aq], \[aq]2\[aq], \[aq]3\[aq]]
.EE
.PP
Or, if the behavior of iterating by code points is intended, you can use
\f[CR]Iterator.from()\f[R] to convert it to a proper iterator:
.IP
.EX
[1, 2, 3]
  .values()
  .flatMap((x) => Iterator.from(String(x * 10)))
  .toArray();
// [\[aq]1\[aq], \[aq]0\[aq], \[aq]2\[aq], \[aq]0\[aq], \[aq]3\[aq], \[aq]0\[aq]]
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]Iterator.prototype.flatMap\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#iterator-helpers)
