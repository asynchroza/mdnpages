.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Proxy.Proxy.setPrototypeOf" "JS" "February 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Proxy.Proxy.setPrototypeOf - handler.setPrototypeOf()
.SH SYNOPSIS
The \f[B]\f[CB]handler.setPrototypeOf()\f[B]\f[R] method is a trap for
the \f[CR][[SetPrototypeOf]]\f[R] object internal method, which is used
by operations such as \f[CR]Object.setPrototypeOf()\f[R].
.SH SYNTAX
.IP
.EX
new Proxy(target, {
  setPrototypeOf(target, prototype) {
  }
});
.EE
.SS Parameters
The following parameters are passed to the \f[CR]setPrototypeOf()\f[R]
method.
\f[CR]this\f[R] is bound to the handler.
.TP
\f[B]target\f[R]
The target object.
.TP
\f[B]prototype\f[R]
The object\[cq]s new prototype or \f[CR]null\f[R].
.SS Return value
The \f[CR]setPrototypeOf()\f[R] method returns \f[CR]true\f[R] if the
\f[CR][[Prototype]]\f[R] was successfully changed, otherwise
\f[CR]false\f[R].
.SH DESCRIPTION
.SS Interceptions
This trap can intercept these operations:
.IP \[bu] 2
\f[CR]Object.setPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]Reflect.setPrototypeOf()\f[R]
.PP
Or any other operation that invokes the \f[CR][[SetPrototypeOf]]\f[R]
internal method.
.SS Invariants
If the following invariants are violated, the trap throws a
\f[CR]TypeError\f[R] when invoked.
.IP \[bu] 2
If \f[CR]target\f[R] is not extensible, the \f[CR]prototype\f[R]
parameter must be the same value as
\f[CR]Object.getPrototypeOf(target)\f[R].
.SH EXAMPLES
If you want to disallow setting a new prototype for your object, your
handler\[cq]s \f[CR]setPrototypeOf()\f[R] method can either return
\f[CR]false\f[R], or it can throw an exception.
.SS Approach 1: Returning false
This approach means that any mutating operation that throws an exception
on failure to mutate, must create the exception itself.
.PP
For example, \f[CR]Object.setPrototypeOf()\f[R] will create and throw a
\f[CR]TypeError\f[R] itself.
If the mutation is performed by an operation that \f[I]doesn\[cq]t\f[R]
ordinarily throw in case of failure, such as
\f[CR]Reflect.setPrototypeOf()\f[R], no exception will be thrown.
.IP
.EX
const handlerReturnsFalse = {
  setPrototypeOf(target, newProto) {
    return false;
  },
};

const newProto = {},
  target = {};

const p1 = new Proxy(target, handlerReturnsFalse);
Object.setPrototypeOf(p1, newProto); // throws a TypeError
Reflect.setPrototypeOf(p1, newProto); // returns false
.EE
.SS Approach 2: Throwing an Exception
The latter approach will cause \f[I]any\f[R] operation that attempts to
mutate, to throw.
This approach is best if you want even non-throwing operations to throw
on failure, or you want to throw a custom exception value.
.IP
.EX
const handlerThrows = {
  setPrototypeOf(target, newProto) {
    throw new Error(\[dq]custom error\[dq]);
  },
};

const newProto = {},
  target = {};

const p2 = new Proxy(target, handlerThrows);
Object.setPrototypeOf(p2, newProto); // throws new Error(\[dq]custom error\[dq])
Reflect.setPrototypeOf(p2, newProto); // throws new Error(\[dq]custom error\[dq])
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Proxy\f[R]
.IP \[bu] 2
\f[CR]Proxy()\f[R] constructor
.IP \[bu] 2
\f[CR]Object.setPrototypeOf()\f[R]
.IP \[bu] 2
\f[CR]Reflect.setPrototypeOf()\f[R]
