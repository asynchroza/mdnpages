.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.flat" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]flat()\f[B]\f[R] method creates a new array with all
sub-array elements concatenated into it recursively up to the specified
depth.
.SH Syntax
.IP
.nf
\f[C]
flat()
flat(depth)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]depth\f[R] \f[I](optional)\f[R]
.RS 2
.IP \[bu] 2
The depth level specifying how deep a nested array structure should be
flattened.
Defaults to 1.
.RE
.SS Return value
.PP
A new array with the sub-array elements concatenated into it.
.SH Description
.PP
The \f[V]flat()\f[R] method is a copying method.
It does not alter \f[V]this\f[R] but instead returns a shallow copy that
contains the same elements as the ones from the original array.
.PP
The \f[V]flat()\f[R] method ignores empty slots if the array being
flattened is sparse.
For example, if \f[V]depth\f[R] is 1, both empty slots in the root array
and in the first level of nested arrays are ignored, but empty slots in
further nested arrays are preserved with the arrays themselves.
.PP
The \f[V]flat()\f[R] method is generic.
It only expects the \f[V]this\f[R] value to have a \f[V]length\f[R]
property and integer-keyed properties.
However, its elements must be arrays if they are to be flattened.
.SH Examples
.SS Flattening nested arrays
.IP
.nf
\f[C]
const arr1 = [1, 2, [3, 4]];
arr1.flat();
// [1, 2, 3, 4]

const arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat();
// [1, 2, 3, 4, [5, 6]]

const arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
// [1, 2, 3, 4, 5, 6]

const arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
arr4.flat(Infinity);
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
\f[R]
.fi
.SS Using flat() on sparse arrays
.PP
The \f[V]flat()\f[R] method removes empty slots in arrays:
.IP
.nf
\f[C]
const arr5 = [1, 2, , 4, 5];
console.log(arr5.flat()); // [1, 2, 4, 5]

const array = [1, , 3, [\[dq]a\[dq], , \[dq]c\[dq]]];
console.log(array.flat()); // [ 1, 3, \[dq]a\[dq], \[dq]c\[dq] ]

const array2 = [1, , 3, [\[dq]a\[dq], , [\[dq]d\[dq], , \[dq]e\[dq]]]];
console.log(array2.flat()); // [ 1, 3, \[dq]a\[dq], [\[dq]d\[dq], empty, \[dq]e\[dq]] ]
console.log(array2.flat(2)); // [ 1, 3, \[dq]a\[dq], \[dq]d\[dq], \[dq]e\[dq]]
\f[R]
.fi
.SS Calling flat() on non-array objects
.PP
The \f[V]flat()\f[R] method reads the \f[V]length\f[R] property of
\f[V]this\f[R] and then accesses each integer index.
If the element is not an array, it\[cq]s directly appended to the
result.
If the element is an array, it\[cq]s flattened according to the
\f[V]depth\f[R] parameter.
.IP
.nf
\f[C]
const arrayLike = {
  length: 3,
  0: [1, 2],
  // Array-like objects aren\[aq]t flattened
  1: { length: 2, 0: 3, 1: 4 },
  2: 5,
};
console.log(Array.prototype.flat.call(arrayLike));
// [ 1, 2, { \[aq]0\[aq]: 3, \[aq]1\[aq]: 4, length: 2 }, 5 ]
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]Array.prototype.flat\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-array)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[V]Array\f[R]
.IP \[bu] 2
\f[V]Array.prototype.concat()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.flatMap()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.map()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.reduce()\f[R]
