.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "WeakSet" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
WeakSet - WeakSet
.SH SYNOPSIS
.PP
A \f[B]\f[VB]WeakSet\f[B]\f[R] is a collection of garbage-collectable
values, including objects and non-registered symbols.
A value in the \f[V]WeakSet\f[R] may only occur once.
It is unique in the \f[V]WeakSet\f[R]\[cq]s collection.
.SH DESCRIPTION
.PP
Values of WeakSets must be garbage-collectable.
Most primitive data types can be arbitrarily created and don\[cq]t have
a lifetime, so they cannot be stored.
Objects and non-registered symbols can be stored because they are
garbage-collectable.
.PP
The main differences to the \f[V]Set\f[R] object are:
.IP \[bu] 2
\f[V]WeakSet\f[R]s are collections of \f[B]objects and symbols
only\f[R].
They cannot contain arbitrary values of any type, as \f[V]Set\f[R]s can.
.IP \[bu] 2
The \f[V]WeakSet\f[R] is \f[I]weak\f[R], meaning references to objects
in a \f[V]WeakSet\f[R] are held \f[I]weakly\f[R].
If no other references to a value stored in the \f[V]WeakSet\f[R] exist,
those values can be garbage collected.
.RS 2
.RS
.PP
\f[B]Note:\f[R] This also means that there is no list of current values
stored in the collection.
\f[V]WeakSets\f[R] are not enumerable.
.RE
.RE
.SS Use case: Detecting circular references
.PP
Functions that call themselves recursively need a way of guarding
against circular data structures by tracking which objects have already
been processed.
.PP
\f[V]WeakSet\f[R]s are ideal for this purpose:
.IP
.nf
\f[C]
// Execute a callback on everything stored inside an object
function execRecursively(fn, subject, _refs = new WeakSet()) {
  // Avoid infinite recursion
  if (_refs.has(subject)) {
    return;
  }

  fn(subject);
  if (typeof subject === \[dq]object\[dq]) {
    _refs.add(subject);
    for (const key in subject) {
      execRecursively(fn, subject[key], _refs);
    }
    _refs.delete(subject);
  }
}

const foo = {
  foo: \[dq]Foo\[dq],
  bar: {
    bar: \[dq]Bar\[dq],
  },
};

foo.bar.baz = foo; // Circular reference!
execRecursively((obj) => console.log(obj), foo);
\f[R]
.fi
.PP
Here, a \f[V]WeakSet\f[R] is created on the first run, and passed along
with every subsequent function call (using the internal \f[V]_refs\f[R]
parameter).
.PP
The number of objects or their traversal order is immaterial, so a
\f[V]WeakSet\f[R] is more suitable (and performant) than a \f[V]Set\f[R]
for tracking object references, especially if a very large number of
objects is involved.
.SH CONSTRUCTOR
.TP
\f[B]WeakSet()\f[R]
Creates a new \f[V]WeakSet\f[R] object.
.SH INSTANCE PROPERTIES
.PP
These properties are defined on \f[V]WeakSet.prototype\f[R] and shared
by all \f[V]WeakSet\f[R] instances.
.TP
\f[B]WeakSet.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[V]WeakSet\f[R] instances, the initial value is the
\f[V]WeakSet\f[R] constructor.
.TP
\f[B]WeakSet.prototype[\[at]\[at]toStringTag]\f[R]
The initial value of the \f[V]\[at]\[at]toStringTag\f[R] property is the
string \f[V]\[dq]WeakSet\[dq]\f[R].
This property is used in \f[V]Object.prototype.toString()\f[R].
.SH INSTANCE METHODS
.TP
\f[B]WeakSet.prototype.add()\f[R]
Appends \f[V]value\f[R] to the \f[V]WeakSet\f[R] object.
.TP
\f[B]WeakSet.prototype.delete()\f[R]
Removes \f[V]value\f[R] from the \f[V]WeakSet\f[R].
\f[V]WeakSet.prototype.has(value)\f[R] will return \f[V]false\f[R]
afterwards.
.TP
\f[B]WeakSet.prototype.has()\f[R]
Returns a boolean asserting whether \f[V]value\f[R] is present in the
\f[V]WeakSet\f[R] object or not.
.SH EXAMPLES
.SS Using the WeakSet object
.IP
.nf
\f[C]
const ws = new WeakSet();
const foo = {};
const bar = {};

ws.add(foo);
ws.add(bar);

ws.has(foo); // true
ws.has(bar); // true

ws.delete(foo); // removes foo from the set
ws.has(foo); // false, foo has been removed
ws.has(bar); // true, bar is retained
\f[R]
.fi
.PP
Note that \f[V]foo !== bar\f[R].
While they are similar objects, \f[I]they are not \f[BI]the same
object\f[I]\f[R].
And so they are both added to the set.
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]WeakSet\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#weakset)
.IP \[bu] 2
\f[V]Map\f[R]
.IP \[bu] 2
\f[V]Set\f[R]
.IP \[bu] 2
\f[V]WeakMap\f[R]
