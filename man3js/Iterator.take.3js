.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Iterator.take" "JS" "August 26, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Iterator.take - Iterator.prototype.take()
.SH SYNOPSIS
The \f[B]\f[CB]take()\f[B]\f[R] method of \f[CR]Iterator\f[R] instances
returns a new iterator helper that yields the given number of elements
in this iterator and then terminates.
.SH SYNTAX
.IP
.EX
take(limit)
.EE
.SS Parameters
.TP
\f[B]limit\f[R]
The number of elements to take from the start of the iteration.
.SS Return value
A new iterator helper.
The returned iterator helper yields the elements in the original
iterator one-by-one, and then completes (the \f[CR]next()\f[R] method
produces \f[CR]{ value: undefined, done: true }\f[R]) once
\f[CR]limit\f[R] elements have been yielded, or when the original
iterator is exhausted, whichever comes first.
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if \f[CR]limit\f[R] becomes \f[CR]NaN\f[R] or negative when
converted to an integer.
.SH EXAMPLES
.SS Using take()
The following example creates an iterator that yields terms in the
Fibonacci sequence, and then logs the first three terms:
.IP
.EX
function* fibonacci() {
  let current = 1;
  let next = 1;
  while (true) {
    yield current;
    [current, next] = [next, current + next];
  }
}

const seq = fibonacci().take(3);
console.log(seq.next().value); // 1
console.log(seq.next().value); // 1
console.log(seq.next().value); // 2
console.log(seq.next().value); // undefined
.EE
.SS Using take() with a for\&...of loop
\f[CR]take()\f[R] is most convenient when you are not hand-rolling the
iterator.
Because iterators are also iterable, you can iterate the returned helper
with a \f[CR]for...of\f[R] loop:
.IP
.EX
for (const n of fibonacci().take(5)) {
  console.log(n);
}

// Logs:
// 1
// 1
// 2
// 3
// 5
.EE
.PP
Because \f[CR]fibonacci()\f[R] is an infinite iterator, you can\[cq]t
use a \f[CR]for\f[R] loop to iterate it directly.
.SS Combining drop() with take()
You can combine \f[CR]drop()\f[R] with
\f[CR]Iterator.prototype.take()\f[R] to get a slice of an iterator:
.IP
.EX
for (const n of fibonacci().drop(2).take(5)) {
  // Drops the first two elements, then takes the next five
  console.log(n);
}
// Logs:
// 2
// 3
// 5
// 8
// 13

for (const n of fibonacci().take(5).drop(2)) {
  // Takes the first five elements, then drops the first two
  console.log(n);
}
// Logs:
// 2
// 3
// 5
.EE
.SS Lower and upper bounds of take count
When the \f[CR]limit\f[R] is negative or \f[CR]NaN\f[R], a
\f[CR]RangeError\f[R] is thrown:
.IP
.EX
fibonacci().take(-1); // RangeError: -1 must be positive
fibonacci().take(undefined); // RangeError: undefined must be positive
.EE
.PP
When the \f[CR]limit\f[R] is larger than the total number of elements
the iterator can produce (such as \f[CR]Infinity\f[R]), the returned
iterator helper has essentially the same behavior as the original
iterator:
.IP
.EX
for (const n of new Set([1, 2, 3]).values().take(Infinity)) {
  console.log(n);
}

// Logs:
// 1
// 2
// 3
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]Iterator.prototype.take\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#iterator-helpers)
.IP \[bu] 2
\f[CR]Iterator\f[R]
.IP \[bu] 2
\f[CR]Iterator.prototype.drop()\f[R]
