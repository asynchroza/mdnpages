.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "RegExp" "JS" "December 23, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RegExp - RegExp
.SH SYNOPSIS
The \f[B]\f[CB]RegExp\f[B]\f[R] object is used for matching text with a
pattern.
.PP
For an introduction to regular expressions, read the Regular expressions
chapter in the JavaScript guide.
For detailed information of regular expression syntax, read the regular
expression reference.
.SH DESCRIPTION
.SS Literal notation and constructor
There are two ways to create a \f[CR]RegExp\f[R] object: a \f[I]literal
notation\f[R] and a \f[I]constructor\f[R].
.IP \[bu] 2
The \f[I]literal notation\f[R] takes a pattern between two slashes,
followed by optional flags, after the second slash.
.IP \[bu] 2
The \f[I]constructor function\f[R] takes either a string or a
\f[CR]RegExp\f[R] object as its first parameter and a string of optional
flags as its second parameter.
.PP
The following three expressions create the same regular expression
object:
.IP
.EX
const re = /ab+c/i; // literal notation
// OR
const re = new RegExp(\[dq]ab+c\[dq], \[dq]i\[dq]); // constructor with string pattern as first argument
// OR
const re = new RegExp(/ab+c/, \[dq]i\[dq]); // constructor with regular expression literal as first argument
.EE
.PP
Before regular expressions can be used, they have to be compiled.
This process allows them to perform matches more efficiently.
More about the process can be found in dotnet
docs (https://docs.microsoft.com/dotnet/standard/base-types/compilation-and-reuse-in-regular-expressions).
.PP
The literal notation results in compilation of the regular expression
when the expression is evaluated.
On the other hand, the constructor of the \f[CR]RegExp\f[R] object,
\f[CR]new RegExp(\[aq]ab+c\[aq])\f[R], results in runtime compilation of
the regular expression.
.PP
Use a string as the first argument to the \f[CR]RegExp()\f[R]
constructor when you want to build the regular expression from dynamic
input.
.SS Flags in constructor
The expression \f[CR]new RegExp(/ab+c/, flags)\f[R] will create a new
\f[CR]RegExp\f[R] using the source of the first parameter and the flags
provided by the second.
.PP
When using the constructor function, the normal string escape rules
(preceding special characters with \f[CR]\[rs]\f[R] when included in a
string) are necessary.
.PP
For example, the following are equivalent:
.IP
.EX
const re = /\[rs]w+/;
// OR
const re = new RegExp(\[dq]\[rs]\[rs]w+\[dq]);
.EE
.SS Special handling for regexes
.RS
.PP
\f[B]Note:\f[R] Whether something is a \[lq]regex\[rq] can be
duck-typed (https://en.wikipedia.org/wiki/Duck_typing).
It doesn\[cq]t have to be a \f[CR]RegExp\f[R]!
.RE
.PP
Some built-in methods would treat regexes specially.
They decide whether \f[CR]x\f[R] is a regex through multiple
steps (https://tc39.es/ecma262/multipage/abstract-operations.html#sec-isregexp):
.IP "1." 3
\f[CR]x\f[R] must be an object (not a primitive).
.IP "2." 3
If \f[CR]x[Symbol.match]\f[R] is not \f[CR]undefined\f[R], check if
it\[cq]s truthy.
.IP "3." 3
Otherwise, if \f[CR]x[Symbol.match]\f[R] is \f[CR]undefined\f[R], check
if \f[CR]x\f[R] had been created with the \f[CR]RegExp\f[R] constructor.
(This step should rarely happen, since if \f[CR]x\f[R] is a
\f[CR]RegExp\f[R] object that have not been tampered with, it should
have a \f[CR]Symbol.match\f[R] property.)
.PP
Note that in most cases, it would go through the \f[CR]Symbol.match\f[R]
check, which means:
.IP \[bu] 2
An actual \f[CR]RegExp\f[R] object whose \f[CR]Symbol.match\f[R]
property\[cq]s value is falsy but not \f[CR]undefined\f[R] (even with
everything else intact, like \f[CR]exec\f[R] and
\f[CR]\[at]\[at]replace\f[R]) can be used as if it\[cq]s not a regex.
.IP \[bu] 2
A non-\f[CR]RegExp\f[R] object with a \f[CR]Symbol.match\f[R] property
will be treated as if it\[cq]s a regex.
.PP
This choice was made because \f[CR]\[at]\[at]match\f[R] is the most
indicative property that something is intended to be used for matching.
(\f[CR]exec\f[R] could also be used, but because it\[cq]s not a symbol
property, there would be too many false positives.)
The places that treat regexes specially include:
.IP \[bu] 2
\f[CR]String.prototype.endsWith()\f[R], \f[CR]startsWith()\f[R], and
\f[CR]includes()\f[R] throw a \f[CR]TypeError\f[R] if the first argument
is a regex.
.IP \[bu] 2
\f[CR]String.prototype.matchAll()\f[R] and \f[CR]replaceAll()\f[R] check
whether the global flag is set if the first argument is a regex before
invoking its \f[CR]\[at]\[at]matchAll\f[R] or
\f[CR]\[at]\[at]replace\f[R] method.
.IP \[bu] 2
The \f[CR]RegExp()\f[R] constructor directly returns the
\f[CR]pattern\f[R] argument only if \f[CR]pattern\f[R] is a regex (among
a few other conditions).
If \f[CR]pattern\f[R] is a regex, it would also interrogate
\f[CR]pattern\f[R]\[cq]s \f[CR]source\f[R] and \f[CR]flags\f[R]
properties instead of coercing \f[CR]pattern\f[R] to a string.
.PP
For example, \f[CR]String.prototype.endsWith()\f[R] would coerce all
inputs to strings, but it would throw if the argument is a regex,
because it\[cq]s only designed to match strings, and using a regex is
likely a developer mistake.
.IP
.EX
\[dq]foobar\[dq].endsWith({ toString: () => \[dq]bar\[dq] }); // true
\[dq]foobar\[dq].endsWith(/bar/); // TypeError: First argument to String.prototype.endsWith must not be a regular expression
.EE
.PP
You can get around the check by setting \f[CR]\[at]\[at]match\f[R] to a
falsy value that\[cq]s not \f[CR]undefined\f[R].
This would mean that the regex cannot be used for
\f[CR]String.prototype.match()\f[R] (since without
\f[CR]\[at]\[at]match\f[R], \f[CR]match()\f[R] would construct a new
\f[CR]RegExp\f[R] object with the two enclosing slashes added by
\f[CR]re.toString()\f[R]), but it can be used for virtually everything
else.
.IP
.EX
const re = /bar/g;
re[Symbol.match] = false;
\[dq]/bar/g\[dq].endsWith(re); // true
re.exec(\[dq]bar\[dq]); // [ \[aq]bar\[aq], index: 0, input: \[aq]bar\[aq], groups: undefined ]
\[dq]bar & bar\[dq].replace(re, \[dq]foo\[dq]); // \[aq]foo & foo\[aq]
.EE
.SS Perl-like RegExp properties
Note that several of the \f[CR]RegExp\f[R] properties have both long and
short (Perl-like) names.
Both names always refer to the same value.
(Perl is the programming language from which JavaScript modeled its
regular expressions.)
See also deprecated \f[CR]RegExp\f[R] properties.
.SH CONSTRUCTOR
.TP
\f[B]RegExp()\f[R]
Creates a new \f[CR]RegExp\f[R] object.
.SH STATIC PROPERTIES
.TP
\f[B]RegExp.$1, \&..., RegExp.$9\f[R] \f[I](deprecated)\f[R]
Static read-only properties that contain parenthesized substring
matches.
.TP
\f[B]RegExp.input ($_)\f[R] \f[I](deprecated)\f[R]
A static property that contains the last string against which a regular
expression was successfully matched.
.TP
\f[B]RegExp.lastMatch ($&)\f[R] \f[I](deprecated)\f[R]
A static read-only property that contains the last matched substring.
.TP
\f[B]RegExp.lastParen ($+)\f[R] \f[I](deprecated)\f[R]
A static read-only property that contains the last parenthesized
substring match.
.TP
\f[B]RegExp.leftContext ($\f[R])\[ga] \f[I](deprecated)\f[R]
A static read-only property that contains the substring preceding the
most recent match.
.TP
\f[B]RegExp.rightContext ($\[aq])\f[R] \f[I](deprecated)\f[R]
A static read-only property that contains the substring following the
most recent match.
.TP
\f[B]RegExp[\[at]\[at]species]\f[R]
The constructor function that is used to create derived objects.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]RegExp.prototype\f[R] and shared
by all \f[CR]RegExp\f[R] instances.
.TP
\f[B]RegExp.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]RegExp\f[R] instances, the initial value is the
\f[CR]RegExp\f[R] constructor.
.TP
\f[B]RegExp.prototype.dotAll\f[R]
Whether \f[CR].\f[R] matches newlines or not.
.TP
\f[B]RegExp.prototype.flags\f[R]
A string that contains the flags of the \f[CR]RegExp\f[R] object.
.TP
\f[B]RegExp.prototype.global\f[R]
Whether to test the regular expression against all possible matches in a
string, or only against the first.
.TP
\f[B]RegExp.prototype.hasIndices\f[R]
Whether the regular expression result exposes the start and end indices
of captured substrings.
.TP
\f[B]RegExp.prototype.ignoreCase\f[R]
Whether to ignore case while attempting a match in a string.
.TP
\f[B]RegExp.prototype.multiline\f[R]
Whether or not to search in strings across multiple lines.
.TP
\f[B]RegExp.prototype.source\f[R]
The text of the pattern.
.TP
\f[B]RegExp.prototype.sticky\f[R]
Whether or not the search is sticky.
.TP
\f[B]RegExp.prototype.unicode\f[R]
Whether or not Unicode features are enabled.
.TP
\f[B]RegExp.prototype.unicodeSets\f[R]
Whether or not the \f[CR]v\f[R] flag, an upgrade to the \f[CR]u\f[R]
mode, is enabled.
.PP
These properties are own properties of each \f[CR]RegExp\f[R] instance.
.TP
\f[B]lastIndex\f[R]
The index at which to start the next match.
.SH INSTANCE METHODS
.TP
\f[B]RegExp.prototype.compile()\f[R] \f[I](deprecated)\f[R]
(Re-)compiles a regular expression during execution of a script.
.TP
\f[B]RegExp.prototype.exec()\f[R]
Executes a search for a match in its string parameter.
.TP
\f[B]RegExp.prototype.test()\f[R]
Tests for a match in its string parameter.
.TP
\f[B]RegExp.prototype.toString()\f[R]
Returns a string representing the specified object.
Overrides the \f[CR]Object.prototype.toString()\f[R] method.
.TP
\f[B]RegExp.prototype[\[at]\[at]match]()\f[R]
Performs match to given string and returns match result.
.TP
\f[B]RegExp.prototype[\[at]\[at]matchAll]()\f[R]
Returns all matches of the regular expression against a string.
.TP
\f[B]RegExp.prototype[\[at]\[at]replace]()\f[R]
Replaces matches in given string with new substring.
.TP
\f[B]RegExp.prototype[\[at]\[at]search]()\f[R]
Searches the match in given string and returns the index the pattern
found in the string.
.TP
\f[B]RegExp.prototype[\[at]\[at]split]()\f[R]
Splits given string into an array by separating the string into
substrings.
.SH EXAMPLES
.SS Using a regular expression to change data format
The following script uses the \f[CR]String.prototype.replace()\f[R]
method to match a name in the format \f[I]first last\f[R] and output it
in the format \f[I]last, first\f[R].
.PP
In the replacement text, the script uses \f[CR]$1\f[R] and \f[CR]$2\f[R]
to indicate the results of the corresponding matching parentheses in the
regular expression pattern.
.IP
.EX
const re = /(\[rs]w+)\[rs]s(\[rs]w+)/;
const str = \[dq]Maria Cruz\[dq];
const newstr = str.replace(re, \[dq]$2, $1\[dq]);
console.log(newstr);
.EE
.PP
This displays \f[CR]\[dq]Cruz, Maria\[dq]\f[R].
.SS Using regular expression to split lines with different line endings/ends of line/line breaks
The default line ending varies depending on the platform (Unix, Windows,
etc.).
The line splitting provided in this example works on all platforms.
.IP
.EX
const text = \[dq]Some text\[rs]nAnd some more\[rs]r\[rs]nAnd yet\[rs]rThis is the end\[dq];
const lines = text.split(/\[rs]r\[rs]n|\[rs]r|\[rs]n/);
console.log(lines); // [ \[aq]Some text\[aq], \[aq]And some more\[aq], \[aq]And yet\[aq], \[aq]This is the end\[aq] ]
.EE
.PP
Note that the order of the patterns in the regular expression matters.
.SS Using regular expression on multiple lines
.IP
.EX
const s = \[dq]Please yes\[rs]nmake my day!\[dq];

s.match(/yes.*day/);
// Returns null

s.match(/yes[\[ha]]*day/);
// Returns [\[dq]yes\[rs]nmake my day\[dq]]
.EE
.SS Using a regular expression with the sticky flag
The \f[CR]sticky\f[R] flag indicates that the regular expression
performs sticky matching in the target string by attempting to match
starting at \f[CR]RegExp.prototype.lastIndex\f[R].
.IP
.EX
const str = \[dq]#foo#\[dq];
const regex = /foo/y;

regex.lastIndex = 1;
regex.test(str); // true
regex.lastIndex = 5;
regex.test(str); // false (lastIndex is taken into account with sticky flag)
regex.lastIndex; // 0 (reset after match failure)
.EE
.SS The difference between the sticky flag and the global flag
With the sticky flag \f[CR]y\f[R], the next match has to happen at the
\f[CR]lastIndex\f[R] position, while with the global flag \f[CR]g\f[R],
the match can happen at the \f[CR]lastIndex\f[R] position or later:
.IP
.EX
const re = /\[rs]d/y;
let r;
while ((r = re.exec(\[dq]123 456\[dq]))) {
  console.log(r, \[dq]AND re.lastIndex\[dq], re.lastIndex);
}

// [ \[aq]1\[aq], index: 0, input: \[aq]123 456\[aq], groups: undefined ] AND re.lastIndex 1
// [ \[aq]2\[aq], index: 1, input: \[aq]123 456\[aq], groups: undefined ] AND re.lastIndex 2
// [ \[aq]3\[aq], index: 2, input: \[aq]123 456\[aq], groups: undefined ] AND re.lastIndex 3
//  \&... and no more match.
.EE
.PP
With the global flag \f[CR]g\f[R], all 6 digits would be matched, not
just 3.
.SS Regular expression and Unicode characters
\f[CR]\[rs]w\f[R] and \f[CR]\[rs]W\f[R] only matches ASCII based
characters; for example, \f[CR]a\f[R] to \f[CR]z\f[R], \f[CR]A\f[R] to
\f[CR]Z\f[R], \f[CR]0\f[R] to \f[CR]9\f[R], and \f[CR]_\f[R].
.PP
To match characters from other languages such as Cyrillic or Hebrew, use
\f[CR]\[rs]uhhhh\f[R], where \f[CR]hhhh\f[R] is the character\[cq]s
Unicode value in hexadecimal.
.PP
This example demonstrates how one can separate out Unicode characters
from a word.
.IP
.EX
const text = \[dq]Образец text на русском языке\[dq];
const regex = /[\[rs]u0400-\[rs]u04FF]+/g;

const match = regex.exec(text);
console.log(match[0]); // \[aq]Образец\[aq]
console.log(regex.lastIndex); // 7

const match2 = regex.exec(text);
console.log(match2[0]); // \[aq]на\[aq] (did not log \[aq]text\[aq])
console.log(regex.lastIndex); // 15

// and so on
.EE
.PP
The Unicode property escapes feature provides a simpler way to target
particular Unicode ranges, by allowing for statements like
\f[CR]\[rs]p{scx=Cyrl}\f[R] (to match any Cyrillic letter), or
\f[CR]\[rs]p{L}/u\f[R] (to match a letter from any language).
.SS Extracting subdomain name from URL
.IP
.EX
const url = \[dq]http://xxx.domain.com\[dq];
console.log(/\[ha]https?:\[rs]/\[rs]/(.+?)\[rs]./.exec(url)[1]); // \[aq]xxx\[aq]
.EE
.RS
.PP
\f[B]Note:\f[R] Instead of using regular expressions for parsing URLs,
it is usually better to use the browsers built-in URL parser by using
the URL API.
.RE
.SS Building a regular expression from dynamic inputs
.IP
.EX
const breakfasts = [\[dq]bacon\[dq], \[dq]eggs\[dq], \[dq]oatmeal\[dq], \[dq]toast\[dq], \[dq]cereal\[dq]];
const order = \[dq]Let me get some bacon and eggs, please\[dq];

order.match(new RegExp(\[ga]\[rs]\[rs]b(${breakfasts.join(\[dq]|\[dq])})\[rs]\[rs]b\[ga], \[dq]g\[dq]));
// Returns [\[aq]bacon\[aq], \[aq]eggs\[aq]]
.EE
.SS Firefox-specific notes
Starting with Firefox 34, in the case of a capturing group with
quantifiers preventing its exercise, the matched text for a capturing
group is now \f[CR]undefined\f[R] instead of an empty string:
.IP
.EX
// Firefox 33 or older
\[dq]x\[dq].replace(/x(.)?/g, (m, group) => {
  console.log(\[ga]group: ${JSON.stringify(group)}\[ga]);
});
// group: \[dq]\[dq]

// Firefox 34 or newer
\[dq]x\[dq].replace(/x(.)?/g, (m, group) => {
  console.log(\[ga]group: ${group}\[ga]);
});
// group: undefined
.EE
.PP
Note that due to web compatibility, \f[CR]RegExp.$N\f[R] will still
return an empty string instead of \f[CR]undefined\f[R] (bug
1053944 (https://bugzil.la/1053944)).
.SH SEE ALSO
.IP \[bu] 2
Polyfill of many modern \f[CR]RegExp\f[R] features (\f[CR]dotAll\f[R],
\f[CR]sticky\f[R] flags, named capture groups, etc.)
in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-string-and-regexp)
.IP \[bu] 2
Regular expressions guide
.IP \[bu] 2
Regular expressions
.IP \[bu] 2
\f[CR]String.prototype.match()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.replace()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.split()\f[R]
