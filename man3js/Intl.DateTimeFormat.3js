.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Intl.DateTimeFormat" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Intl.DateTimeFormat - Intl.DateTimeFormat
.SH SYNOPSIS
.PP
The \f[B]\f[VB]Intl.DateTimeFormat\f[B]\f[R] object enables
language-sensitive date and time formatting.
.SH CONSTRUCTOR
.TP
\f[B]Intl.DateTimeFormat()\f[R]
Creates a new \f[V]Intl.DateTimeFormat\f[R] object.
.SH STATIC METHODS
.TP
\f[B]Intl.DateTimeFormat.supportedLocalesOf()\f[R]
Returns an array containing those of the provided locales that are
supported without having to fall back to the runtime\[cq]s default
locale.
.SH INSTANCE PROPERTIES
.PP
These properties are defined on \f[V]Intl.DateTimeFormat.prototype\f[R]
and shared by all \f[V]Intl.DateTimeFormat\f[R] instances.
.TP
\f[B]Intl.DateTimeFormat.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[V]Intl.DateTimeFormat\f[R] instances, the initial value is the
\f[V]Intl.DateTimeFormat\f[R] constructor.
.TP
\f[B]Intl.DateTimeFormat.prototype[\[at]\[at]toStringTag]\f[R]
The initial value of the \f[V]\[at]\[at]toStringTag\f[R] property is the
string \f[V]\[dq]Intl.DateTimeFormat\[dq]\f[R].
This property is used in \f[V]Object.prototype.toString()\f[R].
.SH INSTANCE METHODS
.TP
\f[B]Intl.DateTimeFormat.prototype.format()\f[R]
Getter function that formats a date according to the locale and
formatting options of this \f[V]DateTimeFormat\f[R] object.
.TP
\f[B]Intl.DateTimeFormat.prototype.formatRange()\f[R]
This method receives two Dates and formats the date range in the most
concise way based on the locale and options provided when instantiating
\f[V]DateTimeFormat\f[R].
.TP
\f[B]Intl.DateTimeFormat.prototype.formatRangeToParts()\f[R]
This method receives two Dates and returns an Array of objects
containing the locale-specific tokens representing each part of the
formatted date range.
.TP
\f[B]Intl.DateTimeFormat.prototype.formatToParts()\f[R]
Returns an \f[V]Array\f[R] of objects representing the date string in
parts that can be used for custom locale-aware formatting.
.TP
\f[B]Intl.DateTimeFormat.prototype.resolvedOptions()\f[R]
Returns a new object with properties reflecting the locale and
formatting options computed during initialization of the object.
.SH EXAMPLES
.SS Using DateTimeFormat
.PP
In basic use without specifying a locale, \f[V]DateTimeFormat\f[R] uses
the default locale and default options.
.IP
.nf
\f[C]
const date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));

// toLocaleString without arguments depends on the implementation,
// the default locale, and the default time zone
console.log(new Intl.DateTimeFormat().format(date));
// \[dq]12/19/2012\[dq] if run with en-US locale (language) and time zone America/Los_Angeles (UTC-0800)
\f[R]
.fi
.SS Using locales
.PP
This example shows some of the variations in localized date and time
formats.
In order to get the format of the language used in the user interface of
your application, make sure to specify that language (and possibly some
fallback languages) using the \f[V]locales\f[R] argument:
.IP
.nf
\f[C]
const date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));

// Results below use the time zone of America/Los_Angeles (UTC-0800, Pacific Standard Time)

// US English uses month-day-year order
console.log(new Intl.DateTimeFormat(\[dq]en-US\[dq]).format(date));
// \[dq]12/19/2012\[dq]

// British English uses day-month-year order
console.log(new Intl.DateTimeFormat(\[dq]en-GB\[dq]).format(date));
// \[dq]19/12/2012\[dq]

// Korean uses year-month-day order
console.log(new Intl.DateTimeFormat(\[dq]ko-KR\[dq]).format(date));
// \[dq]2012. 12. 19.\[dq]

// Arabic in most Arabic speaking countries uses real Arabic digits
console.log(new Intl.DateTimeFormat(\[dq]ar-EG\[dq]).format(date));
// \[dq]١٩‏/١٢‏/٢٠١٢\[dq]

// for Japanese, applications may want to use the Japanese calendar,
// where 2012 was the year 24 of the Heisei era
console.log(new Intl.DateTimeFormat(\[dq]ja-JP-u-ca-japanese\[dq]).format(date));
// \[dq]24/12/19\[dq]

// when requesting a language that may not be supported, such as
// Balinese, include a fallback language, in this case Indonesian
console.log(new Intl.DateTimeFormat([\[dq]ban\[dq], \[dq]id\[dq]]).format(date));
// \[dq]19/12/2012\[dq]
\f[R]
.fi
.SS Using options
.PP
The date and time formats can be customized using the \f[V]options\f[R]
argument:
.IP
.nf
\f[C]
const date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0, 200));

// request a weekday along with a long date
let options = {
  weekday: \[dq]long\[dq],
  year: \[dq]numeric\[dq],
  month: \[dq]long\[dq],
  day: \[dq]numeric\[dq],
};
console.log(new Intl.DateTimeFormat(\[dq]de-DE\[dq], options).format(date));
// \[dq]Donnerstag, 20. Dezember 2012\[dq]

// an application may want to use UTC and make that visible
options.timeZone = \[dq]UTC\[dq];
options.timeZoneName = \[dq]short\[dq];
console.log(new Intl.DateTimeFormat(\[dq]en-US\[dq], options).format(date));
// \[dq]Thursday, December 20, 2012, GMT\[dq]

// sometimes you want to be more precise
options = {
  hour: \[dq]numeric\[dq],
  minute: \[dq]numeric\[dq],
  second: \[dq]numeric\[dq],
  timeZone: \[dq]Australia/Sydney\[dq],
  timeZoneName: \[dq]short\[dq],
};
console.log(new Intl.DateTimeFormat(\[dq]en-AU\[dq], options).format(date));
// \[dq]2:00:00 pm AEDT\[dq]

// sometimes you want to be very precise
options.fractionalSecondDigits = 3; //number digits for fraction-of-seconds
console.log(new Intl.DateTimeFormat(\[dq]en-AU\[dq], options).format(date));
// \[dq]2:00:00.200 pm AEDT\[dq]

// sometimes even the US needs 24-hour time
options = {
  year: \[dq]numeric\[dq],
  month: \[dq]numeric\[dq],
  day: \[dq]numeric\[dq],
  hour: \[dq]numeric\[dq],
  minute: \[dq]numeric\[dq],
  second: \[dq]numeric\[dq],
  hour12: false,
  timeZone: \[dq]America/Los_Angeles\[dq],
};
console.log(new Intl.DateTimeFormat(\[dq]en-US\[dq], options).format(date));
// \[dq]12/19/2012, 19:00:00\[dq]

// to specify options but use the browser\[aq]s default locale, use undefined
console.log(new Intl.DateTimeFormat(undefined, options).format(date));
// \[dq]12/19/2012, 19:00:00\[dq]

// sometimes it\[aq]s helpful to include the period of the day
options = { hour: \[dq]numeric\[dq], dayPeriod: \[dq]short\[dq] };
console.log(new Intl.DateTimeFormat(\[dq]en-US\[dq], options).format(date));
// 10 at night
\f[R]
.fi
.PP
The used calendar and numbering formats can also be set independently
via \f[V]options\f[R] arguments:
.IP
.nf
\f[C]
const options = { calendar: \[dq]chinese\[dq], numberingSystem: \[dq]arab\[dq] };
const dateFormat = new Intl.DateTimeFormat(undefined, options);
const usedOptions = dateFormat.resolvedOptions();

console.log(usedOptions.calendar);
// \[dq]chinese\[dq]

console.log(usedOptions.numberingSystem);
// \[dq]arab\[dq]

console.log(usedOptions.timeZone);
// \[dq]America/New_York\[dq] (the users default timezone)
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
\f[V]Intl\f[R]
.IP \[bu] 2
A polyfill of \f[V]Intl.DateTimeFormat\f[R] in
FormatJS (https://formatjs.io/docs/polyfills/intl-datetimeformat/)
