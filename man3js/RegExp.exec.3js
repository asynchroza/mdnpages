'\" t
.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "RegExp.exec" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]exec()\f[B]\f[R] method executes a search for a match in
a specified string and returns a result array, or \f[V]null\f[R].
.SH Syntax
.IP
.nf
\f[C]
exec(str)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]str\f[R]
.RS 2
.IP \[bu] 2
The string against which to match the regular expression.
All values are coerced to strings, so omitting it or passing
\f[V]undefined\f[R] causes \f[V]exec()\f[R] to search for the string
\f[V]\[dq]undefined\[dq]\f[R], which is rarely what you want.
.RE
.SS Return value
.PP
If the match fails, the \f[V]exec()\f[R] method returns \f[V]null\f[R],
and sets the regex\[cq]s \f[V]lastIndex\f[R] to \f[V]0\f[R].
.PP
If the match succeeds, the \f[V]exec()\f[R] method returns an array and
updates the \f[V]lastIndex\f[R] property of the regular expression
object.
The returned array has the matched text as the first item, and then one
item for each capturing group of the matched text.
The array also has the following additional properties:
.IP \[bu] 2
\f[V]index\f[R]
.RS 2
.IP \[bu] 2
The 0-based index of the match in the string.
.RE
.IP \[bu] 2
\f[V]input\f[R]
.RS 2
.IP \[bu] 2
The original string that was matched against.
.RE
.IP \[bu] 2
\f[V]groups\f[R]
.RS 2
.IP \[bu] 2
A \f[V]null\f[R]-prototype object of named capturing groups, whose keys
are the names, and values are the capturing groups, or
\f[V]undefined\f[R] if no named capturing groups were defined.
See capturing groups for more information.
.RE
.IP \[bu] 2
\f[V]indices\f[R] \f[I](optional)\f[R]
.RS 2
.IP \[bu] 2
This property is only present when the \f[V]d\f[R] flag is set.
It is an array where each entry represents the bounds of a substring
match.
The index of each element in this array corresponds to the index of the
respective substring match in the array returned by \f[V]exec()\f[R].
In other words, the first \f[V]indices\f[R] entry represents the entire
match, the second \f[V]indices\f[R] entry represents the first capturing
group, etc.
Each entry itself is a two-element array, where the first number
represents the match\[cq]s start index, and the second number, its end
index.
.RS 2
.PP
The \f[V]indices\f[R] array additionally has a \f[V]groups\f[R]
property, which holds a \f[V]null\f[R]-prototype object of all named
capturing groups.
The keys are the names of the capturing groups, and each value is a
two-element array, with the first number being the start index, and the
second number being the end index of the capturing group.
If the regular expression doesn\[cq]t contain any named capturing
groups, \f[V]groups\f[R] is \f[V]undefined\f[R].
.RE
.RE
.SH Description
.PP
JavaScript \f[V]RegExp\f[R] objects are \f[I]stateful\f[R] when they
have the global or sticky flags set (e.g.\ \f[V]/foo/g\f[R] or
\f[V]/foo/y\f[R]).
They store a \f[V]lastIndex\f[R] from the previous match.
Using this internally, \f[V]exec()\f[R] can be used to iterate over
multiple matches in a string of text (with capture groups), as opposed
to getting just the matching strings with
\f[V]String.prototype.match()\f[R].
.PP
When using \f[V]exec()\f[R], the global flag has no effect when the
sticky flag is set \[em] the match is always sticky.
.PP
\f[V]exec()\f[R] is the primitive method of regexps.
Many other regexp methods call \f[V]exec()\f[R] internally \[em]
including those called by string methods, like
\f[V]\[at]\[at]replace\f[R].
While \f[V]exec()\f[R] itself is powerful (and is the most efficient),
it often does not convey the intent most clearly.
.IP \[bu] 2
If you only care whether the regex matches a string, but not what is
actually being matched, use \f[V]RegExp.prototype.test()\f[R] instead.
.IP \[bu] 2
If you are finding all occurrences of a global regex and you don\[cq]t
care about information like capturing groups, use
\f[V]String.prototype.match()\f[R] instead.
In addition, \f[V]String.prototype.matchAll()\f[R] helps to simplify
matching multiple parts of a string (with capture groups) by allowing
you to iterate over the matches.
.IP \[bu] 2
If you are executing a match to find its index position in the string,
use the \f[V]String.prototype.search()\f[R] method instead.
.SH Examples
.SS Using exec()
.PP
Consider the following example:
.IP
.nf
\f[C]
// Match \[dq]quick brown\[dq] followed by \[dq]jumps\[dq], ignoring characters in between
// Remember \[dq]brown\[dq] and \[dq]jumps\[dq]
// Ignore case
const re = /quick\[rs]s(?<color>brown).+?(jumps)/dgi;
const result = re.exec(\[dq]The Quick Brown Fox Jumps Over The Lazy Dog\[dq]);
\f[R]
.fi
.PP
The following table shows the state of \f[V]result\f[R] after running
this script:
.PP
.TS
tab(@);
lw(8.4n) lw(61.6n).
T{
Property
T}@T{
Value
T}
_
T{
\f[V][0]\f[R]
T}@T{
\f[V]\[dq]Quick Brown Fox Jumps\[dq]\f[R]
T}
T{
\f[V][1]\f[R]
T}@T{
\f[V]\[dq]Brown\[dq]\f[R]
T}
T{
\f[V][2]\f[R]
T}@T{
\f[V]\[dq]Jumps\[dq]\f[R]
T}
T{
\f[V]index\f[R]
T}@T{
\f[V]4\f[R]
T}
T{
\f[V]indices\f[R]
T}@T{
\f[V][[4, 25], [10, 15], [20, 25]]\f[R]\f[V]groups: { color: [10, 15 ]}\f[R]
T}
T{
\f[V]input\f[R]
T}@T{
\f[V]\[dq]The Quick Brown Fox Jumps Over The Lazy Dog\[dq]\f[R]
T}
T{
\f[V]groups\f[R]
T}@T{
\f[V]{ color: \[dq]brown\[dq] }\f[R]
T}
.TE
.PP
In addition, \f[V]re.lastIndex\f[R] will be set to \f[V]25\f[R], due to
this regex being global.
.SS Finding successive matches
.PP
If your regular expression uses the \f[V]g\f[R] flag, you can use the
\f[V]exec()\f[R] method multiple times to find successive matches in the
same string.
When you do so, the search starts at the substring of \f[V]str\f[R]
specified by the regular expression\[cq]s \f[V]lastIndex\f[R] property
(\f[V]test()\f[R] will also advance the \f[V]lastIndex\f[R] property).
Note that the \f[V]lastIndex\f[R] property will not be reset when
searching a different string, it will start its search at its existing
\f[V]lastIndex\f[R].
.PP
For example, assume you have this script:
.IP
.nf
\f[C]
const myRe = /ab*/g;
const str = \[dq]abbcdefabh\[dq];
let myArray;
while ((myArray = myRe.exec(str)) !== null) {
  let msg = \[ga]Found ${myArray[0]}. \[ga];
  msg += \[ga]Next match starts at ${myRe.lastIndex}\[ga];
  console.log(msg);
}
\f[R]
.fi
.PP
This script displays the following text:
.IP
.nf
\f[C]
Found abb. Next match starts at 3
Found ab. Next match starts at 9
\f[R]
.fi
.RS
.PP
\f[B]Warning:\f[R] There are many pitfalls that can lead to this
becoming an infinite loop!
.IP \[bu] 2
Do \f[I]not\f[R] place the regular expression literal (or
\f[V]RegExp\f[R] constructor) within the \f[V]while\f[R] condition \[em]
it will recreate the regex for every iteration and reset
\f[V]lastIndex\f[R].
.IP \[bu] 2
Be sure that the global (\f[V]g\f[R]) flag is set, or
\f[V]lastIndex\f[R] will never be advanced.
.IP \[bu] 2
If the regex may match zero-length characters
(e.g.\ \f[V]/\[ha]/gm\f[R]), increase its \f[V]lastIndex\f[R] manually
each time to avoid being stuck in the same place.
.RE
.PP
You can usually replace this kind of code with
\f[V]String.prototype.matchAll()\f[R] to make it less error-prone.
.SS Using exec() with RegExp literals
.PP
You can also use \f[V]exec()\f[R] without creating a \f[V]RegExp\f[R]
object explicitly:
.IP
.nf
\f[C]
const matches = /(hello \[rs]S+)/.exec(\[dq]This is a hello world!\[dq]);
console.log(matches[1]);
\f[R]
.fi
.PP
This will log a message containing \f[V]\[aq]hello world!\[aq]\f[R].
.SH See also
.IP \[bu] 2
Regular Expressions chapter in the JavaScript Guide
.IP \[bu] 2
\f[V]RegExp\f[R]
