.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "String.fromCharCode" "JS" "February 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.fromCharCode - String.fromCharCode()
.SH SYNOPSIS
The \f[B]\f[CB]String.fromCharCode()\f[B]\f[R] static method returns a
string created from the specified sequence of UTF-16 code units.
.SH SYNTAX
.IP
.EX
String.fromCharCode(num1)
String.fromCharCode(num1, num2)
String.fromCharCode(num1, num2, /* \&..., */ numN)
.EE
.SS Parameters
.TP
\f[B]num1, ..., numN\f[R]
A sequence of numbers that are UTF-16 code units.
The range is between \f[CR]0\f[R] and \f[CR]65535\f[R]
(\f[CR]0xFFFF\f[R]).
Numbers greater than \f[CR]0xFFFF\f[R] are truncated.
No validity checks are performed.
.SS Return value
A string of length \f[CR]N\f[R] consisting of the \f[CR]N\f[R] specified
UTF-16 code units.
.SH DESCRIPTION
This method returns a string and not a \f[CR]String\f[R] object.
.PP
Because \f[CR]fromCharCode()\f[R] is a static method of
\f[CR]String\f[R], you always use it as
\f[CR]String.fromCharCode()\f[R], rather than as a method of a
\f[CR]String\f[R] object you created.
.SS Returning supplementary characters
In UTF-16, the most common characters can be represented by a single
16-bit value (i.e.
a code unit).
However, this set of characters, known as the Base Multilingual Plane
(BMP), is only 1/17th of the total addressable Unicode code points.
The remaining code points, in the range of \f[CR]65536\f[R]
(\f[CR]0x010000\f[R]) to \f[CR]1114111\f[R] (\f[CR]0x10FFFF\f[R]) are
known as supplementary characters.
In UTF-16, supplementary characters are represented by two 16-bit code
units, known as surrogates, that were reserved for this purpose.
A valid combination of two surrogates used to represent a supplementary
character is known as a surrogate pair.
.PP
Because \f[CR]fromCharCode()\f[R] only works with 16-bit values (same as
the \f[CR]\[rs]u\f[R] escape sequence), a surrogate pair is required in
order to return a supplementary character.
For example, both \f[CR]String.fromCharCode(0xD83C, 0xDF03)\f[R] and
\f[CR]\[rs]uD83C\[rs]uDF03\f[R] return code point \f[CR]U+1F303\f[R]
\[lq]Night with Stars\[rq].
.PP
While there is a mathematical relationship between the supplementary
code point value (e.g.\ \f[CR]0x1F303\f[R]) and both surrogate values
that represent it (e.g., \f[CR]0xD83C\f[R] and \f[CR]0xDF03\f[R]), it
does require an extra step to either calculate or look up the surrogate
pair values every time a supplementary code point is to be used.
For this reason, it\[cq]s more convenient to use
\f[CR]String.fromCodePoint()\f[R], which allows for returning
supplementary characters based on their actual code point value.
For example, \f[CR]String.fromCodePoint(0x1F303)\f[R] returns code point
\f[CR]U+1F303\f[R] \[lq]Night with Stars\[rq].
.SH EXAMPLES
.SS Using fromCharCode()
BMP characters, in UTF-16, use a single code unit:
.IP
.EX
String.fromCharCode(65, 66, 67); // returns \[dq]ABC\[dq]
String.fromCharCode(0x2014); // returns \[dq]\[em]\[dq]
String.fromCharCode(0x12014); // also returns \[dq]\[em]\[dq]; the digit 1 is truncated and ignored
String.fromCharCode(8212); // also returns \[dq]\[em]\[dq]; 8212 is the decimal form of 0x2014
.EE
.PP
Supplementary characters, in UTF-16, require two code units (i.e.\ a
surrogate pair):
.IP
.EX
String.fromCharCode(0xd83c, 0xdf03); // Code Point U+1F303 \[dq]Night with
String.fromCharCode(55356, 57091); // Stars\[dq] === \[dq]\[rs]uD83C\[rs]uDF03\[dq]

String.fromCharCode(0xd834, 0xdf06, 0x61, 0xd834, 0xdf07); // \[dq]\[rs]uD834\[rs]uDF06a\[rs]uD834\[rs]uDF07\[dq]
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]String.fromCodePoint()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.charAt()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.charCodeAt()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.codePointAt()\f[R]
