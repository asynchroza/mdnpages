.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "ArrayBuffer.transfer" "JS" "December 24, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
ArrayBuffer.transfer - ArrayBuffer.prototype.transfer()
.SH SYNOPSIS
The \f[B]\f[CB]transfer()\f[B]\f[R] method of \f[CR]ArrayBuffer\f[R]
instances creates a new \f[CR]ArrayBuffer\f[R] with the same byte
content as this buffer, then detaches this buffer.
.SH SYNTAX
.IP
.EX
transfer()
transfer(newByteLength)
.EE
.SS Parameters
.TP
\f[B]newByteLength\f[R] \f[I](optional)\f[R]
The \f[CR]byteLength\f[R] of the new \f[CR]ArrayBuffer\f[R].
Defaults to the \f[CR]byteLength\f[R] of this \f[CR]ArrayBuffer\f[R].
.RS
.IP \[bu] 2
If \f[CR]newByteLength\f[R] is smaller than the \f[CR]byteLength\f[R] of
this \f[CR]ArrayBuffer\f[R], the \[lq]overflowing\[rq] bytes are
dropped.
.IP \[bu] 2
If \f[CR]newByteLength\f[R] is larger than the \f[CR]byteLength\f[R] of
this \f[CR]ArrayBuffer\f[R], the extra bytes are filled with zeros.
.IP \[bu] 2
If this \f[CR]ArrayBuffer\f[R] is resizable, \f[CR]newByteLength\f[R]
must not be greater than its \f[CR]maxByteLength\f[R].
.RE
.SS Return value
A new \f[CR]ArrayBuffer\f[R] object.
Its contents are initialized to the contents of this
\f[CR]ArrayBuffer\f[R], and extra bytes, if any, are filled with zeros.
The new \f[CR]ArrayBuffer\f[R] is resizable if and only if this
\f[CR]ArrayBuffer\f[R] is resizable, in which case its
\f[CR]maxByteLength\f[R] is the same as this
\f[CR]ArrayBuffer\f[R]\[cq]s.
The original \f[CR]ArrayBuffer\f[R] is detached.
.SS Exceptions
.TP
\f[B]RangeError\f[R]
Thrown if this \f[CR]ArrayBuffer\f[R] is resizable and
\f[CR]newByteLength\f[R] is greater than the \f[CR]maxByteLength\f[R] of
this \f[CR]ArrayBuffer\f[R].
.TP
\f[B]TypeError\f[R]
Thrown if this \f[CR]ArrayBuffer\f[R] is already detached.
.SH DESCRIPTION
The \f[CR]transfer()\f[R] method performs the same operation as the
structured clone algorithm.
It copies the bytes of this \f[CR]ArrayBuffer\f[R] into a new
\f[CR]ArrayBuffer\f[R] object, then detaches this \f[CR]ArrayBuffer\f[R]
object.
See transferring ArrayBuffers for more information.
.PP
\f[CR]transfer()\f[R] preserves the resizability of this
\f[CR]ArrayBuffer\f[R].
If you want the new \f[CR]ArrayBuffer\f[R] to be non-resizable, use
\f[CR]transferToFixedLength()\f[R] instead.
There\[cq]s no way to transfer a buffer that makes a fixed-length buffer
become resizable.
.PP
\f[CR]transfer()\f[R] is very efficient because implementations may
implement this method as a zero-copy move or a \f[CR]realloc\f[R] \[em]
there does not need to be an actual copy of the data.
.SH EXAMPLES
.SS Transferring an ArrayBuffer
.IP
.EX
// Create an ArrayBuffer and write a few bytes
const buffer = new ArrayBuffer(8);
const view = new Uint8Array(buffer);
view[1] = 2;
view[7] = 4;

// Copy the buffer to the same size
const buffer2 = buffer.transfer();
console.log(buffer.detached); // true
console.log(buffer2.byteLength); // 8
const view2 = new Uint8Array(buffer2);
console.log(view2[1]); // 2
console.log(view2[7]); // 4

// Copy the buffer to a smaller size
const buffer3 = buffer2.transfer(4);
console.log(buffer3.byteLength); // 4
const view3 = new Uint8Array(buffer3);
console.log(view3[1]); // 2
console.log(view3[7]); // undefined

// Copy the buffer to a larger size
const buffer4 = buffer3.transfer(8);
console.log(buffer4.byteLength); // 8
const view4 = new Uint8Array(buffer4);
console.log(view4[1]); // 2
console.log(view4[7]); // 0

// Already detached, throws TypeError
buffer.transfer(); // TypeError: Cannot perform ArrayBuffer.prototype.transfer on a detached ArrayBuffer
.EE
.SS Transferring a resizable ArrayBuffer
.IP
.EX
const buffer = new ArrayBuffer(8, { maxByteLength: 16 });
const view = new Uint8Array(buffer);
view[1] = 2;
view[7] = 4;

// Copy the buffer to a smaller size
const buffer2 = buffer.transfer(4);
console.log(buffer2.byteLength); // 4
console.log(buffer2.maxByteLength); // 16
const view2 = new Uint8Array(buffer2);
console.log(view2[1]); // 2
console.log(view2[7]); // undefined
buffer2.resize(8);
console.log(view2[7]); // 0

// Copy the buffer to a larger size within maxByteLength
const buffer3 = buffer2.transfer(12);
console.log(buffer3.byteLength); // 12

// Copy the buffer to a larger size than maxByteLength
buffer3.transfer(20); // RangeError: Invalid array buffer length
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]ArrayBuffer\f[R]
.IP \[bu] 2
\f[CR]ArrayBuffer.prototype.detached\f[R]
.IP \[bu] 2
\f[CR]ArrayBuffer.prototype.transferToFixedLength()\f[R]
