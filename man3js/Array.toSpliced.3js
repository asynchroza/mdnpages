.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.toSpliced" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Array.toSpliced - Array.prototype.toSpliced()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]toSpliced()\f[B]\f[R] method of \f[V]Array\f[R] instances
is the copying version of the \f[V]splice()\f[R] method.
It returns a new array with some elements removed and/or replaced at a
given index.
.SH SYNTAX
.IP
.nf
\f[C]
toSpliced(start)
toSpliced(start, deleteCount)
toSpliced(start, deleteCount, item1)
toSpliced(start, deleteCount, item1, item2, itemN)
\f[R]
.fi
.SS Parameters
.TP
\f[B]start\f[R]
Zero-based index at which to start changing the array, converted to an
integer.
.RS
.IP \[bu] 2
Negative index counts back from the end of the array \[em] if
\f[V]start < 0\f[R], \f[V]start + array.length\f[R] is used.
.IP \[bu] 2
If \f[V]start < -array.length\f[R] or \f[V]start\f[R] is omitted,
\f[V]0\f[R] is used.
.IP \[bu] 2
If \f[V]start >= array.length\f[R], no element will be deleted, but the
method will behave as an adding function, adding as many elements as
provided.
.RE
.TP
\f[B]deleteCount\f[R] \f[I](optional)\f[R]
An integer indicating the number of elements in the array to remove from
\f[V]start\f[R].
.RS
.PP
If \f[V]deleteCount\f[R] is omitted, or if its value is greater than or
equal to the number of elements after the position specified by
\f[V]start\f[R], then all the elements from \f[V]start\f[R] to the end
of the array will be deleted.
However, if you wish to pass any \f[V]itemN\f[R] parameter, you should
pass \f[V]Infinity\f[R] as \f[V]deleteCount\f[R] to delete all elements
after \f[V]start\f[R], because an explicit \f[V]undefined\f[R] gets
converted to \f[V]0\f[R].
.PP
If \f[V]deleteCount\f[R] is \f[V]0\f[R] or negative, no elements are
removed.
In this case, you should specify at least one new element (see below).
.RE
.TP
\f[B]item1\f[R], \&..., \f[B]itemN\f[R] \f[I](optional)\f[R]
The elements to add to the array, beginning from \f[V]start\f[R].
.RS
.PP
If you do not specify any elements, \f[V]toSpliced()\f[R] will only
remove elements from the array.
.RE
.SS Return value
.PP
A new array that consists of all elements before \f[V]start\f[R],
\f[V]item1\f[R], \f[V]item2\f[R], \&..., \f[V]itemN\f[R], and all
elements after \f[V]start + deleteCount\f[R].
.SH DESCRIPTION
.PP
The \f[V]toSpliced()\f[R] method, like \f[V]splice()\f[R], does multiple
things at once: it removes the given number of elements from the array,
starting at a given index, and then inserts the given elements at the
same index.
However, it returns a new array instead of modifying the original array.
The deleted elements therefore are not returned from this method.
.PP
The \f[V]toSpliced()\f[R] method never produces a sparse array.
If the source array is sparse, the empty slots will be replaced with
\f[V]undefined\f[R] in the new array.
.PP
The \f[V]toSpliced()\f[R] method is generic.
It only expects the \f[V]this\f[R] value to have a \f[V]length\f[R]
property and integer-keyed properties.
.SH EXAMPLES
.SS Deleting, adding, and replacing elements
.PP
You can use \f[V]toSpliced()\f[R] to delete, add, and replace elements
in an array and create a new array more efficiently than using
\f[V]slice()\f[R] and \f[V]concat()\f[R].
.IP
.nf
\f[C]
const months = [\[dq]Jan\[dq], \[dq]Mar\[dq], \[dq]Apr\[dq], \[dq]May\[dq]];

// Inserting an element at index 1
const months2 = months.toSpliced(1, 0, \[dq]Feb\[dq]);
console.log(months2); // [\[dq]Jan\[dq], \[dq]Feb\[dq], \[dq]Mar\[dq], \[dq]Apr\[dq], \[dq]May\[dq]]

// Deleting two elements starting from index 2
const months3 = months2.toSpliced(2, 2);
console.log(months3); // [\[dq]Jan\[dq], \[dq]Feb\[dq], \[dq]May\[dq]]

// Replacing one element at index 1 with two new elements
const months4 = months3.toSpliced(1, 1, \[dq]Feb\[dq], \[dq]Mar\[dq]);
console.log(months4); // [\[dq]Jan\[dq], \[dq]Feb\[dq], \[dq]Mar\[dq], \[dq]May\[dq]]

// Original array is not modified
console.log(months); // [\[dq]Jan\[dq], \[dq]Mar\[dq], \[dq]Apr\[dq], \[dq]May\[dq]]
\f[R]
.fi
.SS Using toSpliced() on sparse arrays
.PP
The \f[V]toSpliced()\f[R] method always creates a dense array.
.IP
.nf
\f[C]
const arr = [1, , 3, 4, , 6];
console.log(arr.toSpliced(1, 2)); // [1, 4, undefined, 6]
\f[R]
.fi
.SS Calling toSpliced() on non-array objects
.PP
The \f[V]toSpliced()\f[R] method reads the \f[V]length\f[R] property of
\f[V]this\f[R].
It then reads the integer-keyed properties needed and writes them into
the new array.
.IP
.nf
\f[C]
const arrayLike = {
  length: 3,
  unrelated: \[dq]foo\[dq],
  0: 5,
  2: 4,
};
console.log(Array.prototype.toSpliced.call(arrayLike, 0, 1, 2, 3));
// [2, 3, undefined, 4]
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]Array.prototype.toSpliced\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#change-array-by-copy)
.IP \[bu] 2
\f[V]Array.prototype.splice()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.toReversed()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.toSorted()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.with()\f[R]
