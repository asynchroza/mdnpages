.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "BigInt.asIntN" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]BigInt.asIntN()\f[B]\f[R] static method truncates a
\f[V]BigInt\f[R] value to the given number of least significant bits and
returns that value as a signed integer.
.SH Syntax
.IP
.nf
\f[C]
BigInt.asIntN(bits, bigint)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]bits\f[R]
.RS 2
.IP \[bu] 2
The amount of bits available for the returned BigInt.
Should be an integer between 0 and 253 - 1, inclusive.
.RE
.IP \[bu] 2
\f[V]bigint\f[R]
.RS 2
.IP \[bu] 2
The BigInt value to truncate to fit into the supplied bits.
.RE
.SS Return value
.PP
The value of \f[V]bigint\f[R] modulo 2\[ha]\f[V]bits\f[R], as a signed
integer.
.SS Exceptions
.IP \[bu] 2
\f[V]RangeError\f[R]
.RS 2
.IP \[bu] 2
Thrown if \f[V]bits\f[R] is negative or greater than 253 - 1.
.RE
.SH Description
.PP
The \f[V]BigInt.asIntN\f[R] method truncates a \f[V]BigInt\f[R] value to
the given number of bits, and interprets the result as a signed integer.
For example, for \f[V]BigInt.asIntN(3, 25n)\f[R], the value
\f[V]25n\f[R] is truncated to \f[V]1n\f[R]:
.IP
.nf
\f[C]
25n = 00011001 (base 2)
          \[ha]=== Use only the three remaining bits
===>       001 (base 2) = 1n
\f[R]
.fi
.PP
If the leading bit of the remaining number is \f[V]1\f[R], the result is
negative.
For example, \f[V]BigInt.asIntN(4, 25n)\f[R] yields \f[V]-7n\f[R],
because \f[V]1001\f[R] is the encoding of \f[V]-7\f[R] under two\[cq]s
complement:
.IP
.nf
\f[C]
25n = 00011001 (base 2)
         \[ha]==== Use only the four remaining bits
===>      1001 (base 2) = -7n
\f[R]
.fi
.RS
.PP
\f[B]Note:\f[R] \f[V]BigInt\f[R] values are always encoded as two\[cq]s
complement in binary.
.RE
.PP
Unlike similar language APIs such as
\f[V]Number.prototype.toExponential()\f[R], \f[V]asIntN\f[R] is a static
property of \f[V]BigInt\f[R], so you always use it as
\f[V]BigInt.asIntN()\f[R], rather than as a method of a BigInt value.
Exposing \f[V]asIntN()\f[R] as a \[lq]standard library function\[rq]
allows interop with
asm.js (https://github.com/tc39/proposal-bigint/blob/master/ADVANCED.md#dont-break-asmjs).
.SH Examples
.SS Staying in 64-bit ranges
.PP
The \f[V]BigInt.asIntN()\f[R] method can be useful to stay in the range
of 64-bit arithmetic.
.IP
.nf
\f[C]
const max = 2n ** (64n - 1n) - 1n;

BigInt.asIntN(64, max); // 9223372036854775807n

BigInt.asIntN(64, max + 1n); // -9223372036854775808n
// negative because the 64th bit of 2\[ha]63 is 1
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]BigInt\f[R]
.IP \[bu] 2
\f[V]BigInt.asUintN()\f[R]
