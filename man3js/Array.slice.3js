.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.slice" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Array.slice - Array.prototype.slice()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]slice()\f[B]\f[R] method returns a shallow copy of a
portion of an array into a new array object selected from
\f[V]start\f[R] to \f[V]end\f[R] (\f[V]end\f[R] not included) where
\f[V]start\f[R] and \f[V]end\f[R] represent the index of items in that
array.
The original array will not be modified.
.SH SYNTAX
.IP
.nf
\f[C]
slice()
slice(start)
slice(start, end)
\f[R]
.fi
.SS Parameters
.TP
\f[B]start\f[R] \f[I](optional)\f[R]
Zero-based index at which to start extraction, converted to an integer.
.RS
.IP \[bu] 2
Negative index counts back from the end of the array \[em] if
\f[V]start < 0\f[R], \f[V]start + array.length\f[R] is used.
.IP \[bu] 2
If \f[V]start < -array.length\f[R] or \f[V]start\f[R] is omitted,
\f[V]0\f[R] is used.
.IP \[bu] 2
If \f[V]start >= array.length\f[R], nothing is extracted.
.RE
.TP
\f[B]end\f[R] \f[I](optional)\f[R]
Zero-based index at which to end extraction, converted to an integer.
\f[V]slice()\f[R] extracts up to but not including \f[V]end\f[R].
.RS
.IP \[bu] 2
Negative index counts back from the end of the array \[em] if
\f[V]end < 0\f[R], \f[V]end + array.length\f[R] is used.
.IP \[bu] 2
If \f[V]end < -array.length\f[R], \f[V]0\f[R] is used.
.IP \[bu] 2
If \f[V]end >= array.length\f[R] or \f[V]end\f[R] is omitted,
\f[V]array.length\f[R] is used, causing all elements until the end to be
extracted.
.IP \[bu] 2
If \f[V]end\f[R] is positioned before or at \f[V]start\f[R] after
normalization, nothing is extracted.
.RE
.SS Return value
.PP
A new array containing the extracted elements.
.SH DESCRIPTION
.PP
The \f[V]slice()\f[R] method is a copying method.
It does not alter \f[V]this\f[R] but instead returns a shallow copy that
contains some of the same elements as the ones from the original array.
.PP
The \f[V]slice()\f[R] method preserves empty slots.
If the sliced portion is sparse, the returned array is sparse as well.
.PP
The \f[V]slice()\f[R] method is generic.
It only expects the \f[V]this\f[R] value to have a \f[V]length\f[R]
property and integer-keyed properties.
.SH EXAMPLES
.SS Return a portion of an existing array
.IP
.nf
\f[C]
const fruits = [\[dq]Banana\[dq], \[dq]Orange\[dq], \[dq]Lemon\[dq], \[dq]Apple\[dq], \[dq]Mango\[dq]];
const citrus = fruits.slice(1, 3);

// fruits contains [\[aq]Banana\[aq], \[aq]Orange\[aq], \[aq]Lemon\[aq], \[aq]Apple\[aq], \[aq]Mango\[aq]]
// citrus contains [\[aq]Orange\[aq],\[aq]Lemon\[aq]]
\f[R]
.fi
.SS Using slice
.PP
In the following example, \f[V]slice\f[R] creates a new array,
\f[V]newCar\f[R], from \f[V]myCar\f[R].
Both include a reference to the object \f[V]myHonda\f[R].
When the color of \f[V]myHonda\f[R] is changed to purple, both arrays
reflect the change.
.IP
.nf
\f[C]
// Using slice, create newCar from myCar.
const myHonda = {
  color: \[dq]red\[dq],
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};
const myCar = [myHonda, 2, \[dq]cherry condition\[dq], \[dq]purchased 1997\[dq]];
const newCar = myCar.slice(0, 2);

console.log(\[dq]myCar =\[dq], myCar);
console.log(\[dq]newCar =\[dq], newCar);
console.log(\[dq]myCar[0].color =\[dq], myCar[0].color);
console.log(\[dq]newCar[0].color =\[dq], newCar[0].color);

// Change the color of myHonda.
myHonda.color = \[dq]purple\[dq];
console.log(\[dq]The new color of my Honda is\[dq], myHonda.color);

console.log(\[dq]myCar[0].color =\[dq], myCar[0].color);
console.log(\[dq]newCar[0].color =\[dq], newCar[0].color);
\f[R]
.fi
.PP
This script writes:
.IP
.nf
\f[C]
myCar = [
  { color: \[aq]red\[aq], wheels: 4, engine: { cylinders: 4, size: 2.2 } },
  2,
  \[aq]cherry condition\[aq],
  \[aq]purchased 1997\[aq]
]
newCar = [ { color: \[aq]red\[aq], wheels: 4, engine: { cylinders: 4, size: 2.2 } }, 2 ]
myCar[0].color = red
newCar[0].color = red
The new color of my Honda is purple
myCar[0].color = purple
newCar[0].color = purple
\f[R]
.fi
.SS Calling slice() on non-array objects
.PP
The \f[V]slice()\f[R] method reads the \f[V]length\f[R] property of
\f[V]this\f[R].
It then reads the integer-keyed properties from \f[V]start\f[R] to
\f[V]end\f[R] and defines them on a newly created array.
.IP
.nf
\f[C]
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.slice.call(arrayLike, 1, 3));
// [ 3, 4 ]
\f[R]
.fi
.SS Using slice() to convert array-like objects to arrays
.PP
The \f[V]slice()\f[R] method is often used with \f[V]bind()\f[R] and
\f[V]call()\f[R] to create a utility method that converts an array-like
object into an array.
.IP
.nf
\f[C]
// slice() is called with \[ga]this\[ga] passed as the first argument
const slice = Function.prototype.call.bind(Array.prototype.slice);

function list() {
  return slice(arguments);
}

const list1 = list(1, 2, 3); // [1, 2, 3]
\f[R]
.fi
.SS Using slice() on sparse arrays
.PP
The array returned from \f[V]slice()\f[R] may be sparse if the source is
sparse.
.IP
.nf
\f[C]
console.log([1, 2, , 4, 5].slice(1, 4)); // [2, empty, 4]
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]Array.prototype.slice\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-array)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[V]Array\f[R]
.IP \[bu] 2
\f[V]Array.prototype.pop()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.shift()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.concat()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.splice()\f[R]
.IP \[bu] 2
\f[V]TypedArray.prototype.slice()\f[R]
.IP \[bu] 2
\f[V]String.prototype.slice()\f[R]
