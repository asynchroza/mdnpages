.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "RegExp.RegExp" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
RegExp.RegExp - RegExp() constructor
.SH SYNOPSIS
.PP
The \f[B]\f[VB]RegExp()\f[B]\f[R] constructor creates \f[V]RegExp\f[R]
objects.
.PP
For an introduction to regular expressions, read the Regular Expressions
chapter in the JavaScript Guide.
.SH SYNTAX
.IP
.nf
\f[C]
new RegExp(pattern)
new RegExp(pattern, flags)
RegExp(pattern)
RegExp(pattern, flags)
\f[R]
.fi
.RS
.PP
\f[B]Note:\f[R] \f[V]RegExp()\f[R] can be called with or without
\f[V]new\f[R], but sometimes with different effects.
See Return value.
.RE
.SS Parameters
.TP
\f[B]pattern\f[R]
The text of the regular expression.
This can also be another \f[V]RegExp\f[R] object.
.TP
\f[B]flags\f[R] \f[I](optional)\f[R]
If specified, \f[V]flags\f[R] is a string that contains the flags to
add.
Alternatively, if a \f[V]RegExp\f[R] object is supplied for the
\f[V]pattern\f[R], the \f[V]flags\f[R] string will replace any of that
object\[cq]s flags (and \f[V]lastIndex\f[R] will be reset to
\f[V]0\f[R]).
.RS
.PP
\f[V]flags\f[R] may contain any combination of the following characters:
.TP
\f[B]d\f[R] (indices)
Generate indices for substring matches.
.TP
\f[B]g\f[R] (global)
Find all matches rather than stopping after the first match.
.TP
\f[B]i\f[R] (ignore case)
When matching, casing differences are ignored.
.TP
\f[B]m\f[R] (multiline)
Treat beginning and end assertions (\f[V]\[ha]\f[R] and \f[V]$\f[R]) as
working over multiple lines.
In other words, match the beginning or end of \f[I]each\f[R] line
(delimited by \f[V]\[rs]n\f[R] or \f[V]\[rs]r\f[R]), not only the very
beginning or end of the whole input string.
.TP
\f[B]s\f[R] (dotAll)
Allows \f[V].\f[R] to match newlines.
.TP
\f[B]u\f[R] (unicode)
Treat \f[V]pattern\f[R] as a sequence of Unicode code points.
.TP
\f[B]y\f[R] (sticky)
Matches only from the index indicated by the \f[V]lastIndex\f[R]
property of this regular expression in the target string.
Does not attempt to match from any later indexes.
.RE
.SS Return value
.PP
\f[V]RegExp(pattern)\f[R] returns \f[V]pattern\f[R] directly if all of
the following are true:
.IP \[bu] 2
\f[V]RegExp()\f[R] is called without \f[V]new\f[R];
.IP \[bu] 2
\f[V]pattern\f[R] is a regex;
.IP \[bu] 2
\f[V]pattern.constructor === RegExp\f[R] (usually meaning it\[cq]s not a
subclass);
.IP \[bu] 2
\f[V]flags\f[R] is \f[V]undefined\f[R].
.PP
In all other cases, calling \f[V]RegExp()\f[R] with or without
\f[V]new\f[R] both create a new \f[V]RegExp\f[R] object.
If \f[V]pattern\f[R] is a regex, the new object\[cq]s source is
\f[V]pattern.source\f[R]; otherwise, its source is \f[V]pattern\f[R]
coerced to a string.
If the \f[V]flags\f[R] parameter is not \f[V]undefined\f[R], the new
object\[cq]s \f[V]flags\f[R] is the parameter\[cq]s value; otherwise,
its \f[V]flags\f[R] is \f[V]pattern.flags\f[R] (if \f[V]pattern\f[R] is
a regex).
.SS Exceptions
.TP
\f[B]SyntaxError\f[R]
Thrown if one of the following is true:
.RS
.IP \[bu] 2
\f[V]pattern\f[R] cannot be parsed as a valid regular expression.
.IP \[bu] 2
\f[V]flags\f[R] contains repeated characters or any character outside of
those allowed.
.RE
.SH EXAMPLES
.SS Literal notation and constructor
.PP
There are two ways to create a \f[V]RegExp\f[R] object: a \f[I]literal
notation\f[R] and a \f[I]constructor\f[R].
.IP \[bu] 2
The \f[I]literal notation\f[R] takes a pattern between two slashes,
followed by optional flags, after the second slash.
.IP \[bu] 2
The \f[I]constructor function\f[R] takes either a string or a
\f[V]RegExp\f[R] object as its first parameter and a string of optional
flags as its second parameter.
.PP
The following three expressions create the same regular expression:
.IP
.nf
\f[C]
/ab+c/i;
new RegExp(/ab+c/, \[dq]i\[dq]); // literal notation
new RegExp(\[dq]ab+c\[dq], \[dq]i\[dq]); // constructor
\f[R]
.fi
.PP
Before regular expressions can be used, they have to be compiled.
This process allows them to perform matches more efficiently.
There are two ways to compile and get a \f[V]RegExp\f[R] object.
.PP
The literal notation results in compilation of the regular expression
when the expression is evaluated.
On the other hand, the constructor of the \f[V]RegExp\f[R] object,
\f[V]new RegExp(\[aq]ab+c\[aq])\f[R], results in runtime compilation of
the regular expression.
.PP
Use a string as the first argument to the \f[V]RegExp()\f[R] constructor
when you want to build the regular expression from dynamic input.
.SS Building a regular expression from dynamic inputs
.IP
.nf
\f[C]
const breakfasts = [\[dq]bacon\[dq], \[dq]eggs\[dq], \[dq]oatmeal\[dq], \[dq]toast\[dq], \[dq]cereal\[dq]];
const order = \[dq]Let me get some bacon and eggs, please\[dq];

order.match(new RegExp(\[ga]\[rs]\[rs]b(${breakfasts.join(\[dq]|\[dq])})\[rs]\[rs]b\[ga], \[dq]g\[dq]));
// Returns [\[aq]bacon\[aq], \[aq]eggs\[aq]]
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of many modern \f[V]RegExp\f[R] features (\f[V]dotAll\f[R],
\f[V]sticky\f[R] flags, named capture groups, etc.)
in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-string-and-regexp)
.IP \[bu] 2
Regular Expressions chapter in the JavaScript Guide
.IP \[bu] 2
\f[V]String.prototype.match()\f[R]
.IP \[bu] 2
\f[V]String.prototype.replace()\f[R]
