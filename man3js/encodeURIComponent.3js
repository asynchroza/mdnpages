.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "encodeURIComponent" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]encodeURIComponent()\f[B]\f[R] function encodes a URI by
replacing each instance of certain characters by one, two, three, or
four escape sequences representing the UTF-8 encoding of the character
(will only be four escape sequences for characters composed of two
surrogate characters).
Compared to \f[V]encodeURI()\f[R], this function encodes more
characters, including those that are part of the URI syntax.
.SH Syntax
.IP
.nf
\f[C]
encodeURIComponent(uriComponent)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]uriComponent\f[R]
.RS 2
.IP \[bu] 2
A string to be encoded as a URI component (a path, query string,
fragment, etc.).
Other values are converted to strings.
.RE
.SS Return value
.PP
A new string representing the provided \f[V]uriComponent\f[R] encoded as
a URI component.
.SS Exceptions
.IP \[bu] 2
\f[V]URIError\f[R]
.RS 2
.IP \[bu] 2
Thrown if \f[V]uriComponent\f[R] contains a lone surrogate.
.RE
.SH Description
.PP
\f[V]encodeURIComponent()\f[R] is a function property of the global
object.
.PP
\f[V]encodeURIComponent()\f[R] uses the same encoding algorithm as
described in \f[V]encodeURI()\f[R].
It escapes all characters \f[B]except\f[R]:
.IP
.nf
\f[C]
A\[en]Z a\[en]z 0\[en]9 - _ . ! \[ti] * \[aq] ( )
\f[R]
.fi
.PP
Compared to \f[V]encodeURI()\f[R], \f[V]encodeURIComponent()\f[R]
escapes a larger set of characters.
Use \f[V]encodeURIComponent()\f[R] on user-entered fields from forms
\f[V]POST\f[R]\[cq]d to the server \[em] this will encode \f[V]&\f[R]
symbols that may inadvertently be generated during data entry for
special HTML entities or other characters that require
encoding/decoding.
For example, if a user writes \f[V]Jack & Jill\f[R], without
\f[V]encodeURIComponent()\f[R], the ampersand could be interpreted on
the server as the start of a new field and jeopardize the integrity of
the data.
.PP
For
\f[V]application/x-www-form-urlencoded\f[R] (https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#application/x-www-form-urlencoded-encoding-algorithm),
spaces are to be replaced by \f[V]+\f[R], so one may wish to follow a
\f[V]encodeURIComponent()\f[R] replacement with an additional
replacement of \f[V]%20\f[R] with \f[V]+\f[R].
.SH Examples
.SS Encoding for Content-Disposition and Link headers
.PP
The following example provides the special encoding required within
UTF-8 \f[V]Content-Disposition\f[R] and \f[V]Link\f[R] server response
header parameters (e.g., UTF-8 filenames):
.IP
.nf
\f[C]
const fileName = \[dq]my file(2).txt\[dq];
const header = \[ga]Content-Disposition: attachment; filename*=UTF-8\[aq]\[aq]${encodeRFC5987ValueChars(
  fileName,
)}\[ga];

console.log(header);
// \[dq]Content-Disposition: attachment; filename*=UTF-8\[aq]\[aq]my%20file%282%29.txt\[dq]

function encodeRFC5987ValueChars(str) {
  return (
    encodeURIComponent(str)
      // The following creates the sequences %27 %28 %29 %2A (Note that
      // the valid encoding of \[dq]*\[dq] is %2A, which necessitates calling
      // toUpperCase() to properly encode). Although RFC3986 reserves \[dq]!\[dq],
      // RFC5987 does not, so we do not need to escape it.
      .replace(
        /[\[aq]()*]/g,
        (c) => \[ga]%${c.charCodeAt(0).toString(16).toUpperCase()}\[ga],
      )
      // The following are not required for percent-encoding per RFC5987,
      // so we can allow for a little better readability over the wire: |\[ga]\[ha]
      .replace(/%(7C|60|5E)/g, (str, hex) =>
        String.fromCharCode(parseInt(hex, 16)),
      )
  );
}
\f[R]
.fi
.SS Encoding for RFC3986
.PP
The more recent RFC3986 (https://datatracker.ietf.org/doc/html/rfc3986)
reserves !, \[cq], (, ), and *, even though these characters have no
formalized URI delimiting uses.
The following function encodes a string for RFC3986-compliant URL
component format.
It also encodes [ and ], which are part of the IPv6 URI syntax.
An RFC3986-compliant \f[V]encodeURI\f[R] implementation should not
escape them, which is demonstrated in the \f[V]encodeURI()\f[R] example.
.IP
.nf
\f[C]
function encodeRFC3986URIComponent(str) {
  return encodeURIComponent(str).replace(
    /[!\[aq]()*]/g,
    (c) => \[ga]%${c.charCodeAt(0).toString(16).toUpperCase()}\[ga],
  );
}
\f[R]
.fi
.SS Encoding a lone high surrogate throws
.PP
A \f[V]URIError\f[R] will be thrown if one attempts to encode a
surrogate which is not part of a high-low pair.
For example:
.IP
.nf
\f[C]
// High-low pair OK
encodeURIComponent(\[dq]\[rs]uD800\[rs]uDFFF\[dq]); // \[dq]%F0%90%8F%BF\[dq]

// Lone high surrogate throws \[dq]URIError: malformed URI sequence\[dq]
encodeURIComponent(\[dq]\[rs]uD800\[dq]);

// Lone low surrogate throws \[dq]URIError: malformed URI sequence\[dq]
encodeURIComponent(\[dq]\[rs]uDFFF\[dq]);
\f[R]
.fi
.PP
You can use \f[V]String.prototype.toWellFormed()\f[R], which replaces
lone surrogates with the Unicode replacement character (U+FFFD), to
avoid this error.
You can also use \f[V]String.prototype.isWellFormed()\f[R] to check if a
string contains lone surrogates before passing it to
\f[V]encodeURIComponent()\f[R].
.SH See also
.IP \[bu] 2
\f[V]decodeURI()\f[R]
.IP \[bu] 2
\f[V]encodeURI()\f[R]
.IP \[bu] 2
\f[V]decodeURIComponent()\f[R]
