.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Function.call" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]call()\f[B]\f[R] method calls the function with a given
\f[V]this\f[R] value and arguments provided individually.
.SH Syntax
.IP
.nf
\f[C]
call(thisArg)
call(thisArg, arg1)
call(thisArg, arg1, /* \&..., */ argN)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]thisArg\f[R]
.RS 2
.IP \[bu] 2
The value to use as \f[V]this\f[R] when calling \f[V]func\f[R].
If the function is not in strict mode, \f[V]null\f[R] and
\f[V]undefined\f[R] will be replaced with the global object, and
primitive values will be converted to objects.
.RE
.IP \[bu] 2
\f[V]arg1, \&..., argN\f[R] \f[I](optional)\f[R]
.RS 2
.IP \[bu] 2
Arguments for the function.
.RE
.SS Return value
.PP
The result of calling the function with the specified \f[V]this\f[R]
value and arguments.
.SH Description
.RS
.PP
\f[B]Note:\f[R] This function is almost identical to \f[V]apply()\f[R],
except that the function arguments are passed to \f[V]call()\f[R]
individually as a list, while for \f[V]apply()\f[R] they are combined in
one object, typically an array \[em] for example,
\f[V]func.call(this, \[dq]eat\[dq], \[dq]bananas\[dq])\f[R]
vs.\ \f[V]func.apply(this, [\[dq]eat\[dq], \[dq]bananas\[dq]])\f[R].
.RE
.PP
Normally, when calling a function, the value of \f[V]this\f[R] inside
the function is the object that the function was accessed on.
With \f[V]call()\f[R], you can assign an arbitrary value as
\f[V]this\f[R] when calling an existing function, without first
attaching the function to the object as a property.
This allows you to use methods of one object as generic utility
functions.
.RS
.PP
\f[B]Warning:\f[R] Do not use \f[V]call()\f[R] to chain constructors
(for example, to implement inheritance).
This invokes the constructor function as a plain function, which means
\f[V]new.target\f[R] is \f[V]undefined\f[R], and classes throw an error
because they can\[cq]t be called without \f[V]new\f[R].
Use \f[V]Reflect.construct()\f[R] or \f[V]extends\f[R] instead.
.RE
.SH Examples
.SS Using call() to invoke a function and specifying the this value
.PP
In the example below, when we call \f[V]greet\f[R], the value of
\f[V]this\f[R] will be bound to object \f[V]obj\f[R], even when
\f[V]greet\f[R] is not a method of \f[V]obj\f[R].
.IP
.nf
\f[C]
function greet() {
  console.log(this.animal, \[dq]typically sleep between\[dq], this.sleepDuration);
}

const obj = {
  animal: \[dq]cats\[dq],
  sleepDuration: \[dq]12 and 16 hours\[dq],
};

greet.call(obj); // cats typically sleep between 12 and 16 hours
\f[R]
.fi
.SS Using call() to invoke a function without specifying the first argument
.PP
If the first \f[V]thisArg\f[R] parameter is omitted, it defaults to
\f[V]undefined\f[R].
In non-strict mode, the \f[V]this\f[R] value is then substituted with
\f[V]globalThis\f[R] (which is akin to the global object).
.IP
.nf
\f[C]
globalThis.globProp = \[dq]Wisen\[dq];

function display() {
  console.log(\[ga]globProp value is ${this.globProp}\[ga]);
}

display.call(); // Logs \[dq]globProp value is Wisen\[dq]
\f[R]
.fi
.PP
In strict mode, the value of \f[V]this\f[R] is not substituted, so it
stays as \f[V]undefined\f[R].
.IP
.nf
\f[C]
\[dq]use strict\[dq];

globalThis.globProp = \[dq]Wisen\[dq];

function display() {
  console.log(\[ga]globProp value is ${this.globProp}\[ga]);
}

display.call(); // throws TypeError: Cannot read the property of \[aq]globProp\[aq] of undefined
\f[R]
.fi
.SS Transforming methods to utility functions
.PP
\f[V]call()\f[R] is almost equivalent to a normal function call, except
that \f[V]this\f[R] is passed as a normal parameter instead of as the
value that the function was accessed on.
This is similar to how general-purpose utility functions work: instead
of calling \f[V]array.map(callback)\f[R], you use
\f[V]map(array, callback)\f[R], which avoids mutating
\f[V]Array.prototype\f[R], and allows you to use \f[V]map\f[R] with
array-like objects that are not arrays (for example,
\f[V]arguments\f[R]).
.PP
Take \f[V]Array.prototype.slice()\f[R], for example, which you want to
use for converting an array-like object to a real array.
You could create a shortcut like this:
.IP
.nf
\f[C]
const slice = Array.prototype.slice;

// ...

slice.call(arguments);
\f[R]
.fi
.PP
Note that you can\[cq]t save \f[V]slice.call\f[R] and call it as a plain
function, because the \f[V]call()\f[R] method also reads its
\f[V]this\f[R] value, which is the function it should call.
In this case, you can use \f[V]bind()\f[R] to bind the value of
\f[V]this\f[R] for \f[V]call()\f[R].
In the following piece of code, \f[V]slice()\f[R] is a bound version of
\f[V]Function.prototype.call()\f[R], with the \f[V]this\f[R] value bound
to \f[V]Array.prototype.slice()\f[R].
This means that additional \f[V]call()\f[R] calls can be eliminated:
.IP
.nf
\f[C]
// Same as \[dq]slice\[dq] in the previous example
const unboundSlice = Array.prototype.slice;
const slice = Function.prototype.call.bind(unboundSlice);

// ...

slice(arguments);
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]Function.prototype.bind()\f[R]
.IP \[bu] 2
\f[V]Function.prototype.apply()\f[R]
.IP \[bu] 2
\f[V]Reflect.apply()\f[R]
.IP \[bu] 2
Spread syntax
.IP \[bu] 2
Introduction to Object-Oriented JavaScript
