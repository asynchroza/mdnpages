'\" t
.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Math.atan2" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Math.atan2 - Math.atan2()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]Math.atan2()\f[B]\f[R] static method returns the angle in
the plane (in radians) between the positive x-axis and the ray from (0,
0) to the point (x, y), for \f[V]Math.atan2(y, x)\f[R].
.SH SYNTAX
.IP
.nf
\f[C]
Math.atan2(y, x)
\f[R]
.fi
.SS Parameters
.TP
\f[B]y\f[R]
The y coordinate of the point.
.TP
\f[B]x\f[R]
The x coordinate of the point.
.SS Return value
.PP
The angle in radians (between -π and π, inclusive) between the positive
x-axis and the ray from (0, 0) to the point (x, y).
.SH DESCRIPTION
.PP
The \f[V]Math.atan2()\f[R] method measures the counterclockwise angle θ,
in radians, between the positive x-axis and the point \f[V](x, y)\f[R].
Note that the arguments to this function pass the y-coordinate first and
the x-coordinate second.
[IMAGE: A simple diagram showing the angle returned by atan2(y, x)]
A simple diagram showing the angle returned by atan2(y, x)
.PP
\f[V]Math.atan2()\f[R] is passed separate \f[V]x\f[R] and \f[V]y\f[R]
arguments, while \f[V]Math.atan()\f[R] is passed the ratio of those two
arguments.
\f[V]Math.atan2(y, x)\f[R] differs from \f[V]Math.atan(y / x)\f[R] in
the following cases:
.PP
.TS
tab(@);
lw(20.9n) lw(11.5n) lw(18.8n) lw(18.8n).
T{
\f[V]x\f[R]
T}@T{
\f[V]y\f[R]
T}@T{
\f[V]Math.atan2(y, x)\f[R]
T}@T{
\f[V]Math.atan(y / x)\f[R]
T}
_
T{
\f[V]Infinity\f[R]
T}@T{
\f[V]Infinity\f[R]
T}@T{
π / 4
T}@T{
\f[V]NaN\f[R]
T}
T{
\f[V]Infinity\f[R]
T}@T{
\f[V]-Infinity\f[R]
T}@T{
-π / 4
T}@T{
\f[V]NaN\f[R]
T}
T{
\f[V]-Infinity\f[R]
T}@T{
\f[V]Infinity\f[R]
T}@T{
3π / 4
T}@T{
\f[V]NaN\f[R]
T}
T{
\f[V]-Infinity\f[R]
T}@T{
\f[V]-Infinity\f[R]
T}@T{
-3π / 4
T}@T{
\f[V]NaN\f[R]
T}
T{
0
T}@T{
0
T}@T{
0
T}@T{
\f[V]NaN\f[R]
T}
T{
0
T}@T{
-0
T}@T{
-0
T}@T{
\f[V]NaN\f[R]
T}
T{
< 0 (including \f[V]-0\f[R])
T}@T{
0
T}@T{
π
T}@T{
0
T}
T{
< 0 (including \f[V]-0\f[R])
T}@T{
-0
T}@T{
-π
T}@T{
0
T}
T{
\f[V]-Infinity\f[R]
T}@T{
> 0
T}@T{
π
T}@T{
-0
T}
T{
-0
T}@T{
> 0
T}@T{
π / 2
T}@T{
-π / 2
T}
T{
\f[V]-Infinity\f[R]
T}@T{
< 0
T}@T{
-π
T}@T{
0
T}
T{
-0
T}@T{
< 0
T}@T{
-π / 2
T}@T{
π / 2
T}
.TE
.PP
In addition, for points in the second and third quadrants
(\f[V]x < 0\f[R]), \f[V]Math.atan2()\f[R] would output an angle less
than -π2- or greater than π2.
.PP
Because \f[V]atan2()\f[R] is a static method of \f[V]Math\f[R], you
always use it as \f[V]Math.atan2()\f[R], rather than as a method of a
\f[V]Math\f[R] object you created (\f[V]Math\f[R] is not a constructor).
.SH EXAMPLES
.SS Using Math.atan2()
.IP
.nf
\f[C]
Math.atan2(90, 15); // 1.4056476493802699
Math.atan2(15, 90); // 0.16514867741462683
\f[R]
.fi
.SS Difference between Math.atan2(y, x) and Math.atan(y / x)
.PP
The following script prints all inputs that produce a difference between
\f[V]Math.atan2(y, x)\f[R] and \f[V]Math.atan(y / x)\f[R].
.IP
.nf
\f[C]
const formattedNumbers = new Map([
  [-Math.PI, \[dq]-π\[dq]],
  [(-3 * Math.PI) / 4, \[dq]-3π/4\[dq]],
  [-Math.PI / 2, \[dq]-π/2\[dq]],
  [-Math.PI / 4, \[dq]-π/4\[dq]],
  [Math.PI / 4, \[dq]π/4\[dq]],
  [Math.PI / 2, \[dq]π/2\[dq]],
  [(3 * Math.PI) / 4, \[dq]3π/4\[dq]],
  [Math.PI, \[dq]π\[dq]],
  [-Infinity, \[dq]-∞\[dq]],
  [Infinity, \[dq]∞\[dq]],
]);

function format(template, ...args) {
  return String.raw(
    { raw: template },
    ...args.map((num) =>
      (Object.is(num, -0)
        ? \[dq]-0\[dq]
        : formattedNumbers.get(num) ?? String(num)
      ).padEnd(5),
    ),
  );
}

console.log(\[ga]| x     | y     | atan2 | atan  |
|-------|-------|-------|-------|\[ga]);

for (const x of [-Infinity, -1, -0, 0, 1, Infinity]) {
  for (const y of [-Infinity, -1, -0, 0, 1, Infinity]) {
    const atan2 = Math.atan2(y, x);
    const atan = Math.atan(y / x);
    if (!Object.is(atan2, atan)) {
      console.log(format\[ga]| ${x} | ${y} | ${atan2} | ${atan} |\[ga]);
    }
  }
}
\f[R]
.fi
.PP
The output is:
.IP
.nf
\f[C]
| x     | y     | atan2 | atan  |
|-------|-------|-------|-------|
| -∞    | -∞    | -3π/4 | NaN   |
| -∞    | -1    | -π    | 0     |
| -∞    | -0    | -π    | 0     |
| -∞    | 0     | π     | -0    |
| -∞    | 1     | π     | -0    |
| -∞    | ∞     | 3π/4  | NaN   |
| -1    | -∞    | -π/2  | π/2   |
| -1    | -1    | -3π/4 | π/4   |
| -1    | -0    | -π    | 0     |
| -1    | 0     | π     | -0    |
| -1    | 1     | 3π/4  | -π/4  |
| -1    | ∞     | π/2   | -π/2  |
| -0    | -∞    | -π/2  | π/2   |
| -0    | -1    | -π/2  | π/2   |
| -0    | -0    | -π    | NaN   |
| -0    | 0     | π     | NaN   |
| -0    | 1     | π/2   | -π/2  |
| -0    | ∞     | π/2   | -π/2  |
| 0     | -0    | -0    | NaN   |
| 0     | 0     | 0     | NaN   |
| ∞     | -∞    | -π/4  | NaN   |
| ∞     | ∞     | π/4   | NaN   |
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
\f[V]Math.acos()\f[R]
.IP \[bu] 2
\f[V]Math.asin()\f[R]
.IP \[bu] 2
\f[V]Math.atan()\f[R]
.IP \[bu] 2
\f[V]Math.cos()\f[R]
.IP \[bu] 2
\f[V]Math.sin()\f[R]
.IP \[bu] 2
\f[V]Math.tan()\f[R]
