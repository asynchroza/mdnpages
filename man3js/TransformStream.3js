.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "TransformStream" "JS" "October 25, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
TransformStream \- TransformStream
.SH SYNOPSIS
The \f[B]\f[CB]TransformStream\f[B]\f[R] interface of the Streams API
represents a concrete implementation of the pipe chain \f[I]transform
stream\f[R] concept.
.PP
It may be passed to the \f[CR]ReadableStream.pipeThrough()\f[R] method
in order to transform a stream of data from one format into another.
For example, it might be used to decode (or encode) video frames,
decompress data, or convert the stream from XML to JSON.
.PP
A transformation algorithm may be provided as an optional argument to
the object constructor.
If not supplied, data is not modified when piped through the stream.
.PP
\f[CR]TransformStream\f[R] is a transferable object.
.SH CONSTRUCTOR
.TP
\f[B]TransformStream()\f[R]
Creates and returns a transform stream object, optionally specifying a
transformation object and queuing strategies for the streams.
.SH INSTANCE PROPERTIES
.TP
\f[B]TransformStream.readable\f[R] \f[I](read\-only)\f[R]
The \f[CR]readable\f[R] end of a \f[CR]TransformStream\f[R].
.TP
\f[B]TransformStream.writable\f[R] \f[I](read\-only)\f[R]
The \f[CR]writable\f[R] end of a \f[CR]TransformStream\f[R].
.SH INSTANCE METHODS
None
.SH EXAMPLES
.SS Anything\-to\-uint8array stream
In the following example, a transform stream passes through all chunks
it receives as \f[CR]Uint8Array\f[R] values.
.IP
.EX
const transformContent = {
  start() {}, // required.
  async transform(chunk, controller) {
    chunk = await chunk;
    switch (typeof chunk) {
      case \[dq]object\[dq]:
        // just say the stream is done I guess
        if (chunk === null) {
          controller.terminate();
        } else if (ArrayBuffer.isView(chunk)) {
          controller.enqueue(
            new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength),
          );
        } else if (
          Array.isArray(chunk) &&
          chunk.every((value) => typeof value === \[dq]number\[dq])
        ) {
          controller.enqueue(new Uint8Array(chunk));
        } else if (
          typeof chunk.valueOf === \[dq]function\[dq] &&
          chunk.valueOf() !== chunk
        ) {
          this.transform(chunk.valueOf(), controller); // hack
        } else if (\[dq]toJSON\[dq] in chunk) {
          this.transform(JSON.stringify(chunk), controller);
        }
        break;
      case \[dq]symbol\[dq]:
        controller.error(\[dq]Cannot send a symbol as a chunk part\[dq]);
        break;
      case \[dq]undefined\[dq]:
        controller.error(\[dq]Cannot send undefined as a chunk part\[dq]);
        break;
      default:
        controller.enqueue(this.textencoder.encode(String(chunk)));
        break;
    }
  },
  flush() {
    /* do any destructor work here */
  },
};

class AnyToU8Stream extends TransformStream {
  constructor() {
    super({ ...transformContent, textencoder: new TextEncoder() });
  }
}
.EE
.SS Polyfilling TextEncoderStream and TextDecoderStream
Note that this is deprecated by the native constructors.
This is intended as a polyfill for unsupported platforms.
.IP
.EX
const tes = {
  start() {
    this.encoder = new TextEncoder();
  },
  transform(chunk, controller) {
    controller.enqueue(this.encoder.encode(chunk));
  },
};

let _jstes_wm = new WeakMap(); /* info holder */
class JSTextEncoderStream extends TransformStream {
  constructor() {
    let t = { ...tes };

    super(t);
    _jstes_wm.set(this, t);
  }
  get encoding() {
    return _jstes_wm.get(this).encoder.encoding;
  }
}
.EE
.PP
Similarly, \f[CR]TextDecoderStream\f[R] can be written as such:
.IP
.EX
const tds = {
  start() {
    this.decoder = new TextDecoder(this.encoding, this.options);
  },
  transform(chunk, controller) {
    controller.enqueue(this.decoder.decode(chunk, { stream: true }));
  },
};

let _jstds_wm = new WeakMap(); /* info holder */
class JSTextDecoderStream extends TransformStream {
  constructor(encoding = \[dq]utf\-8\[dq], { ...options } = {}) {
    let t = { ...tds, encoding, options };

    super(t);
    _jstds_wm.set(this, t);
  }
  get encoding() {
    return _jstds_wm.get(this).decoder.encoding;
  }
  get fatal() {
    return _jstds_wm.get(this).decoder.fatal;
  }
  get ignoreBOM() {
    return _jstds_wm.get(this).decoder.ignoreBOM;
  }
}
.EE
.SS Chaining multiple ReadableStreams together
This is a useful one, where multiple streams can be conjoined.
Examples include building a PWA with progressive loading and progressive
streaming.
.IP
.EX
let responses = [
  /* conjoined response tree */
];
let { readable, writable } = new TransformStream();

responses.reduce(
  (a, res, i, arr) =>
    a.then(() => res.pipeTo(writable, { preventClose: i + 1 !== arr.length })),
  Promise.resolve(),
);
.EE
.PP
Note that this is not resilient to other influences.
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://whatwg-stream-visualizer.glitch.me/
WHATWG Stream Visualizer
.UE \c
, for a basic visualization of readable, writable, and transform
streams.
.IP \[bu] 2
\c
.UR https://web.dev/articles/streams
Streams\[em]The Definitive Guide
.UE \c
