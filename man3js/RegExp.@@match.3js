.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "RegExp.\[at]\[at]match" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
RegExp.\[at]\[at]match - RegExp.prototype\[at]\[at]match
.SH SYNOPSIS
.PP
The \f[B]\f[VB][\[at]\[at]match]()\f[B]\f[R] method of \f[V]RegExp\f[R]
instances specifies how \f[V]String.prototype.match()\f[R] should
behave.
In addition, its presence (or absence) can influence whether an object
is regarded as a regular expression.
.SH SYNTAX
.IP
.nf
\f[C]
regexp[Symbol.match](str)
\f[R]
.fi
.SS Parameters
.TP
\f[B]str\f[R]
A \f[V]String\f[R] that is a target of the match.
.SS Return value
.PP
An \f[V]Array\f[R] whose contents depend on the presence or absence of
the global (\f[V]g\f[R]) flag, or \f[V]null\f[R] if no matches are
found.
.IP \[bu] 2
If the \f[V]g\f[R] flag is used, all results matching the complete
regular expression will be returned, but capturing groups are not
included.
.IP \[bu] 2
If the \f[V]g\f[R] flag is not used, only the first complete match and
its related capturing groups are returned.
In this case, \f[V]match()\f[R] will return the same result as
\f[V]RegExp.prototype.exec()\f[R] (an array with some extra properties).
.SH DESCRIPTION
.PP
This method is called internally in \f[V]String.prototype.match()\f[R].
.PP
For example, the following two examples return same result.
.IP
.nf
\f[C]
\[dq]abc\[dq].match(/a/);

/a/[Symbol.match](\[dq]abc\[dq]);
\f[R]
.fi
.PP
If the regex is global (with the \f[V]g\f[R] flag), the regex\[cq]s
\f[V]exec()\f[R] method will be repeatedly called until \f[V]exec()\f[R]
returns \f[V]null\f[R].
Otherwise, \f[V]exec()\f[R] would only be called once and its result
becomes the return value of \f[V]\[at]\[at]match\f[R].
.PP
Because \f[V]\[at]\[at]match\f[R] would keep calling \f[V]exec()\f[R]
until it returns \f[V]null\f[R], and \f[V]exec()\f[R] would
automatically reset the regex\[cq]s \f[V]lastIndex\f[R] to 0 when the
last match fails, \f[V]\[at]\[at]match\f[R] would typically not have
side effects when it exits.
However, when the regex is sticky but not global, \f[V]lastIndex\f[R]
would not be reset.
In this case, each call to \f[V]match()\f[R] may return a different
result.
.IP
.nf
\f[C]
const re = /[abc]/y;
for (let i = 0; i < 5; i++) {
  console.log(\[dq]abc\[dq].match(re), re.lastIndex);
}
// [ \[aq]a\[aq] ] 1
// [ \[aq]b\[aq] ] 2
// [ \[aq]c\[aq] ] 3
// null 0
// [ \[aq]a\[aq] ] 1
\f[R]
.fi
.PP
When the regex is sticky and global, it would still perform sticky
matches \[em] i.e.\ it would fail to match any occurrences beyond the
\f[V]lastIndex\f[R].
.IP
.nf
\f[C]
console.log(\[dq]ab-c\[dq].match(/[abc]/gy)); // [ \[aq]a\[aq], \[aq]b\[aq] ]
\f[R]
.fi
.PP
If the current match is an empty string, the \f[V]lastIndex\f[R] would
still be advanced \[em] if the regex has the \f[V]u\f[R] flag, it would
advance by one Unicode code point; otherwise, it advances by one UTF-16
code unit.
.IP
.nf
\f[C]
console.log(\[dq]ðŸ˜„\[dq].match(/(?:)/g)); // [ \[aq]\[aq], \[aq]\[aq], \[aq]\[aq] ]
console.log(\[dq]ðŸ˜„\[dq].match(/(?:)/gu)); // [ \[aq]\[aq], \[aq]\[aq] ]
\f[R]
.fi
.PP
This method exists for customizing match behavior within
\f[V]RegExp\f[R] subclasses.
.PP
In addition, the \f[V]\[at]\[at]match\f[R] property is used to check
whether an object is a regular expression.
.SH EXAMPLES
.SS Direct call
.PP
This method can be used in \f[I]almost\f[R] the same way as
\f[V]String.prototype.match()\f[R], except the different \f[V]this\f[R]
and the different arguments order.
.IP
.nf
\f[C]
const re = /[0-9]+/g;
const str = \[dq]2016-01-02\[dq];
const result = re[Symbol.match](str);
console.log(result); // [\[dq]2016\[dq], \[dq]01\[dq], \[dq]02\[dq]]
\f[R]
.fi
.SS Using \[at]\[at]match in subclasses
.PP
Subclasses of \f[V]RegExp\f[R] can override the
\f[V][\[at]\[at]match]()\f[R] method to modify the default behavior.
.IP
.nf
\f[C]
class MyRegExp extends RegExp {
  [Symbol.match](str) {
    const result = RegExp.prototype[Symbol.match].call(this, str);
    if (!result) return null;
    return {
      group(n) {
        return result[n];
      },
    };
  }
}

const re = new MyRegExp(\[dq]([0-9]+)-([0-9]+)-([0-9]+)\[dq]);
const str = \[dq]2016-01-02\[dq];
const result = str.match(re); // String.prototype.match calls re[\[at]\[at]match].
console.log(result.group(1)); // 2016
console.log(result.group(2)); // 01
console.log(result.group(3)); // 02
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]RegExp.prototype[\[at]\[at]match]\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-string-and-regexp)
.IP \[bu] 2
\f[V]String.prototype.match()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype[\[at]\[at]matchAll]()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype[\[at]\[at]replace]()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype[\[at]\[at]search]()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype[\[at]\[at]split]()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype.exec()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype.test()\f[R]
.IP \[bu] 2
\f[V]Symbol.match\f[R]
