.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Generator" "JS" "September 12, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Generator - Generator
.SH SYNOPSIS
The \f[B]\f[CB]Generator\f[B]\f[R] object is returned by a
\f[CR]generator function\f[R] and it conforms to both the iterable
protocol and the iterator protocol.
.PP
\f[CR]Generator\f[R] is a subclass of the hidden \f[CR]Iterator\f[R]
class.
.SH CONSTRUCTOR
The \f[CR]Generator\f[R] constructor is not available globally.
Instances of \f[CR]Generator\f[R] must be returned from generator
functions:
.IP
.EX
function* generator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = generator(); // \[dq]Generator { }\[dq]

console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
.EE
.PP
In fact, there\[cq]s no JavaScript entity that corresponds to the
\f[CR]Generator\f[R] constructor.
There\[cq]s only a hidden object which is the prototype object shared by
all objects created by generator functions.
This object is often stylized as \f[CR]Generator.prototype\f[R] to make
it look like a class, but it should be more appropriately called
\f[CR]GeneratorFunction.prototype.prototype\f[R], because
\f[CR]GeneratorFunction\f[R] is an actual JavaScript entity.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]Generator.prototype\f[R] and
shared by all \f[CR]Generator\f[R] instances.
.TP
\f[B]Generator.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]Generator\f[R] instances, the initial value is
\f[CR]GeneratorFunction.prototype\f[R].
.RS
.RS
.PP
\f[B]Note:\f[R] \f[CR]Generator\f[R] objects do not store a reference to
the generator function that created them.
.RE
.RE
.TP
\f[B]Generator.prototype[\[at]\[at]toStringTag]\f[R]
The initial value of the \f[CR]\[at]\[at]toStringTag\f[R] property is
the string \f[CR]\[dq]Generator\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
.SH INSTANCE METHODS
\f[I]Also inherits instance methods from its parent
\f[CI]Iterator\f[I]\f[R].
.TP
\f[B]Generator.prototype.next()\f[R]
Returns a value yielded by the \f[CR]yield\f[R] expression.
.TP
\f[B]Generator.prototype.return()\f[R]
Acts as if a \f[CR]return\f[R] statement is inserted in the
generator\[cq]s body at the current suspended position, which finishes
the generator and allows the generator to perform any cleanup tasks when
combined with a \f[CR]try...finally\f[R] block.
.TP
\f[B]Generator.prototype.throw()\f[R]
Acts as if a \f[CR]throw\f[R] statement is inserted in the
generator\[cq]s body at the current suspended position, which informs
the generator of an error condition and allows it to handle the error,
or perform cleanup and close itself.
.SH EXAMPLES
.SS An infinite iterator
With a generator function, values are not evaluated until they are
needed.
Therefore a generator allows us to define a potentially infinite data
structure.
.IP
.EX
function* infinite() {
  let index = 0;

  while (true) {
    yield index++;
  }
}

const generator = infinite(); // \[dq]Generator { }\[dq]

console.log(generator.next().value); // 0
console.log(generator.next().value); // 1
console.log(generator.next().value); // 2
// \&...
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]function*\f[R]
.IP \[bu] 2
\f[CR]function*\f[R] expression
.IP \[bu] 2
\f[CR]GeneratorFunction\f[R]
.IP \[bu] 2
Iteration protocols
