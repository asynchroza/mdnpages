.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "String.matchAll" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]matchAll()\f[B]\f[R] method returns an iterator of all
results matching a string against a regular expression, including
capturing groups.
.SH Syntax
.IP
.nf
\f[C]
matchAll(regexp)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]regexp\f[R]
.RS 2
.IP \[bu] 2
A regular expression object, or any object that has a
\f[V]Symbol.matchAll\f[R] method.
.RS 2
.PP
If \f[V]regexp\f[R] is not a \f[V]RegExp\f[R] object and does not have a
\f[V]Symbol.matchAll\f[R] method, it is implicitly converted to a
\f[V]RegExp\f[R] by using \f[V]new RegExp(regexp, \[aq]g\[aq])\f[R].
.PP
If \f[V]regexp\f[R] is a regex, then it must have the global
(\f[V]g\f[R]) flag set, or a \f[V]TypeError\f[R] is thrown.
.RE
.RE
.SS Return value
.PP
An iterable iterator object (which is not restartable) of matches.
Each match is an array with the same shape as the return value of
\f[V]RegExp.prototype.exec()\f[R].
.SS Exceptions
.IP \[bu] 2
\f[V]TypeError\f[R]
.RS 2
.IP \[bu] 2
Thrown if the \f[V]regexp\f[R] is a regex that does not have the global
(\f[V]g\f[R]) flag set (its \f[V]flags\f[R] property does not contain
\f[V]\[dq]g\[dq]\f[R]).
.RE
.SH Description
.PP
The implementation of \f[V]String.prototype.matchAll\f[R] itself is very
simple \[em] it simply calls the \f[V]Symbol.matchAll\f[R] method of the
argument with the string as the first parameter (apart from the extra
input validation that the regex is global).
The actual implementation comes from
\f[V]RegExp.prototype[\[at]\[at]matchAll]()\f[R].
.SH Examples
.SS Regexp.prototype.exec() and matchAll()
.PP
Without \f[V]matchAll()\f[R], it\[cq]s possible to use calls to
\f[V]regexp.exec()\f[R] (and regexes with the \f[V]g\f[R] flag) in a
loop to obtain all the matches:
.IP
.nf
\f[C]
const regexp = /foo[a-z]*/g;
const str = \[dq]table football, foosball\[dq];
let match;

while ((match = regexp.exec(str)) !== null) {
  console.log(
    \[ga]Found ${match[0]} start=${match.index} end=${regexp.lastIndex}.\[ga],
  );
}
// Found football start=6 end=14.
// Found foosball start=16 end=24.
\f[R]
.fi
.PP
With \f[V]matchAll()\f[R] available, you can avoid the \f[V]while\f[R]
loop and \f[V]exec\f[R] with \f[V]g\f[R].
Instead, you get an iterator to use with the more convenient
\f[V]for...of\f[R], array spreading, or \f[V]Array.from()\f[R]
constructs:
.IP
.nf
\f[C]
const regexp = /foo[a-z]*/g;
const str = \[dq]table football, foosball\[dq];
const matches = str.matchAll(regexp);

for (const match of matches) {
  console.log(
    \[ga]Found ${match[0]} start=${match.index} end=${
      match.index + match[0].length
    }.\[ga],
  );
}
// Found football start=6 end=14.
// Found foosball start=16 end=24.

// matches iterator is exhausted after the for...of iteration
// Call matchAll again to create a new iterator
Array.from(str.matchAll(regexp), (m) => m[0]);
// [ \[dq]football\[dq], \[dq]foosball\[dq] ]
\f[R]
.fi
.PP
\f[V]matchAll\f[R] will throw an exception if the \f[V]g\f[R] flag is
missing.
.IP
.nf
\f[C]
const regexp = /[a-c]/;
const str = \[dq]abc\[dq];
str.matchAll(regexp);
// TypeError
\f[R]
.fi
.PP
\f[V]matchAll\f[R] internally makes a clone of the \f[V]regexp\f[R]
\[em] so, unlike \f[V]regexp.exec()\f[R], \f[V]lastIndex\f[R] does not
change as the string is scanned.
.IP
.nf
\f[C]
const regexp = /[a-c]/g;
regexp.lastIndex = 1;
const str = \[dq]abc\[dq];
Array.from(str.matchAll(regexp), (m) => \[ga]${regexp.lastIndex} ${m[0]}\[ga]);
// [ \[dq]1 b\[dq], \[dq]1 c\[dq] ]
\f[R]
.fi
.PP
However, this means that unlike using \f[V]regexp.exec()\f[R] in a loop,
you can\[cq]t mutate \f[V]lastIndex\f[R] to make the regex advance or
rewind.
.SS Better access to capturing groups (than String.prototype.match())
.PP
Another compelling reason for \f[V]matchAll\f[R] is the improved access
to capture groups.
.PP
Capture groups are ignored when using \f[V]match()\f[R] with the global
\f[V]g\f[R] flag:
.IP
.nf
\f[C]
const regexp = /t(e)(st(\[rs]d?))/g;
const str = \[dq]test1test2\[dq];

str.match(regexp); // [\[aq]test1\[aq], \[aq]test2\[aq]]
\f[R]
.fi
.PP
Using \f[V]matchAll\f[R], you can access capture groups easily:
.IP
.nf
\f[C]
const array = [...str.matchAll(regexp)];

array[0];
// [\[aq]test1\[aq], \[aq]e\[aq], \[aq]st1\[aq], \[aq]1\[aq], index: 0, input: \[aq]test1test2\[aq], length: 4]
array[1];
// [\[aq]test2\[aq], \[aq]e\[aq], \[aq]st2\[aq], \[aq]2\[aq], index: 5, input: \[aq]test1test2\[aq], length: 4]
\f[R]
.fi
.SS Using matchAll() with a non-RegExp implementing \[at]\[at]matchAll
.PP
If an object has a \f[V]Symbol.matchAll\f[R] method, it can be used as a
custom matcher.
The return value of \f[V]Symbol.matchAll\f[R] becomes the return value
of \f[V]matchAll()\f[R].
.IP
.nf
\f[C]
const str = \[dq]Hmm, this is interesting.\[dq];

str.matchAll({
  [Symbol.matchAll](str) {
    return [[\[dq]Yes, it\[aq]s interesting.\[dq]]];
  },
}); // returns [[\[dq]Yes, it\[aq]s interesting.\[dq]]]
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]String.prototype.matchAll\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-string-and-regexp)
.IP \[bu] 2
\f[V]String.prototype.match()\f[R]
.IP \[bu] 2
Using regular expressions in JavaScript
.IP \[bu] 2
Capturing groups
.IP \[bu] 2
\f[V]RegExp\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype.exec()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype.test()\f[R]
.IP \[bu] 2
\f[V]RegExp.prototype[\[at]\[at]matchAll]()\f[R]
