.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "String.matchAll" "JS" "September 25, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.matchAll \- String.prototype.matchAll()
.SH SYNOPSIS
The \f[B]\f[CB]matchAll()\f[B]\f[R] method of \f[CR]String\f[R] values
returns an iterator of all results matching this string against a
regular expression, including capturing groups.
.SH SYNTAX
.IP
.EX
matchAll(regexp)
.EE
.SS Parameters
.TP
\f[B]regexp\f[R]
A regular expression object, or any object that has a
\f[CR]Symbol.matchAll\f[R] method.
.RS
.PP
If \f[CR]regexp\f[R] is not a \f[CR]RegExp\f[R] object and does not have
a \f[CR]Symbol.matchAll\f[R] method, it is implicitly converted to a
\f[CR]RegExp\f[R] by using \f[CR]new RegExp(regexp, \[aq]g\[aq])\f[R].
.PP
If \f[CR]regexp\f[R] is a regex, then it must have the global
(\f[CR]g\f[R]) flag set, or a \f[CR]TypeError\f[R] is thrown.
.RE
.SS Return value
An iterable iterator object (which is not restartable) of matches.
Each match is an array with the same shape as the return value of
\f[CR]RegExp.prototype.exec()\f[R].
.SS Exceptions
.TP
\f[B]TypeError\f[R]
Thrown if the \f[CR]regexp\f[R] is a regex that does not have the global
(\f[CR]g\f[R]) flag set (its \f[CR]flags\f[R] property does not contain
\f[CR]\[dq]g\[dq]\f[R]).
.SH DESCRIPTION
The implementation of \f[CR]String.prototype.matchAll\f[R] itself is
very simple \[em] it simply calls the \f[CR]Symbol.matchAll\f[R] method
of the argument with the string as the first parameter (apart from the
extra input validation that the regex is global).
The actual implementation comes from
\f[CR]RegExp.prototype[\[at]\[at]matchAll]()\f[R].
.SH EXAMPLES
.SS Regexp.prototype.exec() and matchAll()
Without \f[CR]matchAll()\f[R], it\[cq]s possible to use calls to
\f[CR]regexp.exec()\f[R] (and regexes with the \f[CR]g\f[R] flag) in a
loop to obtain all the matches:
.IP
.EX
const regexp = /foo[a\-z]*/g;
const str = \[dq]table football, foosball\[dq];
let match;

while ((match = regexp.exec(str)) !== null) {
  console.log(
    \[ga]Found ${match[0]} start=${match.index} end=${regexp.lastIndex}.\[ga],
  );
}
// Found football start=6 end=14.
// Found foosball start=16 end=24.
.EE
.PP
With \f[CR]matchAll()\f[R] available, you can avoid the \f[CR]while\f[R]
loop and \f[CR]exec\f[R] with \f[CR]g\f[R].
Instead, you get an iterator to use with the more convenient
\f[CR]for...of\f[R], array spreading, or \f[CR]Array.from()\f[R]
constructs:
.IP
.EX
const regexp = /foo[a\-z]*/g;
const str = \[dq]table football, foosball\[dq];
const matches = str.matchAll(regexp);

for (const match of matches) {
  console.log(
    \[ga]Found ${match[0]} start=${match.index} end=${
      match.index + match[0].length
    }.\[ga],
  );
}
// Found football start=6 end=14.
// Found foosball start=16 end=24.

// matches iterator is exhausted after the for...of iteration
// Call matchAll again to create a new iterator
Array.from(str.matchAll(regexp), (m) => m[0]);
// [ \[dq]football\[dq], \[dq]foosball\[dq] ]
.EE
.PP
\f[CR]matchAll\f[R] will throw an exception if the \f[CR]g\f[R] flag is
missing.
.IP
.EX
const regexp = /[a\-c]/;
const str = \[dq]abc\[dq];
str.matchAll(regexp);
// TypeError
.EE
.PP
\f[CR]matchAll\f[R] internally makes a clone of the \f[CR]regexp\f[R]
\[em] so, unlike \f[CR]regexp.exec()\f[R], \f[CR]lastIndex\f[R] does not
change as the string is scanned.
.IP
.EX
const regexp = /[a\-c]/g;
regexp.lastIndex = 1;
const str = \[dq]abc\[dq];
Array.from(str.matchAll(regexp), (m) => \[ga]${regexp.lastIndex} ${m[0]}\[ga]);
// [ \[dq]1 b\[dq], \[dq]1 c\[dq] ]
.EE
.PP
However, this means that unlike using \f[CR]regexp.exec()\f[R] in a
loop, you can\[cq]t mutate \f[CR]lastIndex\f[R] to make the regex
advance or rewind.
.SS Better access to capturing groups (than String.prototype.match())
Another compelling reason for \f[CR]matchAll\f[R] is the improved access
to capture groups.
.PP
Capture groups are ignored when using \f[CR]match()\f[R] with the global
\f[CR]g\f[R] flag:
.IP
.EX
const regexp = /t(e)(st(\[rs]d?))/g;
const str = \[dq]test1test2\[dq];

str.match(regexp); // [\[aq]test1\[aq], \[aq]test2\[aq]]
.EE
.PP
Using \f[CR]matchAll\f[R], you can access capture groups easily:
.IP
.EX
const array = [...str.matchAll(regexp)];

array[0];
// [\[aq]test1\[aq], \[aq]e\[aq], \[aq]st1\[aq], \[aq]1\[aq], index: 0, input: \[aq]test1test2\[aq], length: 4]
array[1];
// [\[aq]test2\[aq], \[aq]e\[aq], \[aq]st2\[aq], \[aq]2\[aq], index: 5, input: \[aq]test1test2\[aq], length: 4]
.EE
.SS Using matchAll() with a non\-RegExp implementing \[at]\[at]matchAll
If an object has a \f[CR]Symbol.matchAll\f[R] method, it can be used as
a custom matcher.
The return value of \f[CR]Symbol.matchAll\f[R] becomes the return value
of \f[CR]matchAll()\f[R].
.IP
.EX
const str = \[dq]Hmm, this is interesting.\[dq];

str.matchAll({
  [Symbol.matchAll](str) {
    return [[\[dq]Yes, it\[aq]s interesting.\[dq]]];
  },
}); // returns [[\[dq]Yes, it\[aq]s interesting.\[dq]]]
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://github.com/zloirock/core-js#ecmascript-string-and-regexp
Polyfill of \f[CR]String.prototype.matchAll\f[R] in \f[CR]core\-js\f[R]
.UE \c
.IP \[bu] 2
\f[CR]String.prototype.match()\f[R]
.IP \[bu] 2
Regular expressions guide
.IP \[bu] 2
Groups and backreferences guide
.IP \[bu] 2
\f[CR]RegExp\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype.exec()\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype.test()\f[R]
.IP \[bu] 2
\f[CR]RegExp.prototype[\[at]\[at]matchAll]()\f[R]
