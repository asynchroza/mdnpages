.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "SubtleCrypto.exportKey" "JS" "July 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
SubtleCrypto.exportKey \- SubtleCrypto: exportKey() method
.SH SYNOPSIS
\f[B]Secure context\f[R]: This feature is available only in secure
contexts (HTTPS).
.PP
The \f[B]\f[CB]exportKey()\f[B]\f[R] method of the
\f[CR]SubtleCrypto\f[R] interface exports a key: that is, it takes as
input a \f[CR]CryptoKey\f[R] object and gives you the key in an
external, portable format.
.PP
To export a key, the key must have \f[CR]CryptoKey.extractable\f[R] set
to \f[CR]true\f[R].
.PP
Keys can be exported in several formats: see Supported formats in the
\f[CR]SubtleCrypto.importKey()\f[R] page for details.
.PP
Keys are not exported in an encrypted format: to encrypt keys when
exporting them use the \f[CR]SubtleCrypto.wrapKey()\f[R] API instead.
.SH SYNTAX
.IP
.EX
exportKey(format, key)
.EE
.SS Parameters
.TP
\f[B]format\f[R]
A string value describing the data format in which the key should be
exported.
It can be one of the following:
.RS
.IP \[bu] 2
\f[CR]raw\f[R]: Raw format.
.IP \[bu] 2
\f[CR]pkcs8\f[R]: PKCS #8 format.
.IP \[bu] 2
\f[CR]spki\f[R]: SubjectPublicKeyInfo format.
.IP \[bu] 2
\f[CR]jwk\f[R]: JSON Web Key format.
.RE
.TP
\f[B]key\f[R]
The \f[CR]CryptoKey\f[R] to export.
.SS Return value
A \f[CR]Promise\f[R].
.IP \[bu] 2
If \f[CR]format\f[R] was \f[CR]jwk\f[R], then the promise fulfills with
a JSON object containing the key.
.IP \[bu] 2
Otherwise the promise fulfills with an \f[CR]ArrayBuffer\f[R] containing
the key.
.SS Exceptions
The promise is rejected when one of the following exceptions is
encountered:
.TP
\f[B]InvalidAccessError\f[R] \f[B]DOMException\f[R]
Raised when trying to export a non\-extractable key.
.TP
\f[B]NotSupported\f[R] \f[B]DOMException\f[R]
Raised when trying to export in an unknown format.
.TP
\f[B]TypeError\f[R]
Raised when trying to use an invalid format.
.SH EXAMPLES
.RS
.PP
\f[B]Note:\f[R] You can \c
.UR https://mdn.github.io/dom-examples/web-crypto/export-key/index.html
try the working examples
.UE \c
\ out on GitHub.
.RE
.SS Raw export
This example exports an AES key as an \f[CR]ArrayBuffer\f[R] containing
the bytes for the key.
\c
.UR
https://github.com/mdn/dom-examples/blob/main/web-crypto/export-key/raw.js
See the complete code on GitHub
.UE \c
\&.
.IP
.EX
/*
Export the given key and write it into the \[dq]exported\-key\[dq] space.
*/
async function exportCryptoKey(key) {
  const exported = await window.crypto.subtle.exportKey(\[dq]raw\[dq], key);
  const exportedKeyBuffer = new Uint8Array(exported);

  const exportKeyOutput = document.querySelector(\[dq].exported\-key\[dq]);
  exportKeyOutput.textContent = \[ga][${exportedKeyBuffer}]\[ga];
}

/*
Generate an encrypt/decrypt secret key,
then set up an event listener on the \[dq]Export\[dq] button.
*/
window.crypto.subtle
  .generateKey(
    {
      name: \[dq]AES\-GCM\[dq],
      length: 256,
    },
    true,
    [\[dq]encrypt\[dq], \[dq]decrypt\[dq]],
  )
  .then((key) => {
    const exportButton = document.querySelector(\[dq].raw\[dq]);
    exportButton.addEventListener(\[dq]click\[dq], () => {
      exportCryptoKey(key);
    });
  });
.EE
.SS PKCS #8 export
This example exports an RSA private signing key as a PKCS #8 object.
The exported key is then PEM\-encoded.
\c
.UR
https://github.com/mdn/dom-examples/blob/main/web-crypto/export-key/pkcs8.js
See the complete code on GitHub
.UE \c
\&.
.IP
.EX
/*
Convert an ArrayBuffer into a string
from https://developer.chrome.com/blog/how\-to\-convert\-arraybuffer\-to\-and\-from\-string/
*/
function ab2str(buf) {
  return String.fromCharCode.apply(null, new Uint8Array(buf));
}

/*
Export the given key and write it into the \[dq]exported\-key\[dq] space.
*/
async function exportCryptoKey(key) {
  const exported = await window.crypto.subtle.exportKey(\[dq]pkcs8\[dq], key);
  const exportedAsString = ab2str(exported);
  const exportedAsBase64 = window.btoa(exportedAsString);
  const pemExported = \[ga]\-\-\-\-\-BEGIN PRIVATE KEY\-\-\-\-\-\[rs]n${exportedAsBase64}\[rs]n\-\-\-\-\-END PRIVATE KEY\-\-\-\-\-\[ga];

  const exportKeyOutput = document.querySelector(\[dq].exported\-key\[dq]);
  exportKeyOutput.textContent = pemExported;
}

/*
Generate a sign/verify key pair,
then set up an event listener on the \[dq]Export\[dq] button.
*/
window.crypto.subtle
  .generateKey(
    {
      name: \[dq]RSA\-PSS\[dq],
      // Consider using a 4096\-bit key for systems that require long\-term security
      modulusLength: 2048,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: \[dq]SHA\-256\[dq],
    },
    true,
    [\[dq]sign\[dq], \[dq]verify\[dq]],
  )
  .then((keyPair) => {
    const exportButton = document.querySelector(\[dq].pkcs8\[dq]);
    exportButton.addEventListener(\[dq]click\[dq], () => {
      exportCryptoKey(keyPair.privateKey);
    });
  });
.EE
.SS SubjectPublicKeyInfo export
This example exports an RSA public encryption key as a PEM\-encoded
SubjectPublicKeyInfo object.
\c
.UR
https://github.com/mdn/dom-examples/blob/main/web-crypto/export-key/spki.js
See the complete code on GitHub
.UE \c
\&.
.IP
.EX
/*
Convert an ArrayBuffer into a string
from https://developer.chrome.com/blog/how\-to\-convert\-arraybuffer\-to\-and\-from\-string/
*/
function ab2str(buf) {
  return String.fromCharCode.apply(null, new Uint8Array(buf));
}

/*
Export the given key and write it into the \[dq]exported\-key\[dq] space.
*/
async function exportCryptoKey(key) {
  const exported = await window.crypto.subtle.exportKey(\[dq]spki\[dq], key);
  const exportedAsString = ab2str(exported);
  const exportedAsBase64 = window.btoa(exportedAsString);
  const pemExported = \[ga]\-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-\[rs]n${exportedAsBase64}\[rs]n\-\-\-\-\-END PUBLIC KEY\-\-\-\-\-\[ga];

  const exportKeyOutput = document.querySelector(\[dq].exported\-key\[dq]);
  exportKeyOutput.textContent = pemExported;
}

/*
Generate an encrypt/decrypt key pair,
then set up an event listener on the \[dq]Export\[dq] button.
*/
window.crypto.subtle
  .generateKey(
    {
      name: \[dq]RSA\-OAEP\[dq],
      // Consider using a 4096\-bit key for systems that require long\-term security
      modulusLength: 2048,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: \[dq]SHA\-256\[dq],
    },
    true,
    [\[dq]encrypt\[dq], \[dq]decrypt\[dq]],
  )
  .then((keyPair) => {
    const exportButton = document.querySelector(\[dq].spki\[dq]);
    exportButton.addEventListener(\[dq]click\[dq], () => {
      exportCryptoKey(keyPair.publicKey);
    });
  });
.EE
.SS JSON Web Key export
This example exports an ECDSA private signing key as a JSON Web Key
object.
\c
.UR
https://github.com/mdn/dom-examples/blob/main/web-crypto/export-key/jwk.js
See the complete code on GitHub
.UE \c
\&.
.IP
.EX
/*
Export the given key and write it into the \[dq]exported\-key\[dq] space.
*/
async function exportCryptoKey(key) {
  const exported = await window.crypto.subtle.exportKey(\[dq]jwk\[dq], key);
  const exportKeyOutput = document.querySelector(\[dq].exported\-key\[dq]);
  exportKeyOutput.textContent = JSON.stringify(exported, null, \[dq] \[dq]);
}

/*
Generate a sign/verify key pair,
then set up an event listener on the \[dq]Export\[dq] button.
*/
window.crypto.subtle
  .generateKey(
    {
      name: \[dq]ECDSA\[dq],
      namedCurve: \[dq]P\-384\[dq],
    },
    true,
    [\[dq]sign\[dq], \[dq]verify\[dq]],
  )
  .then((keyPair) => {
    const exportButton = document.querySelector(\[dq].jwk\[dq]);
    exportButton.addEventListener(\[dq]click\[dq], () => {
      exportCryptoKey(keyPair.privateKey);
    });
  });
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]SubtleCrypto.importKey()\f[R]
.IP \[bu] 2
\f[CR]SubtleCrypto.wrapKey()\f[R]
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc5208
PKCS #8 format
.UE \c
\&.
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc5280#section-4.1
SubjectPublicKeyInfo format
.UE \c
\&.
.IP \[bu] 2
\c
.UR https://datatracker.ietf.org/doc/html/rfc7517
JSON Web Key format
.UE \c
\&.
