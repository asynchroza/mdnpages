.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "String.charAt" "JS" "April 28, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
String.charAt - String.prototype.charAt()
.SH SYNOPSIS
The \f[B]\f[CB]charAt()\f[B]\f[R] method of \f[CR]String\f[R] values
returns a new string consisting of the single UTF-16 code unit located
at the specified offset into the string.
.SH SYNTAX
.IP
.EX
charAt(index)
.EE
.SS Parameters
.TP
\f[B]index\f[R]
An integer between \f[CR]0\f[R] and \f[CR]str.length - 1\f[R].
If the \f[CR]index\f[R] cannot be converted to the integer or no
\f[CR]index\f[R] is provided, the default is \f[CR]0\f[R], so the first
character of \f[CR]str\f[R] is returned.
.SS Return value
A string representing the character (exactly one UTF-16 code unit) at
the specified \f[CR]index\f[R].
If \f[CR]index\f[R] is out of range, \f[CR]charAt()\f[R] returns an
empty string.
.SH DESCRIPTION
Characters in a string are indexed from left to right.
The index of the first character is \f[CR]0\f[R], and the index of the
last character\[em]in a string called \f[CR]stringName\f[R] is
\f[CR]stringName.length - 1\f[R].
If the \f[CR]index\f[R] you supply is out of this range, JavaScript
returns an empty string.
.PP
If no \f[CR]index\f[R] is provided to \f[CR]charAt()\f[R], the default
is \f[CR]0\f[R].
.SH EXAMPLES
.SS Displaying characters at different locations in a string
The following example displays characters at different locations in the
string \[lq]\f[CR]Brave new world\f[R]\[rq]:
.IP
.EX
const anyString = \[dq]Brave new world\[dq];
console.log(\[ga]The character at index 0   is \[aq]${anyString.charAt()}\[aq]\[ga]);
// No index was provided, used 0 as default

console.log(\[ga]The character at index 0   is \[aq]${anyString.charAt(0)}\[aq]\[ga]);
console.log(\[ga]The character at index 1   is \[aq]${anyString.charAt(1)}\[aq]\[ga]);
console.log(\[ga]The character at index 2   is \[aq]${anyString.charAt(2)}\[aq]\[ga]);
console.log(\[ga]The character at index 3   is \[aq]${anyString.charAt(3)}\[aq]\[ga]);
console.log(\[ga]The character at index 4   is \[aq]${anyString.charAt(4)}\[aq]\[ga]);
console.log(\[ga]The character at index 999 is \[aq]${anyString.charAt(999)}\[aq]\[ga]);
.EE
.PP
These lines display the following:
.IP
.EX
The character at index 0   is \[aq]B\[aq]

The character at index 0   is \[aq]B\[aq]
The character at index 1   is \[aq]r\[aq]
The character at index 2   is \[aq]a\[aq]
The character at index 3   is \[aq]v\[aq]
The character at index 4   is \[aq]e\[aq]
The character at index 999 is \[aq]\[aq]
.EE
.SS Getting whole characters
The following provides a means of ensuring that going through a string
loop always provides a whole character, even if the string contains
characters that are not in the Basic Multi-lingual Plane.
.IP
.EX
const str = \[dq]A\[rs]uD87E\[rs]uDC04Z\[dq]; // We could also use a non-BMP character directly
for (let i = 0; i < str.length; i++) {
  let chr;
  [chr, i] = getWholeCharAndI(str, i);

  // Adapt this line at the top of each loop, passing in the whole string and
  // the current iteration and returning an array with the individual character
  // and \[aq]i\[aq] value (only changed if a surrogate pair)

  console.log(chr);
}

function getWholeCharAndI(str, i) {
  const code = str.charCodeAt(i);

  if (Number.isNaN(code)) {
    return \[dq]\[dq]; // Position not found
  }
  if (code < 0xd800 || code > 0xdfff) {
    return [str.charAt(i), i]; // Normal character, keeping \[aq]i\[aq] the same
  }

  // High surrogate (could change last hex to 0xDB7F to treat high private
  // surrogates as single characters)
  if (0xd800 <= code && code <= 0xdbff) {
    if (str.length <= i + 1) {
      throw new Error(\[dq]High surrogate without following low surrogate\[dq]);
    }
    const next = str.charCodeAt(i + 1);
    if (next < 0xdc00 || next > 0xdfff) {
      throw new Error(\[dq]High surrogate without following low surrogate\[dq]);
    }
    return [str.charAt(i) + str.charAt(i + 1), i + 1];
  }

  // Low surrogate (0xDC00 <= code && code <= 0xDFFF)
  if (i === 0) {
    throw new Error(\[dq]Low surrogate without preceding high surrogate\[dq]);
  }

  const prev = str.charCodeAt(i - 1);

  // (could change last hex to 0xDB7F to treat high private surrogates
  // as single characters)
  if (prev < 0xd800 || prev > 0xdbff) {
    throw new Error(\[dq]Low surrogate without preceding high surrogate\[dq]);
  }

  // Return the next character instead (and increment)
  return [str.charAt(i + 1), i + 1];
}
.EE
.SS Fixing charAt() to support non-Basic-Multilingual-Plane (BMP) characters
While the previous example may be more useful for programs that must
support non-BMP characters (since it does not require the caller to know
where any non-BMP character might appear), in the event that one
\f[I]does\f[R] wish, in choosing a character by index, to treat the
surrogate pairs within a string as the single characters they represent,
one can use the following:
.IP
.EX
function fixedCharAt(str, idx) {
  str = String(str);

  const surrogatePairs = /[\[rs]uD800-\[rs]uDBFF][\[rs]uDC00-\[rs]uDFFF]/g;
  while (surrogatePairs.exec(str) !== null) {
    const lastIdx = surrogatePairs.lastIndex;
    if (lastIdx - 2 < idx) {
      idx++;
    } else {
      break;
    }
  }

  if (idx >= str.length || idx < 0) {
    return \[dq]\[dq];
  }

  let ret = str.charAt(idx);

  if (
    /[\[rs]uD800-\[rs]uDBFF]/.test(ret) &&
    /[\[rs]uDC00-\[rs]uDFFF]/.test(str.charAt(idx + 1))
  ) {
    // Go one further, since one of the \[dq]characters\[dq] is part of a surrogate pair
    ret += str.charAt(idx + 1);
  }
  return ret;
}
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]String.prototype.indexOf()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.lastIndexOf()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.charCodeAt()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.codePointAt()\f[R]
.IP \[bu] 2
\f[CR]String.prototype.split()\f[R]
.IP \[bu] 2
\f[CR]String.fromCodePoint()\f[R]
.IP \[bu] 2
JavaScript has a Unicode problem \[en] Mathias
Bynens (https://mathiasbynens.be/notes/javascript-unicode)
