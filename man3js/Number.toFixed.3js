.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Number.toFixed" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]toFixed()\f[B]\f[R] method formats a number using
fixed-point notation.
.SH Syntax
.IP
.nf
\f[C]
toFixed()
toFixed(digits)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]digits\f[R] \f[I](optional)\f[R]
.RS 2
.IP \[bu] 2
The number of digits to appear after the decimal point; should be a
value between \f[V]0\f[R] and \f[V]100\f[R], inclusive.
If this argument is omitted, it is treated as \f[V]0\f[R].
.RE
.SS Return value
.PP
A string representing the given number using fixed-point notation.
.SS Exceptions
.IP \[bu] 2
\f[V]RangeError\f[R]
.RS 2
.IP \[bu] 2
Thrown if \f[V]digits\f[R] is not between \f[V]1\f[R] and \f[V]100\f[R]
(inclusive).
.RE
.IP \[bu] 2
\f[V]TypeError\f[R]
.RS 2
.IP \[bu] 2
Thrown if this method is invoked on an object that is not a
\f[V]Number\f[R].
.RE
.SH Description
.PP
The \f[V]toFixed()\f[R] method returns a string representation of
\f[V]numObj\f[R] that does not use exponential notation and has exactly
\f[V]digits\f[R] digits after the decimal place.
The number is rounded if necessary, and the fractional part is padded
with zeros if necessary so that it has the specified length.
.PP
If the absolute value of \f[V]numObj\f[R] is greater or equal to 1021,
this method uses the same algorithm as
\f[V]Number.prototype.toString()\f[R] and returns a string in
exponential notation.
\f[V]toFixed()\f[R] returns \f[V]\[dq]Infinity\[dq]\f[R],
\f[V]\[dq]NaN\[dq]\f[R], or \f[V]\[dq]-Infinity\[dq]\f[R] if the value
of \f[V]numObj\f[R] is non-finite.
.PP
The output of \f[V]toFixed()\f[R] may be more precise than
\f[V]toString()\f[R] for some values, because \f[V]toString()\f[R] only
prints enough significant digits to distinguish the number from adjacent
number values.
For example:
.IP
.nf
\f[C]
(1000000000000000128).toString(); // \[aq]1000000000000000100\[aq]
(1000000000000000128).toFixed(0); // \[aq]1000000000000000128\[aq]
\f[R]
.fi
.PP
However, choosing a \f[V]digits\f[R] precision that\[cq]s too high can
return unexpected results, because decimal fractional numbers cannot be
represented precisely in floating point.
For example:
.IP
.nf
\f[C]
(0.3).toFixed(50); // \[aq]0.29999999999999998889776975374843459576368331909180\[aq]
\f[R]
.fi
.SH Examples
.SS Using toFixed()
.IP
.nf
\f[C]
const numObj = 12345.6789;

numObj.toFixed(); // \[aq]12346\[aq]; rounding, no fractional part
numObj.toFixed(1); // \[aq]12345.7\[aq]; it rounds up
numObj.toFixed(6); // \[aq]12345.678900\[aq]; additional zeros
(1.23e20).toFixed(2); // \[aq]123000000000000000000.00\[aq]
(1.23e-10).toFixed(2); // \[aq]0.00\[aq]
(2.34).toFixed(1); // \[aq]2.3\[aq]
(2.35).toFixed(1); // \[aq]2.4\[aq]; it rounds up
(2.55).toFixed(1); // \[aq]2.5\[aq]
// it rounds down as it can\[aq]t be represented exactly by a float and the
// closest representable float is lower
(2.449999999999999999).toFixed(1); // \[aq]2.5\[aq]
// it rounds up as it\[aq]s less than NUMBER.EPSILON away from 2.45.
// This literal actually encodes the same number value as 2.45

(6.02 * 10 ** 23).toFixed(50); // 6.019999999999999e+23; large numbers still use exponential notation
\f[R]
.fi
.SS Using toFixed() with negative numbers
.PP
Because member access has higher precedence than unary minus, you need
to group the negative number expression to get a string.
.IP
.nf
\f[C]
-2.34.toFixed(1); // -2.3, a number
(-2.34).toFixed(1); // \[aq]-2.3\[aq]
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]Number.prototype.toExponential()\f[R]
.IP \[bu] 2
\f[V]Number.prototype.toPrecision()\f[R]
.IP \[bu] 2
\f[V]Number.prototype.toString()\f[R]
.IP \[bu] 2
\f[V]Number.EPSILON\f[R]
