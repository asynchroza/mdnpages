.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "CanvasPattern.setTransform" "JS" "April 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
CanvasPattern.setTransform \- CanvasPattern: setTransform() method
.SH SYNOPSIS
The \f[B]\f[CB]CanvasPattern.setTransform()\f[B]\f[R] method uses a
\f[CR]DOMMatrix\f[R] object as the pattern\[cq]s transformation matrix
and invokes it on the pattern.
.SH SYNTAX
.IP
.EX
setTransform(matrix)
.EE
.SS Parameters
.TP
\f[B]matrix\f[R]
A \f[CR]DOMMatrix\f[R] to use as the pattern\[cq]s transformation
matrix.
.SS Return value
None (\f[CR]undefined\f[R]).
.SH EXAMPLES
.SS Using the \f[CR]setTransform\f[R] method
This is just a simple code snippet which uses the
\f[CR]setTransform\f[R] method to create a \f[CR]CanvasPattern\f[R] with
the specified pattern transformation from a \f[CR]DOMMatrix\f[R].
The pattern gets applied if you set it as the current
\f[CR]fillStyle\f[R] and gets drawn onto the canvas when using the
\f[CR]fillRect()\f[R] method, for example.
.SS HTML
.IP
.EX
<canvas id=\[dq]canvas\[dq]></canvas>
.EE
.SS JavaScript
.IP
.EX
const canvas = document.getElementById(\[dq]canvas\[dq]);
const ctx = canvas.getContext(\[dq]2d\[dq]);

const matrix = new DOMMatrix([1, 0.2, 0.8, 1, 0, 0]);

const img = new Image();
img.src = \[dq]canvas_createpattern.png\[dq];

img.onload = () => {
  const pattern = ctx.createPattern(img, \[dq]repeat\[dq]);
  pattern.setTransform(matrix.rotate(\-45).scale(1.5));
  ctx.fillStyle = pattern;
  ctx.fillRect(0, 0, 400, 400);
};
.EE
.SS Editable demo
Here\[cq]s an editable demo of the code snippet above.
Try changing the argument to \f[CR]SetTransform()\f[R] to see the effect
it had.
.PP
\f[CR]html hidden <canvas id=\[dq]canvas\[dq] width=\[dq]400\[dq] height=\[dq]200\[dq] class=\[dq]playable\-canvas\[dq]></canvas> <div class=\[dq]playable\-buttons\[dq]>   <input id=\[dq]edit\[dq] type=\[dq]button\[dq] value=\[dq]Edit\[dq] />   <input id=\[dq]reset\[dq] type=\[dq]button\[dq] value=\[dq]Reset\[dq] /> </div> <textarea id=\[dq]code\[dq] class=\[dq]playable\-code\[dq] style=\[dq]height:120px\[dq]> const img = new Image(); img.src = \[aq]canvas_createpattern.png\[aq]; img.onload = () => {   const pattern = ctx.createPattern(img, \[aq]repeat\[aq]);   pattern.setTransform(matrix.rotate(\-45).scale(1.5));   ctx.fillStyle = pattern;   ctx.fillRect(0, 0, 400, 400); }; </textarea>\f[R]
.PP
\[ga]\[ga]\[ga]js hidden const canvas =
document.getElementById(\[lq]canvas\[rq]); const ctx =
canvas.getContext(\[lq]2d\[rq]); const textarea =
document.getElementById(\[lq]code\[rq]); const reset =
document.getElementById(\[lq]reset\[rq]); const edit =
document.getElementById(\[lq]edit\[rq]); const code = textarea.value;
.PP
const matrix = new DOMMatrix([1, 0.2, 0.8, 1, 0, 0]);
.PP
function drawCanvas() { ctx.clearRect(0, 0, canvas.width,
canvas.height); eval(textarea.value); }
.PP
reset.addEventListener(\[lq]click\[rq], () => { textarea.value = code;
drawCanvas(); });
.PP
edit.addEventListener(\[lq]click\[rq], () => { textarea.focus(); });
.PP
textarea.addEventListener(\[lq]input\[rq], drawCanvas);
window.addEventListener(\[lq]load\[rq], drawCanvas); \[ga]\[ga]\[ga]
.SH SEE ALSO
.IP \[bu] 2
The interface defining this method: \f[CR]CanvasPattern\f[R]
.IP \[bu] 2
\f[CR]DOMMatrix\f[R]
