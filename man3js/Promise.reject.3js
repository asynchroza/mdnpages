.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Promise.reject" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]Promise.reject()\f[B]\f[R] static method returns a
\f[V]Promise\f[R] object that is rejected with a given reason.
.SH Syntax
.IP
.nf
\f[C]
Promise.reject(reason)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]reason\f[R]
.RS 2
.IP \[bu] 2
Reason why this \f[V]Promise\f[R] rejected.
.RE
.SS Return value
.PP
A \f[V]Promise\f[R] that is rejected with the given reason.
.SH Description
.PP
The static \f[V]Promise.reject\f[R] function returns a \f[V]Promise\f[R]
that is rejected.
For debugging purposes and selective error catching, it is useful to
make \f[V]reason\f[R] an \f[V]instanceof\f[R] \f[V]Error\f[R].
.PP
\f[V]Promise.reject()\f[R] is generic and supports subclassing, which
means it can be called on subclasses of \f[V]Promise\f[R], and the
result will be a promise of the subclass type.
To do so, the subclass\[cq]s constructor must implement the same
signature as the \f[V]Promise()\f[R] constructor \[em] accepting a
single \f[V]executor\f[R] function that can be called with the
\f[V]resolve\f[R] and \f[V]reject\f[R] callbacks as parameters.
\f[V]Promise.reject()\f[R] is essentially a shorthand for
\f[V]new Promise((resolve, reject) => reject(reason))\f[R].
.PP
Unlike \f[V]Promise.resolve()\f[R], \f[V]Promise.reject()\f[R] always
wraps \f[V]reason\f[R] in a new \f[V]Promise\f[R] object, even when
\f[V]reason\f[R] is already a \f[V]Promise\f[R].
.SH Examples
.SS Using the static Promise.reject() method
.IP
.nf
\f[C]
Promise.reject(new Error(\[dq]fail\[dq])).then(
  () => {
    // not called
  },
  (error) => {
    console.error(error); // Stacktrace
  },
);
\f[R]
.fi
.SS Rejecting with a promise
.PP
Unlike \f[V]Promise.resolve\f[R], the \f[V]Promise.reject\f[R] method
does not reuse existing \f[V]Promise\f[R] instances.
It always returns a new \f[V]Promise\f[R] instance that wraps
\f[V]reason\f[R].
.IP
.nf
\f[C]
const p = Promise.resolve(1);
const rejected = Promise.reject(p);
console.log(rejected === p); // false
rejected.catch((v) => {
  console.log(v === p); // true
});
\f[R]
.fi
.SS Calling reject() on a non-Promise constructor
.PP
\f[V]Promise.reject()\f[R] is a generic method.
It can be called on any constructor that implements the same signature
as the \f[V]Promise()\f[R] constructor.
For example, we can call it on a constructor that passes it
\f[V]console.log\f[R] as \f[V]reject\f[R]:
.IP
.nf
\f[C]
class NotPromise {
  constructor(executor) {
    // The \[dq]resolve\[dq] and \[dq]reject\[dq] functions behave nothing like the
    // native promise\[aq]s, but Promise.reject() calls them in the same way.
    executor(
      (value) => console.log(\[dq]Resolved\[dq], value),
      (reason) => console.log(\[dq]Rejected\[dq], reason),
    );
  }
}

Promise.reject.call(NotPromise, \[dq]foo\[dq]); // Logs \[dq]Rejected foo\[dq]
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]Promise\f[R]
