.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "Boolean" "JS" "August 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Boolean \- Boolean
.SH SYNOPSIS
The \f[B]\f[CB]Boolean\f[B]\f[R] object represents a truth value:
\f[CR]true\f[R] or \f[CR]false\f[R].
.SH DESCRIPTION
.SS Boolean primitives and Boolean objects
Do not confuse the primitive \f[CR]Boolean\f[R] values \f[CR]true\f[R]
and \f[CR]false\f[R] with the \f[CR]true\f[R] and \f[CR]false\f[R]
values of the \f[CR]Boolean\f[R] object.
.PP
\f[B]Any\f[R] object, including a \f[CR]Boolean\f[R] object whose value
is \f[CR]false\f[R], evaluates to \f[CR]true\f[R] when passed to a
conditional statement.
For example, the condition in the following \f[CR]if\f[R] statement
evaluates to \f[CR]true\f[R]:
.IP
.EX
const x = new Boolean(false);
if (x) {
  // this code is executed
}
.EE
.PP
This behavior does not apply to \f[CR]Boolean\f[R] primitives.
For example, the condition in the following \f[CR]if\f[R] statement
evaluates to \f[CR]false\f[R]:
.IP
.EX
const x = false;
if (x) {
  // this code is not executed
}
.EE
.PP
Do not use the \f[CR]Boolean()\f[R] constructor with \f[CR]new\f[R] to
convert a non\-boolean value to a boolean value \[em] use
\f[CR]Boolean\f[R] as a function or a double NOT instead:
.IP
.EX
const good = Boolean(expression); // use this
const good2 = !!expression; // or this
const bad = new Boolean(expression); // don\[aq]t use this!
.EE
.PP
If you specify any object, including a \f[CR]Boolean\f[R] object whose
value is \f[CR]false\f[R], as the initial value of a \f[CR]Boolean\f[R]
object, the new \f[CR]Boolean\f[R] object has a value of
\f[CR]true\f[R].
.IP
.EX
const myFalse = new Boolean(false); // initial value of false
const g = Boolean(myFalse); // initial value of true
const myString = new String(\[dq]Hello\[dq]); // string object
const s = Boolean(myString); // initial value of true
.EE
.RS
.PP
\f[B]Warning:\f[R] You should rarely find yourself using
\f[CR]Boolean\f[R] as a constructor.
.RE
.SS Boolean coercion
Many built\-in operations that expect booleans first coerce their
arguments to booleans.
\c
.UR
https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toboolean
The operation
.UE \c
\ can be summarized as follows:
.IP \[bu] 2
Booleans are returned as\-is.
.IP \[bu] 2
\f[CR]undefined\f[R] turns into \f[CR]false\f[R].
.IP \[bu] 2
\f[CR]null\f[R] turns into \f[CR]false\f[R].
.IP \[bu] 2
\f[CR]0\f[R], \f[CR]\-0\f[R], and \f[CR]NaN\f[R] turn into
\f[CR]false\f[R]; other numbers turn into \f[CR]true\f[R].
.IP \[bu] 2
\f[CR]0n\f[R] turns into \f[CR]false\f[R]; other BigInts turn into
\f[CR]true\f[R].
.IP \[bu] 2
The empty string \f[CR]\[dq]\[dq]\f[R] turns into \f[CR]false\f[R];
other strings turn into \f[CR]true\f[R].
.IP \[bu] 2
Symbols turn into \f[CR]true\f[R].
.IP \[bu] 2
All objects become \f[CR]true\f[R].
.RS
.PP
\f[B]Note:\f[R] A legacy behavior makes \f[CR]document.all\f[R] return
\f[CR]false\f[R] when used as a boolean, despite it being an object.
This property is legacy and non\-standard and should not be used.
.RE
.RS
.PP
\f[B]Note:\f[R] Unlike other type conversions like string coercion or
number coercion, boolean coercion does not attempt to convert objects to
primitives.
.RE
.PP
In other words, there are only a handful of values that get coerced to
\f[CR]false\f[R] \[em] these are called falsy values.
All other values are called truthy values.
A value\[cq]s truthiness is important when used with logical operators,
conditional statements, or any boolean context.
.PP
There are two ways to achieve the same effect in JavaScript.
.IP \[bu] 2
Double NOT: \f[CR]!!x\f[R] negates \f[CR]x\f[R] twice, which converts
\f[CR]x\f[R] to a boolean using the same algorithm as above.
.IP \[bu] 2
The \f[CR]Boolean()\f[R] function: \f[CR]Boolean(x)\f[R] uses the same
algorithm as above to convert \f[CR]x\f[R].
.PP
Note that truthiness is not the same as being loosely equal to
\f[CR]true\f[R] or \f[CR]false\f[R].
.IP
.EX
if ([]) {
  console.log(\[dq][] is truthy\[dq]);
}
if ([] == false) {
  console.log(\[dq][] == false\[dq]);
}
// [] is truthy
// [] == false
.EE
.PP
\f[CR][]\f[R] is truthy, but it\[cq]s also loosely equal to
\f[CR]false\f[R].
It\[cq]s truthy, because all objects are truthy.
However, when comparing with \f[CR]false\f[R], which is a primitive,
\f[CR][]\f[R] is also converted to a primitive, which is
\f[CR]\[dq]\[dq]\f[R] via \f[CR]Array.prototype.toString()\f[R].
Comparing strings and booleans results in both being converted to
numbers, and they both become \f[CR]0\f[R], so \f[CR][] == false\f[R] is
\f[CR]true\f[R].
In general, falsiness and \f[CR]== false\f[R] differ in the following
cases:
.IP \[bu] 2
\f[CR]NaN\f[R], \f[CR]undefined\f[R], and \f[CR]null\f[R] are falsy but
not loosely equal to \f[CR]false\f[R].
.IP \[bu] 2
\f[CR]\[dq]0\[dq]\f[R] (and other string literals that are not
\f[CR]\[dq]\[dq]\f[R] but get coerced to 0) is truthy but loosely equal
to \f[CR]false\f[R].
.IP \[bu] 2
Objects are always truthy, but their primitive representation may be
loosely equal to \f[CR]false\f[R].
.PP
Truthy values are even more unlikely to be loosely equal to
\f[CR]true\f[R].
All values are either truthy or falsy, but most values are loosely equal
to neither \f[CR]true\f[R] nor \f[CR]false\f[R].
.SH CONSTRUCTOR
.TP
\f[B]Boolean()\f[R]
Creates a new \f[CR]Boolean\f[R] object.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]Boolean.prototype\f[R] and shared
by all \f[CR]Boolean\f[R] instances.
.TP
\f[B]Boolean.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]Boolean\f[R] instances, the initial value is the
\f[CR]Boolean\f[R] constructor.
.SH INSTANCE METHODS
.TP
\f[B]Boolean.prototype.toString()\f[R]
Returns a string of either \f[CR]true\f[R] or \f[CR]false\f[R] depending
upon the value of the object.
Overrides the \f[CR]Object.prototype.toString()\f[R] method.
.TP
\f[B]Boolean.prototype.valueOf()\f[R]
Returns the primitive value of the \f[CR]Boolean\f[R] object.
Overrides the \f[CR]Object.prototype.valueOf()\f[R] method.
.SH EXAMPLES
.SS Creating Boolean objects with an initial value of false
.IP
.EX
const bNoParam = new Boolean();
const bZero = new Boolean(0);
const bNull = new Boolean(null);
const bEmptyString = new Boolean(\[dq]\[dq]);
const bfalse = new Boolean(false);
.EE
.SS Creating Boolean objects with an initial value of true
.IP
.EX
const btrue = new Boolean(true);
const btrueString = new Boolean(\[dq]true\[dq]);
const bfalseString = new Boolean(\[dq]false\[dq]);
const bSuLin = new Boolean(\[dq]Su Lin\[dq]);
const bArrayProto = new Boolean([]);
const bObjProto = new Boolean({});
.EE
.SH SEE ALSO
.IP \[bu] 2
Boolean
.IP \[bu] 2
Boolean primitives
.IP \[bu] 2
\c
.UR https://en.wikipedia.org/wiki/Boolean_data_type
Boolean data type
.UE \c
\ on Wikipedia
