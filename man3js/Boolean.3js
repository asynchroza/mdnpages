.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Boolean" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Boolean - Boolean
.SH SYNOPSIS
.PP
The \f[B]\f[VB]Boolean\f[B]\f[R] object represents a truth value:
\f[V]true\f[R] or \f[V]false\f[R].
.SH DESCRIPTION
.SS Boolean primitives and Boolean objects
.PP
Do not confuse the primitive \f[V]Boolean\f[R] values \f[V]true\f[R] and
\f[V]false\f[R] with the \f[V]true\f[R] and \f[V]false\f[R] values of
the \f[V]Boolean\f[R] object.
.PP
\f[B]Any\f[R] object, including a \f[V]Boolean\f[R] object whose value
is \f[V]false\f[R], evaluates to \f[V]true\f[R] when passed to a
conditional statement.
For example, the condition in the following \f[V]if\f[R] statement
evaluates to \f[V]true\f[R]:
.IP
.nf
\f[C]
const x = new Boolean(false);
if (x) {
  // this code is executed
}
\f[R]
.fi
.PP
This behavior does not apply to \f[V]Boolean\f[R] primitives.
For example, the condition in the following \f[V]if\f[R] statement
evaluates to \f[V]false\f[R]:
.IP
.nf
\f[C]
const x = false;
if (x) {
  // this code is not executed
}
\f[R]
.fi
.PP
Do not use the \f[V]Boolean()\f[R] constructor with \f[V]new\f[R] to
convert a non-boolean value to a boolean value \[em] use
\f[V]Boolean\f[R] as a function or a double NOT instead:
.IP
.nf
\f[C]
const good = Boolean(expression); // use this
const good2 = !!expression; // or this
const bad = new Boolean(expression); // don\[aq]t use this!
\f[R]
.fi
.PP
If you specify any object, including a \f[V]Boolean\f[R] object whose
value is \f[V]false\f[R], as the initial value of a \f[V]Boolean\f[R]
object, the new \f[V]Boolean\f[R] object has a value of \f[V]true\f[R].
.IP
.nf
\f[C]
const myFalse = new Boolean(false); // initial value of false
const g = Boolean(myFalse); // initial value of true
const myString = new String(\[dq]Hello\[dq]); // string object
const s = Boolean(myString); // initial value of true
\f[R]
.fi
.RS
.PP
\f[B]Warning:\f[R] You should rarely find yourself using
\f[V]Boolean\f[R] as a constructor.
.RE
.SS Boolean coercion
.PP
Many built-in operations that expect booleans first coerce their
arguments to booleans.
The operation (https://tc39.es/ecma262/#sec-tostring) can be summarized
as follows:
.IP \[bu] 2
Booleans are returned as-is.
.IP \[bu] 2
\f[V]undefined\f[R] turns into \f[V]false\f[R].
.IP \[bu] 2
\f[V]null\f[R] turns into \f[V]false\f[R].
.IP \[bu] 2
\f[V]0\f[R], \f[V]-0\f[R], and \f[V]NaN\f[R] turn into \f[V]false\f[R];
other numbers turn into \f[V]true\f[R].
.IP \[bu] 2
\f[V]0n\f[R] turns into \f[V]false\f[R]; other BigInts turn into
\f[V]true\f[R].
.IP \[bu] 2
Symbols turn into \f[V]true\f[R].
.IP \[bu] 2
All objects become \f[V]true\f[R].
.RS
.PP
\f[B]Note:\f[R] A legacy behavior makes \f[V]document.all\f[R] return
\f[V]false\f[R] when used as a boolean, despite it being an object.
This property is legacy and non-standard and should not be used.
.RE
.RS
.PP
\f[B]Note:\f[R] Unlike other type conversions like string coercion or
number coercion, boolean coercion does not attempt to convert objects to
primitives.
.RE
.PP
In other words, there are only a handful of values that get coerced to
\f[V]false\f[R] \[em] these are called falsy values.
All other values are called truthy values.
A value\[cq]s truthiness is important when used with logical operators,
conditional statements, or any boolean context.
.PP
There are two ways to achieve the same effect in JavaScript.
.IP \[bu] 2
Double NOT: \f[V]!!x\f[R] negates \f[V]x\f[R] twice, which converts
\f[V]x\f[R] to a boolean using the same algorithm as above.
.IP \[bu] 2
The \f[V]Boolean()\f[R] function: \f[V]Boolean(x)\f[R] uses the same
algorithm as above to convert \f[V]x\f[R].
.PP
Note that truthiness is not the same as being loosely equal to
\f[V]true\f[R] or \f[V]false\f[R].
.IP
.nf
\f[C]
if ([]) {
  console.log(\[dq][] is truthy\[dq]);
}
if ([] == false) {
  console.log(\[dq][] == false\[dq]);
}
// [] is truthy
// [] == false
\f[R]
.fi
.PP
\f[V][]\f[R] is truthy, but it\[cq]s also loosely equal to
\f[V]false\f[R].
It\[cq]s truthy, because all objects are truthy.
However, when comparing with \f[V]false\f[R], which is a primitive,
\f[V][]\f[R] is also converted to a primitive, which is
\f[V]\[dq]\[dq]\f[R] via \f[V]Array.prototype.toString()\f[R].
Comparing strings and booleans results in both being converted to
numbers, and they both become \f[V]0\f[R], so \f[V][] == false\f[R] is
\f[V]true\f[R].
In general, falsiness and \f[V]== false\f[R] differ in the following
cases:
.IP \[bu] 2
\f[V]NaN\f[R], \f[V]undefined\f[R], and \f[V]null\f[R] are falsy but not
loosely equal to \f[V]false\f[R].
.IP \[bu] 2
\f[V]\[dq]0\[dq]\f[R] (and other string literals that are not
\f[V]\[dq]\[dq]\f[R] but get coerced to 0) is truthy but loosely equal
to \f[V]false\f[R].
.IP \[bu] 2
Objects are always truthy, but their primitive representation may be
loosely equal to \f[V]false\f[R].
.PP
Truthy values are even more unlikely to be loosely equal to
\f[V]true\f[R].
All values are either truthy or falsy, but most values are loosely equal
to neither \f[V]true\f[R] nor \f[V]false\f[R].
.SH CONSTRUCTOR
.TP
\f[B]Boolean()\f[R]
Creates a new \f[V]Boolean\f[R] object.
.SH INSTANCE PROPERTIES
.PP
These properties are defined on \f[V]Boolean.prototype\f[R] and shared
by all \f[V]Boolean\f[R] instances.
.TP
\f[B]Boolean.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[V]Boolean\f[R] instances, the initial value is the
\f[V]Boolean\f[R] constructor.
.SH INSTANCE METHODS
.TP
\f[B]Boolean.prototype.toString()\f[R]
Returns a string of either \f[V]true\f[R] or \f[V]false\f[R] depending
upon the value of the object.
Overrides the \f[V]Object.prototype.toString()\f[R] method.
.TP
\f[B]Boolean.prototype.valueOf()\f[R]
Returns the primitive value of the \f[V]Boolean\f[R] object.
Overrides the \f[V]Object.prototype.valueOf()\f[R] method.
.SH EXAMPLES
.SS Creating Boolean objects with an initial value of false
.IP
.nf
\f[C]
const bNoParam = new Boolean();
const bZero = new Boolean(0);
const bNull = new Boolean(null);
const bEmptyString = new Boolean(\[dq]\[dq]);
const bfalse = new Boolean(false);
\f[R]
.fi
.SS Creating Boolean objects with an initial value of true
.IP
.nf
\f[C]
const btrue = new Boolean(true);
const btrueString = new Boolean(\[dq]true\[dq]);
const bfalseString = new Boolean(\[dq]false\[dq]);
const bSuLin = new Boolean(\[dq]Su Lin\[dq]);
const bArrayProto = new Boolean([]);
const bObjProto = new Boolean({});
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Boolean
.IP \[bu] 2
Boolean primitives
.IP \[bu] 2
Boolean data type
(Wikipedia) (https://en.wikipedia.org/wiki/Boolean_data_type)
