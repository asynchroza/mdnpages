.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "String.charCodeAt" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]charCodeAt()\f[B]\f[R] method returns an integer between
\f[V]0\f[R] and \f[V]65535\f[R] representing the UTF-16 code unit at the
given index.
.PP
The UTF-16 code unit matches the Unicode code point for code points
which can be represented in a single UTF-16 code unit.
If the Unicode code point cannot be represented in a single UTF-16 code
unit (because its value is greater than \f[V]0xFFFF\f[R]) then the code
unit returned will be \f[I]the first part of a surrogate pair\f[R] for
the code point.
If you want the entire code point value, use \f[V]codePointAt()\f[R].
.SH Syntax
.IP
.nf
\f[C]
charCodeAt(index)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]index\f[R]
.RS 2
.IP \[bu] 2
An integer greater than or equal to \f[V]0\f[R] and less than the
\f[V]length\f[R] of the string.
If \f[V]index\f[R] is not a number, it defaults to \f[V]0\f[R].
.RE
.SS Return value
.PP
A number representing the UTF-16 code unit value of the character at the
given \f[V]index\f[R].
If \f[V]index\f[R] is out of range, \f[V]charCodeAt()\f[R] returns
\f[V]NaN\f[R].
.SH Description
.PP
Unicode code points range from \f[V]0\f[R] to \f[V]1114111\f[R]
(\f[V]0x10FFFF\f[R]).
The first 128 Unicode code points are a direct match of the ASCII
character encoding.
(For information on Unicode, see UTF-16 characters, Unicode code points,
and grapheme clusters.)
.RS
.PP
\f[B]Note:\f[R] \f[V]charCodeAt()\f[R] will always return a value that
is less than \f[V]65536\f[R].
This is because the higher code points are represented by \f[I]a
pair\f[R] of (lower valued) \[lq]surrogate\[rq] pseudo-characters which
are used to comprise the real character.
.PP
Because of this, in order to examine (or reproduce) the full character
for individual character values of \f[V]65536\f[R] or greater, for such
characters, it is necessary to retrieve not only
\f[V]charCodeAt(i)\f[R], but also \f[V]charCodeAt(i+1)\f[R] (as if
manipulating a string with two letters), or to use
\f[V]codePointAt(i)\f[R] instead.
See examples 2 and 3 (below).
.RE
.PP
\f[V]charCodeAt()\f[R] returns \f[V]NaN\f[R] if the given index is less
than \f[V]0\f[R], or if it is equal to or greater than the
\f[V]length\f[R] of the string.
.PP
Backward compatibility: In historic versions (like JavaScript 1.2) the
\f[V]charCodeAt()\f[R] method returns a number indicating the
ISO-Latin-1 codeset value of the character at the given index.
The ISO-Latin-1 codeset ranges from \f[V]0\f[R] to \f[V]255\f[R].
The first \f[V]0\f[R] to \f[V]127\f[R] are a direct match of the ASCII
character set.
.SH Examples
.SS Using charCodeAt()
.PP
The following example returns \f[V]65\f[R], the Unicode value for A.
.IP
.nf
\f[C]
\[dq]ABC\[dq].charCodeAt(0); // returns 65
\f[R]
.fi
.SS Fixing charCodeAt() to handle non-Basic-Multilingual-Plane characters if their presence earlier in the string is unknown
.PP
This version might be used in for loops and the like when it is unknown
whether non-BMP characters exist before the specified index position.
.IP
.nf
\f[C]
function fixedCharCodeAt(str, idx) {
  // ex. fixedCharCodeAt(\[aq]\[rs]uD800\[rs]uDC00\[aq], 0); // 65536
  // ex. fixedCharCodeAt(\[aq]\[rs]uD800\[rs]uDC00\[aq], 1); // false
  idx = idx || 0;
  const code = str.charCodeAt(idx);
  let hi, low;

  // High surrogate (could change last hex to 0xDB7F
  // to treat high private surrogates
  // as single characters)
  if (0xd800 <= code && code <= 0xdbff) {
    hi = code;
    low = str.charCodeAt(idx + 1);
    if (isNaN(low)) {
      throw new Error(
        \[dq]High surrogate not followed by low surrogate in fixedCharCodeAt()\[dq],
      );
    }
    return (hi - 0xd800) * 0x400 + (low - 0xdc00) + 0x10000;
  }
  if (0xdc00 <= code && code <= 0xdfff) {
    // Low surrogate
    // We return false to allow loops to skip
    // this iteration since should have already handled
    // high surrogate above in the previous iteration
    return false;
    // hi = str.charCodeAt(idx - 1);
    // low = code;
    // return ((hi - 0xD800) * 0x400) +
    //   (low - 0xDC00) + 0x10000;
  }
  return code;
}
\f[R]
.fi
.SS Fixing charCodeAt() to handle non-Basic-Multilingual-Plane characters if their presence earlier in the string is known
.IP
.nf
\f[C]
function knownCharCodeAt(str, idx) {
  str += \[dq]\[dq];
  const end = str.length;

  const surrogatePairs = /[\[rs]uD800-\[rs]uDBFF][\[rs]uDC00-\[rs]uDFFF]/g;
  while (surrogatePairs.exec(str) !== null) {
    const li = surrogatePairs.lastIndex;
    if (li - 2 < idx) {
      idx++;
    } else {
      break;
    }
  }

  if (idx >= end || idx < 0) {
    return NaN;
  }

  const code = str.charCodeAt(idx);

  if (0xd800 <= code && code <= 0xdbff) {
    const hi = code;
    const low = str.charCodeAt(idx + 1);
    // Go one further, since one of the \[dq]characters\[dq]
    // is part of a surrogate pair
    return (hi - 0xd800) * 0x400 + (low - 0xdc00) + 0x10000;
  }
  return code;
}
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]String.fromCharCode()\f[R]
.IP \[bu] 2
\f[V]String.prototype.charAt()\f[R]
.IP \[bu] 2
\f[V]String.fromCodePoint()\f[R]
.IP \[bu] 2
\f[V]String.prototype.codePointAt()\f[R]
