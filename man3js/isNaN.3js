.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "isNaN" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
isNaN - isNaN()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]isNaN()\f[B]\f[R] function determines whether a value is
\f[V]NaN\f[R] when converted to a number.
Because coercion inside the \f[V]isNaN()\f[R] function can be
surprising, you may alternatively want to use \f[V]Number.isNaN()\f[R].
.SH SYNTAX
.IP
.nf
\f[C]
isNaN(value)
\f[R]
.fi
.SS Parameters
.TP
\f[B]value\f[R]
The value to be tested.
.SS Return value
.PP
\f[V]true\f[R] if the given value is \f[V]NaN\f[R] after being converted
to a number; otherwise, \f[V]false\f[R].
.SH DESCRIPTION
.PP
\f[V]isNaN()\f[R] is a function property of the global object.
.PP
For number values, \f[V]isNaN()\f[R] tests if the number is the value
\f[V]NaN\f[R].
When the argument to the \f[V]isNaN()\f[R] function is not of type
Number, the value is first coerced to a number, and the resulting value
is then compared against \f[V]NaN\f[R].
.PP
This behavior of \f[V]isNaN()\f[R] for non-numeric arguments can be
confusing!
For example, an empty string is coerced to 0, while a boolean is coerced
to 0 or 1; both values are intuitively \[lq]not numbers\[rq], but they
don\[cq]t evaluate to \f[V]NaN\f[R], so \f[V]isNaN()\f[R] returns
\f[V]false\f[R].
Therefore, \f[V]isNaN()\f[R] answers neither the question \[lq]is the
input the floating point \f[V]NaN\f[R] value\[rq] nor the question
\[lq]is the input not a number\[rq].
.PP
\f[V]Number.isNaN()\f[R] is a more reliable way to test whether a value
is the number value \f[V]NaN\f[R] or not.
Alternatively, the expression \f[V]x !== x\f[R] can be used, and neither
of the solutions is subject to the false positives that make the global
\f[V]isNaN()\f[R] unreliable.
To test if a value is a number, use
\f[V]typeof x === \[dq]number\[dq]\f[R].
.PP
The \f[V]isNaN()\f[R] function answers the question \[lq]is the input
functionally equivalent to \f[V]NaN\f[R] when used in a number
context\[rq].
If \f[V]isNaN(x)\f[R] returns \f[V]false\f[R], you can use \f[V]x\f[R]
in an arithmetic expression as if it\[cq]s a valid number that\[cq]s not
\f[V]NaN\f[R].
If \f[V]isNaN(x)\f[R] returns \f[V]true\f[R], \f[V]x\f[R] will get
coerced to \f[V]NaN\f[R] and make most arithmetic expressions return
\f[V]NaN\f[R] (because \f[V]NaN\f[R] propagates).
You can use this, for example, to test whether an argument to a function
is arithmetically processable (usable \[lq]like\[rq] a number), and
handle values that are not number-like by throwing an error, providing a
default value, etc.
This way, you can have a function that makes use of the full versatility
JavaScript provides by implicitly converting values depending on
context.
.RS
.PP
\f[B]Note:\f[R] The \f[V]+\f[R] operator performs both number addition
and string concatenation.
Therefore, even if \f[V]isNaN()\f[R] returns \f[V]false\f[R] for both
operands, the \f[V]+\f[R] operator may still return a string, because
it\[cq]s not used as an arithmetic operator.
For example, \f[V]isNaN(\[dq]1\[dq])\f[R] returns \f[V]false\f[R], but
\f[V]\[dq]1\[dq] + 1\f[R] returns \f[V]\[dq]11\[dq]\f[R].
To be sure that you are working with numbers, coerce the value to a
number and use \f[V]Number.isNaN()\f[R] to test the result.
.RE
.SH EXAMPLES
.PP
Note how \f[V]isNaN()\f[R] returns \f[V]true\f[R] for values that are
not the value \f[V]NaN\f[R] but are not numbers either:
.IP
.nf
\f[C]
isNaN(NaN); // true
isNaN(undefined); // true
isNaN({}); // true

isNaN(true); // false
isNaN(null); // false
isNaN(37); // false

// Strings
isNaN(\[dq]37\[dq]); // false: \[dq]37\[dq] is converted to the number 37 which is not NaN
isNaN(\[dq]37.37\[dq]); // false: \[dq]37.37\[dq] is converted to the number 37.37 which is not NaN
isNaN(\[dq]37,5\[dq]); // true
isNaN(\[dq]123ABC\[dq]); // true: Number(\[dq]123ABC\[dq]) is NaN
isNaN(\[dq]\[dq]); // false: the empty string is converted to 0 which is not NaN
isNaN(\[dq] \[dq]); // false: a string with spaces is converted to 0 which is not NaN

// Dates
isNaN(new Date()); // false; Date objects can be converted to a number (timestamp)
isNaN(new Date().toString()); // true; the string representation of a Date object cannot be parsed as a number
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
\f[V]NaN\f[R]
.IP \[bu] 2
\f[V]Number.isNaN()\f[R]
