.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "MediaDevices.devicechange_event" "JS" "July 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
MediaDevices.devicechange_event \- MediaDevices: devicechange event
.SH SYNOPSIS
A \f[CR]devicechange\f[R] event is sent to a \f[CR]MediaDevices\f[R]
instance whenever a media device such as a camera, microphone, or
speaker is connected to or removed from the system.
.PP
This event is not cancelable and does not bubble.
.SH SYNTAX
Use the event name in methods like \f[CR]addEventListener()\f[R], or set
an event handler property.
.IP
.EX
addEventListener(\[dq]devicechange\[dq], (event) => {});

ondevicechange = (event) => {};
.EE
.SH EVENT TYPE
A generic \f[CR]Event\f[R].
.SH EXAMPLE
In this example, we create a function called
\f[CR]updateDeviceList()\f[R], which is called once when
\f[CR]MediaDevices.getUserMedia()\f[R] successfully obtains a stream,
and then is called any time the device list changes.
It displays in the browser window two lists: one of audio devices and
one of video devices, with both the device\[cq]s label (name) and
whether it\[cq]s an input or an output device.
Because the example provides a handler for the \f[CR]devicechange\f[R]
event, the list is refreshed any time a media device is attached to or
removed from the device running the sample.
\[ga]\[ga]\[ga]html hidden
Click the start button below to begin the demonstration.
Start
.PP
Audio devices:
Video devices:
.IP
.EX

\[ga]\[ga]\[ga]css hidden
body {
  font:
    14px \[dq]Open Sans\[dq],
    \[dq]Arial\[dq],
    sans\-serif;
}

video {
  margin\-top: 20px;
  border: 1px solid black;
}

\&.button {
  cursor: pointer;
  width: 160px;
  border: 1px solid black;
  font\-size: 16px;
  text\-align: center;
  padding\-top: 2px;
  padding\-bottom: 4px;
  color: white;
  background\-color: darkgreen;
}

h2 {
  margin\-bottom: 4px;
}

\&.left {
  float: left;
  width: 48%;
  margin\-right: 2%;
}

\&.right {
  float: right;
  width: 48%;
  margin\-left: 2%;
}

\&.deviceList {
  border: 1px solid black;
  list\-style\-type: none;
  margin\-top: 2px;
  padding: 6px;
}
.EE
.PP
\[ga]\[ga]\[ga]js hidden // UI elements const videoElement =
document.querySelector(\[lq]#video\[rq]); const logElement =
document.querySelector(\[lq]output\[rq]); const startButton =
document.querySelector(\[lq]#startButton\[rq]);
.PP
function log(msg) { logElement.innerHTML += \f[CR]${msg}<br>\f[R]; }
.PP
startButton.addEventListener( \[lq]click\[rq], () => { const constraints
= { video: { width: 160, height: 120, frameRate: 30, }, audio: {
sampleRate: 44100, sampleSize: 16, volume: 0.25, }, };
.IP
.EX
navigator.mediaDevices
  .getUserMedia(constraints)
  .then((stream) => {
    videoElement.srcObject = stream;
    updateDeviceList();
  })
  .catch((err) => {
    log(\[ga]${err.name}: ${err.message}\[ga]);
  });
.EE
.PP
}, false, );
.IP
.EX

We set up global variables that contain references to the \[ga]<ul>\[ga]
elements that are used to list the audio and video devices:

\[ga]\[ga]\[ga]js
const audioList = document.getElementById(\[dq]audioList\[dq]);
const videoList = document.getElementById(\[dq]videoList\[dq]);
.EE
.SS Getting and drawing the device list
Now let\[cq]s take a look at \f[CR]updateDeviceList()\f[R] itself.
This method is called any time we want to fetch the current list of
media devices and then update the displayed lists of audio and video
devices using that information.
.IP
.EX
function updateDeviceList() {
  navigator.mediaDevices.enumerateDevices().then((devices) => {
    audioList.innerHTML = \[dq]\[dq];
    videoList.innerHTML = \[dq]\[dq];

    devices.forEach((device) => {
      const elem = document.createElement(\[dq]li\[dq]);
      const [kind, type, direction] = device.kind.match(/(\[rs]w+)(input|output)/i);

      elem.innerHTML = \[ga]<strong>${device.label}</strong> (${direction})\[ga];
      if (type === \[dq]audio\[dq]) {
        audioList.appendChild(elem);
      } else if (type === \[dq]video\[dq]) {
        videoList.appendChild(elem);
      }
    });
  });
}
.EE
.PP
\f[CR]updateDeviceList()\f[R] consists entirely of a call to the
function \f[CR]enumerateDevices()\f[R] on the \f[CR]MediaDevices\f[R]
object referenced in the \f[CR]navigator.mediaDevices\f[R] property, as
well as the code that\[cq]s run when the \f[CR]promise\f[R] returned by
\f[CR]enumerateDevices()\f[R] is fulfilled.
The fulfillment handler is called when the device list is ready.
The list is passed into the fulfillment handler as an array of
\f[CR]MediaDeviceInfo\f[R] objects, each describing one media input or
output device.
.PP
A \f[CR]forEach()\f[R] loop is used to scan through all the devices.
For each device, we create a new \f[CR]<li>\f[R] object to be used to
display it to the user.
.PP
The line
\f[CR]let [kind, type, direction] = device.kind.match(/(\[rs]w+)(input|output)/i);\f[R]
deserves special notice.
This uses destructuring assignment to assign the values of the first
three items in the array returned by \f[CR]String.match()\f[R] to the
variables \f[CR]kind\f[R], \f[CR]type\f[R], and \f[CR]direction\f[R].
We do this because the value of \f[CR]MediaDeviceInfo.kind\f[R] is a
single string that includes both the media type and the direction the
media flows, such as \[lq]audioinput\[rq] or \[lq]videooutput\[rq].
This line, then, pulls out the type (\[lq]audio\[rq] or \[lq]video\[rq])
and direction (\[lq]input\[rq] or \[lq]output\[rq]) so they can be used
to construct the string displayed in the list.
.PP
Once the string is assembled, containing the device\[cq]s name in bold
and the direction in parentheses, it\[cq]s appended to the appropriate
list by calling \f[CR]appendChild()\f[R] on either \f[CR]audioList\f[R]
or \f[CR]videoList\f[R], as appropriate based on the device type.
.SS Handling device list changes
We call \f[CR]updateDeviceList()\f[R] in two places.
The first is in the \f[CR]getUserMedia()\f[R] promise\[cq]s fulfillment
handler, to initially fill out the list when the stream is opened.
The second is in the event handler for this \f[CR]devicechange\f[R]
event:
.IP
.EX
navigator.mediaDevices.ondevicechange = (event) => {
  updateDeviceList();
};
.EE
.PP
With this code in place, each time the user plugs in a camera,
microphone, or other media device, or turns one on or off, we call
\f[CR]updateDeviceList()\f[R] to redraw the list of connected devices.
.SS Result
