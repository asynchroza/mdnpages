.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "Node.insertBefore" "JS" "April 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Node.insertBefore \- Node: insertBefore() method
.SH SYNOPSIS
The \f[B]\f[CB]insertBefore()\f[B]\f[R] method of the \f[CR]Node\f[R]
interface inserts a node before a \f[I]reference node\f[R] as a child of
a specified \f[I]parent node\f[R].
.PP
If the given node already exists in the document,
\f[CR]insertBefore()\f[R] moves it from its current position to the new
position.
(That is, it will automatically be removed from its existing parent
before appending it to the specified new parent.)
.PP
This means that a node cannot be in two locations of the document
simultaneously.
.RS
.PP
\f[B]Note:\f[R] The \f[CR]Node.cloneNode()\f[R] can be used to make a
copy of the node before appending it under the new parent.
Note that the copies made with \f[CR]cloneNode()\f[R] will not be
automatically kept in sync.
.RE
.PP
If the given child is a \f[CR]DocumentFragment\f[R], the entire contents
of the \f[CR]DocumentFragment\f[R] are moved into the child list of the
specified parent node.
.SH SYNTAX
.IP
.EX
insertBefore(newNode, referenceNode)
.EE
.SS Parameters
.TP
\f[B]newNode\f[R]
The node to be inserted.
.TP
\f[B]referenceNode\f[R]
The node before which \f[CR]newNode\f[R] is inserted.
If this is \f[CR]null\f[R], then \f[CR]newNode\f[R] is inserted at the
end of node\[cq]s child nodes.
> \f[B]Note:\f[R] \f[CR]referenceNode\f[R] is \f[B]not\f[R] an optional
parameter.
> You must explicitly pass a \f[CR]Node\f[R] or \f[CR]null\f[R].
> Failing to provide it or passing invalid values may \c
.UR https://crbug.com/419780
behave
.UE \c
\ \c
.UR https://bugzil.la/119489
differently
.UE \c
\ in different browser versions.
.SS Return value
Returns the added child (unless \f[CR]newNode\f[R] is a
\f[CR]DocumentFragment\f[R], in which case the empty
\f[CR]DocumentFragment\f[R] is returned).
.SS Exceptions
Pre\-insert validity
.SH EXAMPLE
.SS Example 1
.IP
.EX
<div id=\[dq]parentElement\[dq]>
  <span id=\[dq]childElement\[dq]>foo bar</span>
</div>

<script>
  // Create the new node to insert
  const newNode = document.createElement(\[dq]span\[dq]);

  // Get a reference to the parent node
  const parentDiv = document.getElementById(\[dq]childElement\[dq]).parentNode;

  // Begin test case [ 1 ] : Existing childElement (all works correctly)
  let sp2 = document.getElementById(\[dq]childElement\[dq]);
  parentDiv.insertBefore(newNode, sp2);
  // End test case [ 1 ]

  // Begin test case [ 2 ] : childElement is of Type undefined
  sp2 = undefined; // Non\-existent node of id \[dq]childElement\[dq]
  parentDiv.insertBefore(newNode, sp2); // Implicit dynamic cast to type Node
  // End test case [ 2 ]

  // Begin test case [ 3 ] : childElement is of Type \[dq]undefined\[dq] (string)
  sp2 = \[dq]undefined\[dq]; // Non\-existent node of id \[dq]childElement\[dq]
  parentDiv.insertBefore(newNode, sp2); // Generates \[dq]Type Error: Invalid Argument\[dq]
  // End test case [ 3 ]
</script>
.EE
.SS Example 2
.IP
.EX
<div id=\[dq]parentElement\[dq]>
  <span id=\[dq]childElement\[dq]>foo bar</span>
</div>

<script>
  // Create a new, plain <span> element
  let sp1 = document.createElement(\[dq]span\[dq]);

  // Get the reference element
  let sp2 = document.getElementById(\[dq]childElement\[dq]);
  // Get the parent element
  let parentDiv = sp2.parentNode;

  // Insert the new element into before sp2
  parentDiv.insertBefore(sp1, sp2);
</script>
.EE
.RS
.PP
\f[B]Note:\f[R] There is no \f[CR]insertAfter()\f[R] method.
It can be emulated by combining the \f[CR]insertBefore\f[R] method with
\f[CR]Node.nextSibling\f[R].
.PP
In the previous example, \f[CR]sp1\f[R] could be inserted after
\f[CR]sp2\f[R] using:
.IP
.EX
parentDiv.insertBefore(sp1, sp2.nextSibling);
.EE
.PP
If \f[CR]sp2\f[R] does not have a next sibling, then it must be the last
child \[em] \f[CR]sp2.nextSibling\f[R] returns \f[CR]null\f[R], and
\f[CR]sp1\f[R] is inserted at the end of the child node list
(immediately after \f[CR]sp2\f[R]).
.RE
.SS Example 3
Insert an element before the first child element, using the
\f[CR]firstChild\f[R] property.
.IP
.EX
// Get the parent element
let parentElement = document.getElementById(\[dq]parentElement\[dq]);
// Get the parent\[aq]s first child
let theFirstChild = parentElement.firstChild;

// Create a new element
let newElement = document.createElement(\[dq]div\[dq]);

// Insert the new element before the first child
parentElement.insertBefore(newElement, theFirstChild);
.EE
.PP
When the element does not have a first child, then \f[CR]firstChild\f[R]
is \f[CR]null\f[R].
The element is still appended to the parent, after the last child.
.PP
Since the parent element did not have a first child, it did not have a
last child, either.
Consequently, the newly inserted element is the \f[I]only\f[R] element.
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Node.removeChild()\f[R]
.IP \[bu] 2
\f[CR]Node.replaceChild()\f[R]
.IP \[bu] 2
\f[CR]Node.appendChild()\f[R]
.IP \[bu] 2
\f[CR]Node.hasChildNodes()\f[R]
.IP \[bu] 2
\f[CR]Element.insertAdjacentElement()\f[R]
.IP \[bu] 2
\f[CR]Element.prepend()\f[R]
.IP \[bu] 2
\f[CR]Element.before()\f[R]
.IP \[bu] 2
\f[CR]Element.after()\f[R]
