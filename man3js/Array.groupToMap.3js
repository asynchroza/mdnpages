.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.groupToMap" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Array.groupToMap - Array.prototype.groupToMap()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]groupToMap()\f[B]\f[R] method groups the elements of the
calling array using the values returned by a provided testing function.
The final returned \f[V]Map\f[R] uses the unique values from the test
function as keys, which can be used to get the array of elements in each
group.
.PP
The method is primarily useful when grouping elements that are
associated with an object, and in particular when that object might
change over time.
If the object is invariant, you might instead represent it using a
string, and group elements with \f[V]Array.prototype.group()\f[R].
.SH SYNTAX
.IP
.nf
\f[C]
groupToMap(callbackFn)
groupToMap(callbackFn, thisArg)
\f[R]
.fi
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element in the array.
It should return a value (object or primitive) indicating the group of
the current element.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the array.
.TP
\f[B]index\f[R]
The index of the current element being processed in the array.
.TP
\f[B]array\f[R]
The array \f[V]groupToMap()\f[R] was called upon.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
A value to use as \f[V]this\f[R] when executing \f[V]callbackFn\f[R].
See iterative methods.
.SS Return value
.PP
A \f[V]Map\f[R] object with keys for each group, each assigned to an
array containing the elements of the associated group.
.SH DESCRIPTION
.PP
The \f[V]groupToMap()\f[R] method is an iterative method.
It calls a provided \f[V]callbackFn\f[R] function once for each element
in an array.
The callback function returns a value indicating the group of the
associated element.
The values returned by \f[V]callbackFn\f[R] are used as keys for the
\f[V]Map\f[R] returned by \f[V]groupToMap()\f[R].
Each key has an associated array containing all the elements for which
the callback returned the same value.
.PP
\f[V]callbackFn\f[R] is invoked for \f[I]every\f[R] index of the array,
not just those with assigned values.
Empty slots in sparse arrays behave the same as \f[V]undefined\f[R].
.PP
The \f[V]groupToMap()\f[R] method is a copying method.
It does not alter \f[V]this\f[R] but instead returns a map of arrays
that contains the same elements as the ones from the original array.
However, the function provided as \f[V]callbackFn\f[R] can mutate the
array.
Note, however, that the length of the array is saved \f[I]before\f[R]
the first invocation of \f[V]callbackFn\f[R].
Therefore:
.IP \[bu] 2
\f[V]callbackFn\f[R] will not visit any elements added beyond the
array\[cq]s initial length when the call to \f[V]groupToMap()\f[R]
began.
.IP \[bu] 2
Changes to already-visited indexes do not cause \f[V]callbackFn\f[R] to
be invoked on them again.
.IP \[bu] 2
If an existing, yet-unvisited element of the array is changed by
\f[V]callbackFn\f[R], its value passed to the \f[V]callbackFn\f[R] will
be the value at the time that element gets visited.
Deleted elements are visited as if they were \f[V]undefined\f[R].
.RS
.PP
\f[B]Warning:\f[R] Concurrent modifications of the kind described above
frequently lead to hard-to-understand code and are generally to be
avoided (except in special cases).
.RE
.PP
The elements in the returned \f[V]Map\f[R] and the original array are
the same (not deep copies).
Changing the internal structure of the elements will be reflected in
both the original array and the returned \f[V]Map\f[R].
.PP
The \f[V]groupToMap()\f[R] method is generic.
It only expects the \f[V]this\f[R] value to have a \f[V]length\f[R]
property and integer-keyed properties.
.PP
This method is useful when you need to group information that is related
to a particular object that might potentially change over time.
This is because even if the object is modified, it will continue to work
as a key to the returned \f[V]Map\f[R].
If you instead create a string representation for the object and use
that as a grouping key in \f[V]Array.prototype.group()\f[R], you must
maintain the mapping between the original object and its representation
as the object changes.
.RS
.PP
\f[B]Note:\f[R] To access the groups in the returned \f[V]Map\f[R], you
must use the same object that was originally used as a key in the
\f[V]Map\f[R] (although you may modify its properties).
You can\[cq]t use another object that just happens to have the same name
and properties.
.RE
.SH EXAMPLES
.SS Using groupToMap()
.PP
First we define an array containing objects representing an inventory of
different foodstuffs.
Each food has a \f[V]type\f[R] and a \f[V]quantity\f[R].
.IP
.nf
\f[C]
const inventory = [
  { name: \[dq]asparagus\[dq], type: \[dq]vegetables\[dq], quantity: 9 },
  { name: \[dq]bananas\[dq], type: \[dq]fruit\[dq], quantity: 5 },
  { name: \[dq]goat\[dq], type: \[dq]meat\[dq], quantity: 23 },
  { name: \[dq]cherries\[dq], type: \[dq]fruit\[dq], quantity: 12 },
  { name: \[dq]fish\[dq], type: \[dq]meat\[dq], quantity: 22 },
];
\f[R]
.fi
.PP
The code below uses \f[V]groupToMap()\f[R] with an arrow function that
returns the object keys named \f[V]restock\f[R] or \f[V]sufficient\f[R],
depending on whether the element has \f[V]quantity < 6\f[R].
The returned \f[V]result\f[R] object is a \f[V]Map\f[R] so we need to
call \f[V]get()\f[R] with the key to obtain the array.
.IP
.nf
\f[C]
const restock = { restock: true };
const sufficient = { restock: false };
const result = inventory.groupToMap(({ quantity }) =>
  quantity < 6 ? restock : sufficient,
);
console.log(result.get(restock));
// [{ name: \[dq]bananas\[dq], type: \[dq]fruit\[dq], quantity: 5 }]
\f[R]
.fi
.PP
Note that the function argument \f[V]{ quantity }\f[R] is a basic
example of object destructuring syntax for function arguments.
This unpacks the \f[V]quantity\f[R] property of an object passed as a
parameter, and assigns it to a variable named \f[V]quantity\f[R] in the
body of the function.
This is a very succinct way to access the relevant values of elements
within a function.
.PP
The key to a \f[V]Map\f[R] can be modified and still used.
However you can\[cq]t recreate the key and still use it.
For this reason it is important that anything that needs to use the map
keeps a reference to its keys.
.IP
.nf
\f[C]
// The key can be modified and still used
restock[\[dq]fast\[dq]] = true;
console.log(result.get(restock));
// [{ name: \[dq]bananas\[dq], type: \[dq]fruit\[dq], quantity: 5 }]

// A new key can\[aq]t be used, even if it has the same structure!
const restock2 = { restock: true };
console.log(result.get(restock2)); // undefined
\f[R]
.fi
.SS Using groupToMap() on sparse arrays
.PP
When used on sparse arrays, the \f[V]groupToMap()\f[R] method iterates
empty slots as if they have the value \f[V]undefined\f[R].
.IP
.nf
\f[C]
console.log([1, , 3].groupToMap((x) => x));
// Map { 1 => [1], undefined => [undefined], 3 => [3] }
\f[R]
.fi
.SS Calling groupToMap() on non-array objects
.PP
The \f[V]groupToMap()\f[R] method reads the \f[V]length\f[R] property of
\f[V]this\f[R] and then accesses each integer index.
.IP
.nf
\f[C]
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.groupToMap.call(arrayLike, (x) => x % 2));
// Map { 0 => [2, 4], 1 => [3] }
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[V]Array.prototype.groupToMap\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#array-grouping)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[V]Array\f[R]
.IP \[bu] 2
\f[V]Array.prototype.group()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.reduce()\f[R]
.IP \[bu] 2
\f[V]Map()\f[R]
