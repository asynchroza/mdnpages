.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "RTCPeerConnection.canTrickleIceCandidates" "JS" "July 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
RTCPeerConnection.canTrickleIceCandidates \- RTCPeerConnection:
canTrickleIceCandidates property
.SH SYNOPSIS
The read\-only \f[B]\f[CB]RTCPeerConnection\f[B]\f[R] property
\f[B]\f[CB]canTrickleIceCandidates\f[B]\f[R] returns a boolean value
which indicates whether or not the remote peer can accept \c
.UR https://datatracker.ietf.org/doc/html/draft-ietf-mmusic-trickle-ice
trickled ICE candidates
.UE \c
\&.
.PP
\f[B]ICE trickling\f[R] is the process of continuing to send candidates
after the initial offer or answer has already been sent to the other
peer.
.PP
This property is only set after having called
\f[CR]RTCPeerConnection.setRemoteDescription()\f[R].
Ideally, your signaling protocol provides a way to detect trickling
support, so that you don\[cq]t need to rely on this property.
A WebRTC browser will always support trickle ICE.
If trickling isn\[cq]t supported, or you aren\[cq]t able to tell, you
can check for a falsy value for this property and then wait until the
value of \f[CR]iceGatheringState\f[R] changes to
\f[CR]\[dq]completed\[dq]\f[R] before creating and sending the initial
offer.
That way, the offer contains all of the candidates.
.SH VALUE
A boolean value that is \f[CR]true\f[R] if the remote peer can accept
trickled ICE candidates and \f[CR]false\f[R] if it cannot.
If no remote peer has been established, this value is \f[CR]null\f[R].
.RS
.PP
\f[B]Note:\f[R] This property\[cq]s value is determined once the local
peer has called \f[CR]RTCPeerConnection.setRemoteDescription()\f[R]; the
provided description is used by the ICE agent to determine whether or
not the remote peer supports trickled ICE candidates.
.RE
.SH EXAMPLES
.IP
.EX
const pc = new RTCPeerConnection();

function waitToCompleteIceGathering(pc) {
  return new Promise((resolve) => {
    pc.addEventListener(
      \[dq]icegatheringstatechange\[dq],
      (e) =>
        e.target.iceGatheringState === \[dq]complete\[dq] &&
        resolve(pc.localDescription),
    );
  });
}

// The following code might be used to handle an offer from a peer when
// it isn\[aq]t known whether it supports trickle ICE.
async function newPeer(remoteOffer) {
  await pc.setRemoteDescription(remoteOffer);
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  if (pc.canTrickleIceCandidates) return pc.localDescription;
  const answer = await waitToCompleteIceGathering(pc);
  sendAnswerToPeer(answer); //To peer via signaling channel
}
// Handle error with try/catch

pc.addEventListener(
  \[dq]icecandidate\[dq],
  (e) => pc.canTrickleIceCandidates && sendCandidateToPeer(e.candidate),
);
.EE
.SH SEE ALSO
.IP \[bu] 2
WebRTC
.IP \[bu] 2
\f[CR]RTCPeerConnection.addIceCandidate()\f[R]
.IP \[bu] 2
Lifetime of a WebRTC session
