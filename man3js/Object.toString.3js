.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Object.toString" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]toString()\f[B]\f[R] method returns a string representing
the object.
This method is meant to be overridden by derived objects for custom type
conversion logic.
.SH Syntax
.IP
.nf
\f[C]
toString()
\f[R]
.fi
.SS Parameters
.PP
By default \f[V]toString()\f[R] takes no parameters.
However, objects that inherit from \f[V]Object\f[R] may override it with
their own implementations that do take parameters.
For example, the \f[V]Number.prototype.toString()\f[R] and
\f[V]BigInt.prototype.toString()\f[R] methods take an optional
\f[V]radix\f[R] parameter.
.SS Return value
.PP
A string representing the object.
.SH Description
.PP
JavaScript calls the \f[V]toString\f[R] method to convert an object to a
primitive value.
You rarely need to invoke the \f[V]toString\f[R] method yourself;
JavaScript automatically invokes it when encountering an object where a
primitive value is expected.
.PP
This method is called in priority by string conversion, but numeric
conversion and primitive conversion call \f[V]valueOf()\f[R] in
priority.
However, because the base \f[V]valueOf()\f[R] method returns an object,
the \f[V]toString()\f[R] method is usually called in the end, unless the
object overrides \f[V]valueOf()\f[R].
For example, \f[V]+[1]\f[R] returns \f[V]1\f[R], because its
\f[V]toString()\f[R] method returns \f[V]\[dq]1\[dq]\f[R], which is then
converted to a number.
.PP
All objects that inherit from \f[V]Object.prototype\f[R] (that is, all
except \f[V]null\f[R]-prototype objects) inherit the
\f[V]toString()\f[R] method.
When you create a custom object, you can override \f[V]toString()\f[R]
to call a custom method, so that your custom object can be converted to
a string value.
Alternatively, you can add a \f[V]\[at]\[at]toPrimitive\f[R] method,
which allows even more control over the conversion process, and will
always be preferred over \f[V]valueOf\f[R] or \f[V]toString\f[R] for any
type conversion.
.PP
To use the base \f[V]Object.prototype.toString()\f[R] with an object
that has it overridden (or to invoke it on \f[V]null\f[R] or
\f[V]undefined\f[R]), you need to call
\f[V]Function.prototype.call()\f[R] or
\f[V]Function.prototype.apply()\f[R] on it, passing the object you want
to inspect as the first parameter (called \f[V]thisArg\f[R]).
.IP
.nf
\f[C]
const arr = [1, 2, 3];

arr.toString(); // \[dq]1,2,3\[dq]
Object.prototype.toString.call(arr); // \[dq][object Array]\[dq]
\f[R]
.fi
.PP
\f[V]Object.prototype.toString()\f[R] returns
\f[V]\[dq][object Type]\[dq]\f[R], where \f[V]Type\f[R] is the object
type.
If the object has a \f[V]Symbol.toStringTag\f[R] property whose value is
a string, that value will be used as the \f[V]Type\f[R].
Many built-in objects, including \f[V]Map\f[R] and \f[V]Symbol\f[R],
have a \f[V]Symbol.toStringTag\f[R].
Some objects predating ES6 do not have \f[V]Symbol.toStringTag\f[R], but
have a special tag nonetheless.
They include (the tag is the same as the type name given below):
.IP \[bu] 2
\f[V]Array\f[R]
.IP \[bu] 2
\f[V]Function\f[R] (anything whose \f[V]typeof\f[R] returns
\f[V]\[dq]function\[dq]\f[R])
.IP \[bu] 2
\f[V]Error\f[R]
.IP \[bu] 2
\f[V]Boolean\f[R]
.IP \[bu] 2
\f[V]Number\f[R]
.IP \[bu] 2
\f[V]String\f[R]
.IP \[bu] 2
\f[V]Date\f[R]
.IP \[bu] 2
\f[V]RegExp\f[R]
.PP
The \f[V]arguments\f[R] object returns
\f[V]\[dq][object Arguments]\[dq]\f[R].
Everything else, including user-defined classes, unless with a custom
\f[V]Symbol.toStringTag\f[R], will return
\f[V]\[dq][object Object]\[dq]\f[R].
.PP
\f[V]Object.prototype.toString()\f[R] invoked on \f[V]null\f[R] and
\f[V]undefined\f[R] returns \f[V][object Null]\f[R] and
\f[V][object Undefined]\f[R], respectively.
.SH Examples
.SS Overriding toString for custom objects
.PP
You can create a function to be called in place of the default
\f[V]toString()\f[R] method.
The \f[V]toString()\f[R] function you create should return a string
value.
If it returns an object and the method is called implicitly during type
conversion, then its result is ignored and the value of a related
method, \f[V]valueOf()\f[R], is used instead, or a \f[V]TypeError\f[R]
is thrown if none of these methods return a primitive.
.PP
The following code defines a \f[V]Dog\f[R] class.
.IP
.nf
\f[C]
class Dog {
  constructor(name, breed, color, sex) {
    this.name = name;
    this.breed = breed;
    this.color = color;
    this.sex = sex;
  }
}
\f[R]
.fi
.PP
If you call the \f[V]toString()\f[R] method, either explicitly or
implicitly, on an instance of \f[V]Dog\f[R], it returns the default
value inherited from \f[V]Object\f[R]:
.IP
.nf
\f[C]
const theDog = new Dog(\[dq]Gabby\[dq], \[dq]Lab\[dq], \[dq]chocolate\[dq], \[dq]female\[dq]);

theDog.toString(); // \[dq][object Object]\[dq]
\[ga]${theDog}\[ga]; // \[dq][object Object]\[dq]
\f[R]
.fi
.PP
The following code overrides the default \f[V]toString()\f[R] method.
This method generates a string containing the \f[V]name\f[R],
\f[V]breed\f[R], \f[V]color\f[R], and \f[V]sex\f[R] of the object.
.IP
.nf
\f[C]
class Dog {
  constructor(name, breed, color, sex) {
    this.name = name;
    this.breed = breed;
    this.color = color;
    this.sex = sex;
  }
  toString() {
    return \[ga]Dog ${this.name} is a ${this.sex} ${this.color} ${this.breed}\[ga];
  }
}
\f[R]
.fi
.PP
With the preceding code in place, any time an instance of \f[V]Dog\f[R]
is used in a string context, JavaScript automatically calls the
\f[V]toString()\f[R] method.
.IP
.nf
\f[C]
const theDog = new Dog(\[dq]Gabby\[dq], \[dq]Lab\[dq], \[dq]chocolate\[dq], \[dq]female\[dq]);

\[ga]${theDog}\[ga]; // \[dq]Dog Gabby is a female chocolate Lab\[dq]
\f[R]
.fi
.SS Using toString() to detect object class
.PP
\f[V]toString()\f[R] can be used with every object and (by default)
allows you to get its class.
.IP
.nf
\f[C]
const toString = Object.prototype.toString;

toString.call(new Date()); // [object Date]
toString.call(new String()); // [object String]
// Math has its Symbol.toStringTag
toString.call(Math); // [object Math]

toString.call(undefined); // [object Undefined]
toString.call(null); // [object Null]
\f[R]
.fi
.PP
Using \f[V]toString()\f[R] in this way is unreliable; objects can change
the behavior of \f[V]Object.prototype.toString()\f[R] by defining a
\f[V]Symbol.toStringTag\f[R] property, leading to unexpected results.
For example:
.IP
.nf
\f[C]
const myDate = new Date();
Object.prototype.toString.call(myDate); // [object Date]

myDate[Symbol.toStringTag] = \[dq]myDate\[dq];
Object.prototype.toString.call(myDate); // [object myDate]

Date.prototype[Symbol.toStringTag] = \[dq]prototype polluted\[dq];
Object.prototype.toString.call(new Date()); // [object prototype polluted]
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]Object.prototype.toString\f[R] with
\f[V]Symbol.toStringTag\f[R] support in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-object)
.IP \[bu] 2
\f[V]Object.prototype.valueOf()\f[R]
.IP \[bu] 2
\f[V]Number.prototype.toString()\f[R]
.IP \[bu] 2
\f[V]Symbol.toPrimitive\f[R]
.IP \[bu] 2
\f[V]Symbol.toStringTag\f[R]
