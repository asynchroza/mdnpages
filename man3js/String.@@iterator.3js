.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "String.\[at]\[at]iterator" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB][\[at]\[at]iterator]()\f[B]\f[R] method of
\f[V]String\f[R] values implements the iterable protocol and allows
strings to be consumed by most syntaxes expecting iterables, such as the
spread syntax and \f[V]for...of\f[R] loops.
It returns a string iterator object that yields the Unicode code points
of the string value as individual strings.
.SH Syntax
.IP
.nf
\f[C]
string[Symbol.iterator]()
\f[R]
.fi
.SS Return value
.PP
A new iterable iterator object that yields the Unicode code points of
the string value as individual strings.
.SH Description
.PP
Strings are iterated by Unicode code points.
This means grapheme clusters will be split, but surrogate pairs will be
preserved.
.IP
.nf
\f[C]
// \[dq]Backhand Index Pointing Right: Dark Skin Tone\[dq]
[...\[dq]üëâüèø\[dq]]; // [\[aq]üëâ\[aq], \[aq]üèø\[aq]]
// splits into the basic \[dq]Backhand Index Pointing Right\[dq] emoji and
// the \[dq]Dark skin tone\[dq] emoji

// \[dq]Family: Man, Boy\[dq]
[...\[dq]üë®‚Äçüë¶\[dq]]; // [ \[aq]üë®\[aq], \[aq]‚Äç\[aq], \[aq]üë¶\[aq] ]
// splits into the \[dq]Man\[dq] and \[dq]Boy\[dq] emoji, joined by a ZWJ
\f[R]
.fi
.SH Examples
.SS Iteration using for\&...of loop
.PP
Note that you seldom need to call this method directly.
The existence of the \f[V]\[at]\[at]iterator\f[R] method makes strings
iterable, and iterating syntaxes like the \f[V]for...of\f[R] loop
automatically calls this method to obtain the iterator to loop over.
.IP
.nf
\f[C]
const str = \[dq]A\[rs]uD835\[rs]uDC68B\[rs]uD835\[rs]uDC69C\[rs]uD835\[rs]uDC6A\[dq];

for (const v of str) {
  console.log(v);
}
// \[dq]A\[dq]
// \[dq]\[rs]uD835\[rs]uDC68\[dq]
// \[dq]B\[dq]
// \[dq]\[rs]uD835\[rs]uDC69\[dq]
// \[dq]C\[dq]
// \[dq]\[rs]uD835\[rs]uDC6A\[dq]
\f[R]
.fi
.SS Manually hand-rolling the iterator
.PP
You may still manually call the \f[V]next()\f[R] method of the returned
iterator object to achieve maximum control over the iteration process.
.IP
.nf
\f[C]
const str = \[dq]A\[rs]uD835\[rs]uDC68\[dq];

const strIter = str[Symbol.iterator]();

console.log(strIter.next().value); // \[dq]A\[dq]
console.log(strIter.next().value); // \[dq]\[rs]uD835\[rs]uDC68\[dq]
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]String.prototype[\[at]\[at]iterator]\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-string-and-regexp)
.IP \[bu] 2
Iteration protocols
