.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Object.getOwnPropertyNames" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]Object.getOwnPropertyNames()\f[B]\f[R] static method
returns an array of all properties (including non-enumerable properties
except for those which use Symbol) found directly in a given object.
.SH Syntax
.IP
.nf
\f[C]
Object.getOwnPropertyNames(obj)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]obj\f[R]
.RS 2
.IP \[bu] 2
The object whose enumerable and non-enumerable properties are to be
returned.
.RE
.SS Return value
.PP
An array of strings that corresponds to the properties found directly in
the given object.
.SH Description
.PP
\f[V]Object.getOwnPropertyNames()\f[R] returns an array whose elements
are strings corresponding to the enumerable and non-enumerable
properties found directly in a given object \f[V]obj\f[R].
The ordering of the enumerable properties in the array is consistent
with the ordering exposed by a \f[V]for...in\f[R] loop (or by
\f[V]Object.keys()\f[R]) over the properties of the object.
The non-negative integer keys of the object (both enumerable and
non-enumerable) are added in ascending order to the array first,
followed by the string keys in the order of insertion.
.PP
In ES5, if the argument to this method is not an object (a primitive),
then it will cause a \f[V]TypeError\f[R].
In ES2015, a non-object argument will be coerced to an object.
.IP
.nf
\f[C]
Object.getOwnPropertyNames(\[dq]foo\[dq]);
// TypeError: \[dq]foo\[dq] is not an object (ES5 code)

Object.getOwnPropertyNames(\[dq]foo\[dq]);
// [\[dq]0\[dq], \[dq]1\[dq], \[dq]2\[dq], \[dq]length\[dq]]  (ES2015 code)
\f[R]
.fi
.SH Examples
.SS Using Object.getOwnPropertyNames()
.IP
.nf
\f[C]
const arr = [\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq]];
console.log(Object.getOwnPropertyNames(arr).sort());
// [\[dq]0\[dq], \[dq]1\[dq], \[dq]2\[dq], \[dq]length\[dq]]

// Array-like object
const obj = { 0: \[dq]a\[dq], 1: \[dq]b\[dq], 2: \[dq]c\[dq] };
console.log(Object.getOwnPropertyNames(obj).sort());
// [\[dq]0\[dq], \[dq]1\[dq], \[dq]2\[dq]]

Object.getOwnPropertyNames(obj).forEach((val, idx, array) => {
  console.log(\[ga]${val} -> ${obj[val]}\[ga]);
});
// 0 -> a
// 1 -> b
// 2 -> c

// non-enumerable property
const myObj = Object.create(
  {},
  {
    getFoo: {
      value() {
        return this.foo;
      },
      enumerable: false,
    },
  },
);
myObj.foo = 1;

console.log(Object.getOwnPropertyNames(myObj).sort()); // [\[dq]foo\[dq], \[dq]getFoo\[dq]]
\f[R]
.fi
.PP
If you want only the enumerable properties, see \f[V]Object.keys()\f[R]
or use a \f[V]for...in\f[R] loop (note that this will also return
enumerable properties found along the prototype chain for the object
unless the latter is filtered with \f[V]hasOwn()\f[R]).
.PP
Items on the prototype chain are not listed:
.IP
.nf
\f[C]
function ParentClass() {}
ParentClass.prototype.inheritedMethod = function () {};

function ChildClass() {
  this.prop = 5;
  this.method = function () {};
}
ChildClass.prototype = new ParentClass();
ChildClass.prototype.prototypeMethod = function () {};

console.log(Object.getOwnPropertyNames(new ChildClass()));
// [\[dq]prop\[dq], \[dq]method\[dq]]
\f[R]
.fi
.SS Get non-enumerable properties only
.PP
This uses the \f[V]Array.prototype.filter()\f[R] function to remove the
enumerable keys (obtained with \f[V]Object.keys()\f[R]) from a list of
all keys (obtained with \f[V]Object.getOwnPropertyNames()\f[R]) thus
giving only the non-enumerable keys as output.
.IP
.nf
\f[C]
const target = myObject;
const enumAndNonenum = Object.getOwnPropertyNames(target);
const enumOnly = new Set(Object.keys(target));
const nonenumOnly = enumAndNonenum.filter((key) => !enumOnly.has(key));

console.log(nonenumOnly);
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]Object.getOwnPropertyNames\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-object)
.IP \[bu] 2
Enumerability and ownership of properties
.IP \[bu] 2
\f[V]Object.hasOwn()\f[R]
.IP \[bu] 2
\f[V]Object.prototype.propertyIsEnumerable()\f[R]
.IP \[bu] 2
\f[V]Object.create()\f[R]
.IP \[bu] 2
\f[V]Object.keys()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.forEach()\f[R]
