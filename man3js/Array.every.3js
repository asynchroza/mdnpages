.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Array.every" "JS" "April 17, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.every - Array.prototype.every()
.SH SYNOPSIS
The \f[B]\f[CB]every()\f[B]\f[R] method tests whether all elements in
the array pass the test implemented by the provided function.
It returns a Boolean value.
.SH SYNTAX
.IP
.EX
every(callbackFn)
every(callbackFn, thisArg)
.EE
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element in the array.
It should return a truthy value to indicate the element passes the test,
and a falsy value otherwise.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the array.
.TP
\f[B]index\f[R]
The index of the current element being processed in the array.
.TP
\f[B]array\f[R]
The array \f[CR]every()\f[R] was called upon.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
A value to use as \f[CR]this\f[R] when executing \f[CR]callbackFn\f[R].
See iterative methods.
.SS Return value
\f[CR]true\f[R] if \f[CR]callbackFn\f[R] returns a truthy value for
every array element.
Otherwise, \f[CR]false\f[R].
.SH DESCRIPTION
The \f[CR]every()\f[R] method is an iterative method.
It calls a provided \f[CR]callbackFn\f[R] function once for each element
in an array, until the \f[CR]callbackFn\f[R] returns a falsy value.
If such an element is found, \f[CR]every()\f[R] immediately returns
\f[CR]false\f[R] and stops iterating through the array.
Otherwise, if \f[CR]callbackFn\f[R] returns a truthy value for all
elements, \f[CR]every()\f[R] returns \f[CR]true\f[R].
.PP
\f[CR]every\f[R] acts like the \[lq]for all\[rq] quantifier in
mathematics.
In particular, for an empty array, it returns \f[CR]true\f[R].
(It is vacuously true (https://en.wikipedia.org/wiki/Vacuous_truth) that
all elements of the empty
set (https://en.wikipedia.org/wiki/Empty_set#Properties) satisfy any
given condition.)
.PP
\f[CR]callbackFn\f[R] is invoked only for array indexes which have
assigned values.
It is not invoked for empty slots in sparse arrays.
.PP
\f[CR]every()\f[R] does not mutate the array on which it is called, but
the function provided as \f[CR]callbackFn\f[R] can.
Note, however, that the length of the array is saved \f[I]before\f[R]
the first invocation of \f[CR]callbackFn\f[R].
Therefore:
.IP \[bu] 2
\f[CR]callbackFn\f[R] will not visit any elements added beyond the
array\[cq]s initial length when the call to \f[CR]every()\f[R] began.
.IP \[bu] 2
Changes to already-visited indexes do not cause \f[CR]callbackFn\f[R] to
be invoked on them again.
.IP \[bu] 2
If an existing, yet-unvisited element of the array is changed by
\f[CR]callbackFn\f[R], its value passed to the \f[CR]callbackFn\f[R]
will be the value at the time that element gets visited.
Deleted elements are not visited.
.RS
.PP
\f[B]Warning:\f[R] Concurrent modifications of the kind described above
frequently lead to hard-to-understand code and are generally to be
avoided (except in special cases).
.RE
.PP
The \f[CR]every()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer-keyed properties.
.SH EXAMPLES
.SS Testing size of all array elements
The following example tests whether all elements in the array are bigger
than 10.
.IP
.EX
function isBigEnough(element, index, array) {
  return element >= 10;
}
[12, 5, 8, 130, 44].every(isBigEnough); // false
[12, 54, 18, 130, 44].every(isBigEnough); // true
.EE
.SS Check if one array is a subset of another array
The following example tests if all the elements of an array are present
in another array.
.IP
.EX
const isSubset = (array1, array2) =>
  array2.every((element) => array1.includes(element));

console.log(isSubset([1, 2, 3, 4, 5, 6, 7], [5, 7, 6])); // true
console.log(isSubset([1, 2, 3, 4, 5, 6, 7], [5, 8, 7])); // false
.EE
.SS Using every() on sparse arrays
\f[CR]every()\f[R] will not run its predicate on empty slots.
.IP
.EX
console.log([1, , 3].every((x) => x !== undefined)); // true
console.log([2, , 2].every((x) => x === 2)); // true
.EE
.SS Affecting Initial Array (modifying, appending, and deleting)
The following examples tests the behavior of the \f[CR]every\f[R] method
when the array is modified.
.IP
.EX
// ---------------
// Modifying items
// ---------------
let arr = [1, 2, 3, 4];
arr.every((elem, index, arr) => {
  arr[index + 1]--;
  console.log(\[ga][${arr}][${index}] -> ${elem}\[ga]);
  return elem < 2;
});

// Loop runs for 3 iterations, but would
// have run 2 iterations without any modification
//
// 1st iteration: [1,1,3,4][0] -> 1
// 2nd iteration: [1,1,2,4][1] -> 1
// 3rd iteration: [1,1,2,3][2] -> 2

// ---------------
// Appending items
// ---------------
arr = [1, 2, 3];
arr.every((elem, index, arr) => {
  arr.push(\[dq]new\[dq]);
  console.log(\[ga][${arr}][${index}] -> ${elem}\[ga]);
  return elem < 4;
});

// Loop runs for 3 iterations, even after appending new items
//
// 1st iteration: [1, 2, 3, new][0] -> 1
// 2nd iteration: [1, 2, 3, new, new][1] -> 2
// 3rd iteration: [1, 2, 3, new, new, new][2] -> 3

// ---------------
// Deleting items
// ---------------
arr = [1, 2, 3, 4];
arr.every((elem, index, arr) => {
  arr.pop();
  console.log(\[ga][${arr}][${index}] -> ${elem}\[ga]);
  return elem < 4;
});

// Loop runs for 2 iterations only, as the remaining
// items are \[ga]pop()\[ga]ed off
//
// 1st iteration: [1,2,3][0] -> 1
// 2nd iteration: [1,2][1] -> 2
.EE
.SS Calling every() on non-array objects
The \f[CR]every()\f[R] method reads the \f[CR]length\f[R] property of
\f[CR]this\f[R] and then accesses each integer index until the end is
reached or \f[CR]callbackFn\f[R] returns \f[CR]false\f[R].
.IP
.EX
const arrayLike = {
  length: 3,
  0: \[dq]a\[dq],
  1: \[dq]b\[dq],
  2: \[dq]c\[dq],
};
console.log(
  Array.prototype.every.call(arrayLike, (x) => typeof x === \[dq]string\[dq]),
); // true
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]Array.prototype.every\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-array)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.forEach()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.some()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.find()\f[R]
.IP \[bu] 2
\f[CR]TypedArray.prototype.every()\f[R]
