.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "BigInt" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
BigInt - BigInt
.SH SYNOPSIS
.PP
\f[B]\f[VB]BigInt\f[B]\f[R] values represent numeric values which are
too large to be represented by the \f[V]number\f[R] primitive.
.SH DESCRIPTION
.PP
A \f[B]BigInt value\f[R], also sometimes just called a \f[B]BigInt\f[R],
is a \f[V]bigint\f[R] primitive, created by appending \f[V]n\f[R] to the
end of an integer literal, or by calling the \f[V]BigInt()\f[R] function
(without the \f[V]new\f[R] operator) and giving it an integer value or
string value.
.IP
.nf
\f[C]
const previouslyMaxSafeInteger = 9007199254740991n;

const alsoHuge = BigInt(9007199254740991);
// 9007199254740991n

const hugeString = BigInt(\[dq]9007199254740991\[dq]);
// 9007199254740991n

const hugeHex = BigInt(\[dq]0x1fffffffffffff\[dq]);
// 9007199254740991n

const hugeOctal = BigInt(\[dq]0o377777777777777777\[dq]);
// 9007199254740991n

const hugeBin = BigInt(
  \[dq]0b11111111111111111111111111111111111111111111111111111\[dq],
);
// 9007199254740991n
\f[R]
.fi
.PP
BigInt values are similar to Number values in some ways, but also differ
in a few key matters: A BigInt value cannot be used with methods in the
built-in \f[V]Math\f[R] object and cannot be mixed with a Number value
in operations; they must be coerced to the same type.
Be careful coercing values back and forth, however, as the precision of
a BigInt value may be lost when it is coerced to a Number value.
.SS Type information
.PP
When tested against \f[V]typeof\f[R], a BigInt value (\f[V]bigint\f[R]
primitive) will give \f[V]\[dq]bigint\[dq]\f[R]:
.IP
.nf
\f[C]
typeof 1n === \[dq]bigint\[dq]; // true
typeof BigInt(\[dq]1\[dq]) === \[dq]bigint\[dq]; // true
\f[R]
.fi
.PP
A BigInt value can also be wrapped in an \f[V]Object\f[R]:
.IP
.nf
\f[C]
typeof Object(1n) === \[dq]object\[dq]; // true
\f[R]
.fi
.SS Operators
.PP
The following operators may be used with BigInt values or object-wrapped
BigInt values:
.IP
.nf
\f[C]
+ * - % **
\f[R]
.fi
.PP
Bitwise operators are supported as well, except \f[V]>>>\f[R] (zero-fill
right shift), as every BigInt value is signed.
.PP
Also unsupported is the unary operator (\f[V]+\f[R]), in order to not
break
asm.js (https://github.com/tc39/proposal-bigint/blob/master/ADVANCED.md#dont-break-asmjs).
.IP
.nf
\f[C]
const previousMaxSafe = BigInt(Number.MAX_SAFE_INTEGER);
// 9007199254740991n

const maxPlusOne = previousMaxSafe + 1n;
// 9007199254740992n

const theFuture = previousMaxSafe + 2n;
// 9007199254740993n, this works now!

const multi = previousMaxSafe * 2n;
// 18014398509481982n

const subtr = multi - 10n;
// 18014398509481972n

const mod = multi % 10n;
// 2n

const bigN = 2n ** 54n;
// 18014398509481984n

bigN * -1n;
// -18014398509481984n
\f[R]
.fi
.PP
The \f[V]/\f[R] operator also works as expected with whole numbers \[em]
but operations with a fractional result will be truncated when used with
a BigInt value \[em] they won\[cq]t return any fractional digits.
.IP
.nf
\f[C]
const expected = 4n / 2n;
// 2n

const truncated = 5n / 2n;
// 2n, not 2.5n
\f[R]
.fi
.SS Comparisons
.PP
A BigInt value is not strictly equal to a Number value, but it
\f[I]is\f[R] loosely so:
.IP
.nf
\f[C]
0n === 0; // false
0n == 0; // true
\f[R]
.fi
.PP
A Number value and a BigInt value may be compared as usual:
.IP
.nf
\f[C]
1n < 2; // true
2n > 1; // true
2 > 2; // false
2n > 2; // false
2n >= 2; // true
\f[R]
.fi
.PP
BigInt values and Number values may be mixed in arrays and sorted:
.IP
.nf
\f[C]
const mixed = [4n, 6, -12n, 10, 4, 0, 0n];
// [4n, 6, -12n, 10, 4, 0, 0n]

mixed.sort(); // default sorting behavior
// [ -12n, 0, 0n, 10, 4n, 4, 6 ]

mixed.sort((a, b) => a - b);
// won\[aq]t work since subtraction will not work with mixed types
// TypeError: can\[aq]t convert BigInt value to Number value

// sort with an appropriate numeric comparator
mixed.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
// [ -12n, 0, 0n, 4n, 4, 6, 10 ]
\f[R]
.fi
.PP
Note that comparisons with \f[V]Object\f[R]-wrapped BigInt values act as
with other objects, only indicating equality when the same object
instance is compared:
.IP
.nf
\f[C]
Object(0n) === 0n; // false
Object(0n) === Object(0n); // false

const o = Object(0n);
o === o; // true
\f[R]
.fi
.PP
Because coercing between Number values and BigInt values can lead to
loss of precision, the following are recommended:
.IP \[bu] 2
Only use a BigInt value when values greater than 253 are reasonably
expected.
.IP \[bu] 2
Don\[cq]t coerce between BigInt values and Number values.
.SS Conditionals
.PP
A BigInt value follows the same conversion rules as Numbers when:
.IP \[bu] 2
it is converted to a \f[V]Boolean\f[R]: via the \f[V]Boolean\f[R]
function;
.IP \[bu] 2
when used with logical operators \f[V]||\f[R], \f[V]&&\f[R], and
\f[V]!\f[R]; or
.IP \[bu] 2
within a conditional test like an \f[V]if\f[R] statement.
.PP
Namely, only \f[V]0n\f[R] is falsy; everything else is truthy.
.IP
.nf
\f[C]
if (0n) {
  console.log(\[dq]Hello from the if!\[dq]);
} else {
  console.log(\[dq]Hello from the else!\[dq]);
}
// \[dq]Hello from the else!\[dq]

0n || 12n; // 12n
0n && 12n; // 0n
Boolean(0n); // false
Boolean(12n); // true
!12n; // false
!0n; // true
\f[R]
.fi
.SS Cryptography
.PP
The operations supported on BigInt values are not constant-time and are
thus open to timing
attacks (https://en.wikipedia.org/wiki/Timing_attack).
JavaScript BigInts therefore could be dangerous for use in cryptography
without mitigating factors.
As a very generic example, an attacker could measure the time difference
between \f[V]101n ** 65537n\f[R] and \f[V]17n ** 9999n\f[R], and deduce
the magnitude of secrets, such as private keys, based on the time
elapsed.
If you still have to use BigInts, take a look at the Timing attack
FAQ (https://timing.attacks.cr.yp.to/programming.html) for general
advice regarding the issue.
.SS Use within JSON
.PP
Using \f[V]JSON.stringify()\f[R] with any BigInt value will raise a
\f[V]TypeError\f[R], as BigInt values aren\[cq]t serialized in JSON by
default.
However, \f[V]JSON.stringify()\f[R] specifically leaves a backdoor for
BigInt values: it would try to call the BigInt\[cq]s \f[V]toJSON()\f[R]
method.
(It doesn\[cq]t do so for any other primitive values.)
Therefore, you can implement your own \f[V]toJSON()\f[R] method (which
is one of the few cases where patching built-in objects is not
explicitly discouraged):
.IP
.nf
\f[C]
BigInt.prototype.toJSON = function () {
  return this.toString();
};
\f[R]
.fi
.PP
Instead of throwing, \f[V]JSON.stringify()\f[R] now produces a string
like this:
.IP
.nf
\f[C]
console.log(JSON.stringify({ a: 1n }));
// {\[dq]a\[dq]:\[dq]1\[dq]}
\f[R]
.fi
.PP
If you do not wish to patch \f[V]BigInt.prototype\f[R], you can use the
\f[V]replacer\f[R] parameter of \f[V]JSON.stringify\f[R] to serialize
BigInt values:
.IP
.nf
\f[C]
const replacer = (key, value) =>
  typeof value === \[dq]bigint\[dq] ? value.toString() : value;

const data = {
  number: 1,
  big: 18014398509481982n,
};
const stringified = JSON.stringify(data, replacer);

console.log(stringified);
// {\[dq]number\[dq]:1,\[dq]big\[dq]:\[dq]18014398509481982\[dq]}
\f[R]
.fi
.PP
If you have JSON data containing values you know will be large integers,
you can use the \f[V]reviver\f[R] parameter of \f[V]JSON.parse\f[R] to
handle them:
.IP
.nf
\f[C]
const reviver = (key, value) => (key === \[dq]big\[dq] ? BigInt(value) : value);

const payload = \[aq]{\[dq]number\[dq]:1,\[dq]big\[dq]:\[dq]18014398509481982\[dq]}\[aq];
const parsed = JSON.parse(payload, reviver);

console.log(parsed);
// { number: 1, big: 18014398509481982n }
\f[R]
.fi
.RS
.PP
\f[B]Note:\f[R] While it\[cq]s possible to make the replacer of
\f[V]JSON.stringify()\f[R] generic and properly serialize BigInt values
for all objects, the reviver of \f[V]JSON.parse()\f[R] must be specific
to the payload shape you expect, because the serialization is
\f[I]lossy\f[R]: it\[cq]s not possible to distinguish between a string
that represents a BigInt and a normal string.
.RE
.SS BigInt coercion
.PP
Many built-in operations that expect BigInts first coerce their
arguments to BigInts.
The operation (https://tc39.es/ecma262/#sec-tobigint) can be summarized
as follows:
.IP \[bu] 2
BigInts are returned as-is.
.IP \[bu] 2
\f[V]undefined\f[R] and \f[V]null\f[R] throw a \f[V]TypeError\f[R].
.IP \[bu] 2
\f[V]true\f[R] turns into \f[V]1n\f[R]; \f[V]false\f[R] turns into
\f[V]0n\f[R].
.IP \[bu] 2
Strings are converted by parsing them as if they contain an integer
literal.
Any parsing failure results in a \f[V]SyntaxError\f[R].
The syntax is a subset of string numeric literals, where decimal points
or exponent indicators are not allowed.
.IP \[bu] 2
Numbers throw a \f[V]TypeError\f[R] to prevent unintended implicit
coercion causing loss of precision.
.IP \[bu] 2
Symbols throw a \f[V]TypeError\f[R].
.IP \[bu] 2
Objects are first converted to a primitive by calling their
\f[V][\[at]\[at]toPrimitive]()\f[R] (with \f[V]\[dq]number\[dq]\f[R] as
hint), \f[V]valueOf()\f[R], and \f[V]toString()\f[R] methods, in that
order.
The resulting primitive is then converted to a BigInt.
.PP
The best way to achieve nearly the same effect in JavaScript is through
the \f[V]BigInt()\f[R] function: \f[V]BigInt(x)\f[R] uses the same
algorithm to convert \f[V]x\f[R], except that Numbers don\[cq]t throw a
\f[V]TypeError\f[R], but are converted to BigInts if they are integers.
.PP
Note that built-in operations expecting BigInts often truncate the
BigInt to a fixed width after coercion.
This includes \f[V]BigInt.asIntN()\f[R], \f[V]BigInt.asUintN()\f[R], and
methods of \f[V]BigInt64Array\f[R] and \f[V]BigUint64Array\f[R].
.SH CONSTRUCTOR
.TP
\f[B]BigInt()\f[R]
Creates a new BigInt value.
.SH STATIC METHODS
.TP
\f[B]BigInt.asIntN()\f[R]
Clamps a BigInt value to a signed integer value, and returns that value.
.TP
\f[B]BigInt.asUintN()\f[R]
Clamps a BigInt value to an unsigned integer value, and returns that
value.
.SH INSTANCE PROPERTIES
.PP
These properties are defined on \f[V]BigInt.prototype\f[R] and shared by
all \f[V]BigInt\f[R] instances.
.TP
\f[B]BigInt.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[V]BigInt\f[R] instances, the initial value is the
\f[V]BigInt\f[R] constructor.
.TP
\f[B]BigInt.prototype[\[at]\[at]toStringTag]\f[R]
The initial value of the \f[V]\[at]\[at]toStringTag\f[R] property is the
string \f[V]\[dq]BigInt\[dq]\f[R].
This property is used in \f[V]Object.prototype.toString()\f[R].
However, because \f[V]BigInt\f[R] also has its own \f[V]toString()\f[R]
method, this property is not used unless you call
\f[V]Object.prototype.toString.call()\f[R] with a BigInt as
\f[V]thisArg\f[R].
.SH INSTANCE METHODS
.TP
\f[B]BigInt.prototype.toLocaleString()\f[R]
Returns a string with a language-sensitive representation of this BigInt
value.
Overrides the \f[V]Object.prototype.toLocaleString()\f[R] method.
.TP
\f[B]BigInt.prototype.toString()\f[R]
Returns a string representing this BigInt value in the specified radix
(base).
Overrides the \f[V]Object.prototype.toString()\f[R] method.
.TP
\f[B]BigInt.prototype.valueOf()\f[R]
Returns this BigInt value.
Overrides the \f[V]Object.prototype.valueOf()\f[R] method.
.SH EXAMPLES
.SS Calculating Primes
.IP
.nf
\f[C]
// Returns true if the passed BigInt value is a prime number
function isPrime(p) {
  for (let i = 2n; i * i <= p; i++) {
    if (p % i === 0n) return false;
  }
  return true;
}

// Takes a BigInt value as an argument, returns nth prime number as a BigInt value
function nthPrime(nth) {
  let maybePrime = 2n;
  let prime = 0n;

  while (nth >= 0n) {
    if (isPrime(maybePrime)) {
      nth--;
      prime = maybePrime;
    }
    maybePrime++;
  }

  return prime;
}

nthPrime(20n);
// 73n
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
\f[V]Number\f[R]
.IP \[bu] 2
\f[V]Number.MAX_SAFE_INTEGER\f[R]
