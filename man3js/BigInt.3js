.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "BigInt" "JS" "September 28, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
BigInt \- BigInt
.SH SYNOPSIS
\f[B]\f[CB]BigInt\f[B]\f[R] values represent numeric values which are
too large to be represented by the \f[CR]number\f[R] primitive.
.SH DESCRIPTION
A \f[B]BigInt value\f[R], also sometimes just called a \f[B]BigInt\f[R],
is a \f[CR]bigint\f[R] primitive, created by appending \f[CR]n\f[R] to
the end of an integer literal, or by calling the \f[CR]BigInt()\f[R]
function (without the \f[CR]new\f[R] operator) and giving it an integer
value or string value.
.IP
.EX
const previouslyMaxSafeInteger = 9007199254740991n;

const alsoHuge = BigInt(9007199254740991);
// 9007199254740991n

const hugeString = BigInt(\[dq]9007199254740991\[dq]);
// 9007199254740991n

const hugeHex = BigInt(\[dq]0x1fffffffffffff\[dq]);
// 9007199254740991n

const hugeOctal = BigInt(\[dq]0o377777777777777777\[dq]);
// 9007199254740991n

const hugeBin = BigInt(
  \[dq]0b11111111111111111111111111111111111111111111111111111\[dq],
);
// 9007199254740991n
.EE
.PP
BigInt values are similar to Number values in some ways, but also differ
in a few key matters: A BigInt value cannot be used with methods in the
built\-in \f[CR]Math\f[R] object and cannot be mixed with a Number value
in operations; they must be coerced to the same type.
Be careful coercing values back and forth, however, as the precision of
a BigInt value may be lost when it is coerced to a Number value.
.SS Type information
When tested against \f[CR]typeof\f[R], a BigInt value (\f[CR]bigint\f[R]
primitive) will give \f[CR]\[dq]bigint\[dq]\f[R]:
.IP
.EX
typeof 1n === \[dq]bigint\[dq]; // true
typeof BigInt(\[dq]1\[dq]) === \[dq]bigint\[dq]; // true
.EE
.PP
A BigInt value can also be wrapped in an \f[CR]Object\f[R]:
.IP
.EX
typeof Object(1n) === \[dq]object\[dq]; // true
.EE
.SS Operators
Most operators support BigInts, however most do not permit operands to
be of mixed types \[em] both operands must be BigInt or neither:
.IP \[bu] 2
Arithmetic operators: \f[CR]+\f[R], \f[CR]\-\f[R], \f[CR]*\f[R],
\f[CR]/\f[R], \f[CR]%\f[R], \f[CR]**\f[R]
.IP \[bu] 2
Bitwise operators: \f[CR]>>\f[R], \f[CR]<<\f[R], \f[CR]&\f[R],
\f[CR]|\f[R], \f[CR]\[ha]\f[R], \f[CR]\[ti]\f[R]
.IP \[bu] 2
Unary negation (\f[CR]\-\f[R])
.IP \[bu] 2
Increment/decrement: \f[CR]++\f[R], \f[CR]\-\-\f[R]
.PP
The boolean\-returning operators allow mixing numbers and BigInts as
operands:
.IP \[bu] 2
Relational operators and equality operators: \f[CR]>\f[R], \f[CR]<\f[R],
\f[CR]>=\f[R], \f[CR]<=\f[R], \f[CR]==\f[R], \f[CR]!=\f[R],
\f[CR]===\f[R], \f[CR]!==\f[R]
.IP \[bu] 2
Logical operators only rely on the truthiness of operands
.PP
A couple of operators do not support BigInt at all:
.IP \[bu] 2
Unary plus (\f[CR]+\f[R]) cannot be supported due to conflicting usage
in asm.js, so it has been left out \c
.UR
https://github.com/tc39/proposal-bigint/blob/master/ADVANCED.md#dont-break-asmjs
in order to not break asm.js
.UE \c
\&.
.IP \[bu] 2
Unsigned right shift (\f[CR]>>>\f[R]) is the only bitwise operator
that\[cq]s unsupported, as every BigInt value is signed.
.PP
Special cases:
.IP \[bu] 2
Addition (\f[CR]+\f[R]) involving a string and a BigInt returns a
string.
.IP \[bu] 2
Division (\f[CR]/\f[R]) truncates fractional components towards zero,
since BigInt is unable to represent fractional quantities.
.IP
.EX
const previousMaxSafe = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n
const maxPlusOne = previousMaxSafe + 1n; // 9007199254740992n
const theFuture = previousMaxSafe + 2n; // 9007199254740993n, this works now!
const multi = previousMaxSafe * 2n; // 18014398509481982n
const subtr = multi \- 10n; // 18014398509481972n
const mod = multi % 10n; // 2n
const bigN = 2n ** 54n; // 18014398509481984n
bigN * \-1n; // \-18014398509481984n
const expected = 4n / 2n; // 2n
const truncated = 5n / 2n; // 2n, not 2.5n
.EE
.SS Comparisons
A BigInt value is not strictly equal to a Number value, but it
\f[I]is\f[R] loosely so:
.IP
.EX
0n === 0; // false
0n == 0; // true
.EE
.PP
A Number value and a BigInt value may be compared as usual:
.IP
.EX
1n < 2; // true
2n > 1; // true
2 > 2; // false
2n > 2; // false
2n >= 2; // true
.EE
.PP
BigInt values and Number values may be mixed in arrays and sorted:
.IP
.EX
const mixed = [4n, 6, \-12n, 10, 4, 0, 0n];
// [4n, 6, \-12n, 10, 4, 0, 0n]

mixed.sort(); // default sorting behavior
// [ \-12n, 0, 0n, 10, 4n, 4, 6 ]

mixed.sort((a, b) => a \- b);
// won\[aq]t work since subtraction will not work with mixed types
// TypeError: can\[aq]t convert BigInt value to Number value

// sort with an appropriate numeric comparator
mixed.sort((a, b) => (a < b ? \-1 : a > b ? 1 : 0));
// [ \-12n, 0, 0n, 4n, 4, 6, 10 ]
.EE
.PP
Note that comparisons with \f[CR]Object\f[R]\-wrapped BigInt values act
as with other objects, only indicating equality when the same object
instance is compared:
.IP
.EX
Object(0n) === 0n; // false
Object(0n) === Object(0n); // false

const o = Object(0n);
o === o; // true
.EE
.PP
Because coercing between Number values and BigInt values can lead to
loss of precision, the following are recommended:
.IP \[bu] 2
Only use a BigInt value when values greater than 253 are reasonably
expected.
.IP \[bu] 2
Don\[cq]t coerce between BigInt values and Number values.
.SS Conditionals
A BigInt value follows the same conversion rules as Numbers when:
.IP \[bu] 2
it is converted to a \f[CR]Boolean\f[R]: via the \f[CR]Boolean\f[R]
function;
.IP \[bu] 2
when used with logical operators \f[CR]||\f[R], \f[CR]&&\f[R], and
\f[CR]!\f[R]; or
.IP \[bu] 2
within a conditional test like an \f[CR]if\f[R] statement.
.PP
Namely, only \f[CR]0n\f[R] is falsy; everything else is truthy.
.IP
.EX
if (0n) {
  console.log(\[dq]Hello from the if!\[dq]);
} else {
  console.log(\[dq]Hello from the else!\[dq]);
}
// \[dq]Hello from the else!\[dq]

0n || 12n; // 12n
0n && 12n; // 0n
Boolean(0n); // false
Boolean(12n); // true
!12n; // false
!0n; // true
.EE
.SS Cryptography
The operations supported on BigInt values are not constant\-time and are
thus open to \c
.UR https://en.wikipedia.org/wiki/Timing_attack
timing attacks
.UE \c
\&.
JavaScript BigInts therefore could be dangerous for use in cryptography
without mitigating factors.
As a very generic example, an attacker could measure the time difference
between \f[CR]101n ** 65537n\f[R] and \f[CR]17n ** 9999n\f[R], and
deduce the magnitude of secrets, such as private keys, based on the time
elapsed.
If you still have to use BigInts, take a look at the \c
.UR https://timing.attacks.cr.yp.to/programming.html
Timing attack FAQ
.UE \c
\ for general advice regarding the issue.
.SS Use within JSON
Using \f[CR]JSON.stringify()\f[R] with any BigInt value will raise a
\f[CR]TypeError\f[R], as BigInt values aren\[cq]t serialized in JSON by
default.
However, \f[CR]JSON.stringify()\f[R] specifically leaves a backdoor for
BigInt values: it would try to call the BigInt\[cq]s \f[CR]toJSON()\f[R]
method.
(It doesn\[cq]t do so for any other primitive values.)
Therefore, you can implement your own \f[CR]toJSON()\f[R] method (which
is one of the few cases where patching built\-in objects is not
explicitly discouraged):
.IP
.EX
BigInt.prototype.toJSON = function () {
  return this.toString();
};
.EE
.PP
Instead of throwing, \f[CR]JSON.stringify()\f[R] now produces a string
like this:
.IP
.EX
console.log(JSON.stringify({ a: 1n }));
// {\[dq]a\[dq]:\[dq]1\[dq]}
.EE
.PP
If you do not wish to patch \f[CR]BigInt.prototype\f[R], you can use the
\f[CR]replacer\f[R] parameter of \f[CR]JSON.stringify\f[R] to serialize
BigInt values:
.IP
.EX
const replacer = (key, value) =>
  typeof value === \[dq]bigint\[dq] ? value.toString() : value;

const data = {
  number: 1,
  big: 18014398509481982n,
};
const stringified = JSON.stringify(data, replacer);

console.log(stringified);
// {\[dq]number\[dq]:1,\[dq]big\[dq]:\[dq]18014398509481982\[dq]}
.EE
.PP
If you have JSON data containing values you know will be large integers,
you can use the \f[CR]reviver\f[R] parameter of \f[CR]JSON.parse\f[R] to
handle them:
.IP
.EX
const reviver = (key, value) => (key === \[dq]big\[dq] ? BigInt(value) : value);

const payload = \[aq]{\[dq]number\[dq]:1,\[dq]big\[dq]:\[dq]18014398509481982\[dq]}\[aq];
const parsed = JSON.parse(payload, reviver);

console.log(parsed);
// { number: 1, big: 18014398509481982n }
.EE
.RS
.PP
\f[B]Note:\f[R] While it\[cq]s possible to make the replacer of
\f[CR]JSON.stringify()\f[R] generic and properly serialize BigInt values
for all objects, the reviver of \f[CR]JSON.parse()\f[R] must be specific
to the payload shape you expect, because the serialization is
\f[I]lossy\f[R]: it\[cq]s not possible to distinguish between a string
that represents a BigInt and a normal string.
.RE
.SS BigInt coercion
Many built\-in operations that expect BigInts first coerce their
arguments to BigInts.
\c
.UR
https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tobigint
The operation
.UE \c
\ can be summarized as follows:
.IP \[bu] 2
BigInts are returned as\-is.
.IP \[bu] 2
\f[CR]undefined\f[R] and \f[CR]null\f[R] throw a \f[CR]TypeError\f[R].
.IP \[bu] 2
\f[CR]true\f[R] turns into \f[CR]1n\f[R]; \f[CR]false\f[R] turns into
\f[CR]0n\f[R].
.IP \[bu] 2
Strings are converted by parsing them as if they contain an integer
literal.
Any parsing failure results in a \f[CR]SyntaxError\f[R].
The syntax is a subset of string numeric literals, where decimal points
or exponent indicators are not allowed.
.IP \[bu] 2
Numbers throw a \f[CR]TypeError\f[R] to prevent unintended implicit
coercion causing loss of precision.
.IP \[bu] 2
Symbols throw a \f[CR]TypeError\f[R].
.IP \[bu] 2
Objects are first converted to a primitive by calling their
\f[CR][\[at]\[at]toPrimitive]()\f[R] (with \f[CR]\[dq]number\[dq]\f[R]
as hint), \f[CR]valueOf()\f[R], and \f[CR]toString()\f[R] methods, in
that order.
The resulting primitive is then converted to a BigInt.
.PP
The best way to achieve nearly the same effect in JavaScript is through
the \f[CR]BigInt()\f[R] function: \f[CR]BigInt(x)\f[R] uses the same
algorithm to convert \f[CR]x\f[R], except that Numbers don\[cq]t throw a
\f[CR]TypeError\f[R], but are converted to BigInts if they are integers.
.PP
Note that built\-in operations expecting BigInts often truncate the
BigInt to a fixed width after coercion.
This includes \f[CR]BigInt.asIntN()\f[R], \f[CR]BigInt.asUintN()\f[R],
and methods of \f[CR]BigInt64Array\f[R] and \f[CR]BigUint64Array\f[R].
.SH CONSTRUCTOR
.TP
\f[B]BigInt()\f[R]
Creates a new BigInt value.
.SH STATIC METHODS
.TP
\f[B]BigInt.asIntN()\f[R]
Clamps a BigInt value to a signed integer value, and returns that value.
.TP
\f[B]BigInt.asUintN()\f[R]
Clamps a BigInt value to an unsigned integer value, and returns that
value.
.SH INSTANCE PROPERTIES
These properties are defined on \f[CR]BigInt.prototype\f[R] and shared
by all \f[CR]BigInt\f[R] instances.
.TP
\f[B]BigInt.prototype.constructor\f[R]
The constructor function that created the instance object.
For \f[CR]BigInt\f[R] instances, the initial value is the
\f[CR]BigInt\f[R] constructor.
.TP
\f[B]BigInt.prototype[\[at]\[at]toStringTag]\f[R]
The initial value of the \f[CR]\[at]\[at]toStringTag\f[R] property is
the string \f[CR]\[dq]BigInt\[dq]\f[R].
This property is used in \f[CR]Object.prototype.toString()\f[R].
However, because \f[CR]BigInt\f[R] also has its own
\f[CR]toString()\f[R] method, this property is not used unless you call
\f[CR]Object.prototype.toString.call()\f[R] with a BigInt as
\f[CR]thisArg\f[R].
.SH INSTANCE METHODS
.TP
\f[B]BigInt.prototype.toLocaleString()\f[R]
Returns a string with a language\-sensitive representation of this
BigInt value.
Overrides the \f[CR]Object.prototype.toLocaleString()\f[R] method.
.TP
\f[B]BigInt.prototype.toString()\f[R]
Returns a string representing this BigInt value in the specified radix
(base).
Overrides the \f[CR]Object.prototype.toString()\f[R] method.
.TP
\f[B]BigInt.prototype.valueOf()\f[R]
Returns this BigInt value.
Overrides the \f[CR]Object.prototype.valueOf()\f[R] method.
.SH EXAMPLES
.SS Calculating Primes
.IP
.EX
// Returns true if the passed BigInt value is a prime number
function isPrime(p) {
  for (let i = 2n; i * i <= p; i++) {
    if (p % i === 0n) return false;
  }
  return true;
}

// Takes a BigInt value as an argument, returns nth prime number as a BigInt value
function nthPrime(nth) {
  let maybePrime = 2n;
  let prime = 0n;

  while (nth >= 0n) {
    if (isPrime(maybePrime)) {
      nth\-\-;
      prime = maybePrime;
    }
    maybePrime++;
  }

  return prime;
}

nthPrime(20n);
// 73n
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Number\f[R]
.IP \[bu] 2
\f[CR]Number.MAX_SAFE_INTEGER\f[R]
