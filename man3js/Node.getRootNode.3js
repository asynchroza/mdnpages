.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "Node.getRootNode" "JS" "September 6, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Node.getRootNode \- Node: getRootNode() method
.SH SYNOPSIS
The \f[B]\f[CB]getRootNode()\f[B]\f[R] method of the \f[CR]Node\f[R]
interface returns the context object\[cq]s root, which optionally
includes the shadow root if it is available.
.SH SYNTAX
.IP
.EX
getRootNode()
getRootNode(options)
.EE
.SS Parameters
.TP
\f[B]options\f[R] \f[I](optional)\f[R]
An object that sets options for getting the root node.
The available options are:
.RS
.IP \[bu] 2
\f[CR]composed\f[R]: A boolean value that indicates whether the shadow
root should be returned (\f[CR]false\f[R], the default), or a root node
beyond shadow root (\f[CR]true\f[R]).
.RE
.SS Return value
An object inheriting from \f[CR]Node\f[R].
This will differ in exact form depending on where you call
\f[CR]getRootNode()\f[R]; for example:
.IP \[bu] 2
Calling it on an element inside a standard web page will return an
\f[CR]HTMLDocument\f[R] object representing the entire page (or
\f[CR]<iframe>\f[R]).
.IP \[bu] 2
Calling it on an element inside a shadow DOM will return the associated
\f[CR]ShadowRoot\f[R].
.IP \[bu] 2
Calling it on an element that is not attached to a document or a shadow
tree will return the root of the DOM tree it belongs to.
.SH EXAMPLES
.SS Example 1
The first simple example returns a reference to the HTML/document node:
.IP
.EX
const rootNode = node.getRootNode();
.EE
.SS Example 2
This more complex example shows the difference between returning a
normal root, and a root including the shadow root:
.IP
.EX
<div class=\[dq]parent\[dq]>
  <div class=\[dq]child\[dq]></div>
</div>
<div class=\[dq]shadowHost\[dq]>shadowHost</div>
<pre id=\[dq]output\[dq]>Output: </pre>
.EE
.IP
.EX
const parent = document.querySelector(\[dq].parent\[dq]);
const child = document.querySelector(\[dq].child\[dq]);
const shadowHost = document.querySelector(\[dq].shadowHost\[dq]);
const output = document.getElementById(\[dq]output\[dq]);

output.textContent += \[ga]\[rs]nparent\[aq]s root: ${parent.getRootNode().nodeName} \[rs]n\[ga]; // #document
output.textContent += \[ga]child\[aq]s  root: ${child.getRootNode().nodeName} \[rs]n\[rs]n\[ga]; // #document

// create a ShadowRoot
const shadowRoot = shadowHost.attachShadow({ mode: \[dq]open\[dq] });
shadowRoot.innerHTML =
  \[aq]<style>div{background:#2bb8aa;}</style><div class=\[dq]shadowChild\[dq]>shadowChild</div>\[aq];
const shadowChild = shadowRoot.querySelector(\[dq].shadowChild\[dq]);

// The default value of composed is false
output.textContent += \[ga]shadowChild.getRootNode() === shadowRoot : ${
  shadowChild.getRootNode() === shadowRoot
} \[rs]n\[ga]; // true
output.textContent += \[ga]shadowChild.getRootNode({composed:false}) === shadowRoot : ${
  shadowChild.getRootNode({ composed: false }) === shadowRoot
} \[rs]n\[ga]; // true
output.textContent += \[ga]shadowChild.getRootNode({composed:true}).nodeName : ${
  shadowChild.getRootNode({ composed: true }).nodeName
} \[rs]n\[ga]; // #document
.EE
.SS Example 3
This example returns the root of the unmounted tree.
Note \f[CR]element\f[R] here is the root of the tree (as it has no
parent), so by definition its root is itself:
.IP
.EX
const element = document.createElement(\[dq]p\[dq]);
const child = document.createElement(\[dq]span\[dq]);

element.append(child);

const rootNode = child.getRootNode(); // <p><span></span></p>

element === rootNode; // true
element === element.getRootNode(); // true
.EE
