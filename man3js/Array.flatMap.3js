.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.flatMap" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]flatMap()\f[B]\f[R] method returns a new array formed by
applying a given callback function to each element of the array, and
then flattening the result by one level.
It is identical to a \f[V]map()\f[R] followed by a \f[V]flat()\f[R] of
depth 1 (\f[V]arr.map(...args).flat()\f[R]), but slightly more efficient
than calling those two methods separately.
.SH Syntax
.IP
.nf
\f[C]
flatMap(callbackFn)
flatMap(callbackFn, thisArg)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]callbackFn\f[R]
.RS 2
.IP \[bu] 2
A function to execute for each element in the array.
It should return an array containing new elements of the new array, or a
single non-array value to be added to the new array.
The function is called with the following arguments:
.RS 2
.IP \[bu] 2
\f[V]element\f[R]
.RS 2
.IP \[bu] 2
The current element being processed in the array.
.RE
.IP \[bu] 2
\f[V]index\f[R]
.RS 2
.IP \[bu] 2
The index of the current element being processed in the array.
.RE
.IP \[bu] 2
\f[V]array\f[R]
.RS 2
.IP \[bu] 2
The array \f[V]flatMap()\f[R] was called upon.
.RE
.RE
.RE
.IP \[bu] 2
\f[V]thisArg\f[R] \f[I](optional)\f[R]
.RS 2
.IP \[bu] 2
A value to use as \f[V]this\f[R] when executing \f[V]callbackFn\f[R].
See iterative methods.
.RE
.SS Return value
.PP
A new array with each element being the result of the callback function
and flattened by a depth of 1.
.SH Description
.PP
The \f[V]flatMap()\f[R] method is an iterative method.
See \f[V]Array.prototype.map()\f[R] for a detailed description of the
callback function.
The \f[V]flatMap()\f[R] method is identical to
\f[V]map(callbackFn, thisArg)\f[R] followed by \f[V]flat(1)\f[R] \[em]
for each element, it produces an array of new elements, and concatenates
the resulting arrays together to form a new array.
.PP
The \f[V]flatMap()\f[R] method is generic.
It only expects the \f[V]this\f[R] value to have a \f[V]length\f[R]
property and integer-keyed properties.
However, the value returned from \f[V]callbackFn\f[R] must be an array
if it is to be flattened.
.SS Alternative
.SS Pre-allocate and explicitly iterate
.IP
.nf
\f[C]
const arr = [1, 2, 3, 4];

arr.flatMap((x) => [x, x * 2]);
// is equivalent to
const n = arr.length;
const acc = new Array(n * 2);
for (let i = 0; i < n; i++) {
  const x = arr[i];
  acc[i * 2] = x;
  acc[i * 2 + 1] = x * 2;
}
// [1, 2, 2, 4, 3, 6, 4, 8]
\f[R]
.fi
.PP
Note that in this particular case the \f[V]flatMap\f[R] approach is
slower than the for-loop approach \[em] due to the creation of temporary
arrays that must be garbage collected, as well as the return array not
needing to be frequently resized.
However, \f[V]flatMap\f[R] may still be the correct solution in cases
where its flexibility and readability are desired.
.SH Examples
.SS map() and flatMap()
.IP
.nf
\f[C]
const arr1 = [1, 2, 3, 4];

arr1.map((x) => [x * 2]);
// [[2], [4], [6], [8]]

arr1.flatMap((x) => [x * 2]);
// [2, 4, 6, 8]

// only one level is flattened
arr1.flatMap((x) => [[x * 2]]);
// [[2], [4], [6], [8]]
\f[R]
.fi
.PP
While the above could have been achieved by using map itself, here is an
example that better showcases the use of \f[V]flatMap()\f[R].
.PP
Let\[cq]s generate a list of words from a list of sentences.
.IP
.nf
\f[C]
const arr1 = [\[dq]it\[aq]s Sunny in\[dq], \[dq]\[dq], \[dq]California\[dq]];

arr1.map((x) => x.split(\[dq] \[dq]));
// [[\[dq]it\[aq]s\[dq],\[dq]Sunny\[dq],\[dq]in\[dq]],[\[dq]\[dq]],[\[dq]California\[dq]]]

arr1.flatMap((x) => x.split(\[dq] \[dq]));
// [\[dq]it\[aq]s\[dq],\[dq]Sunny\[dq],\[dq]in\[dq], \[dq]\[dq], \[dq]California\[dq]]
\f[R]
.fi
.PP
Notice, the output list length can be different from the input list
length.
.SS For adding and removing items during a map()
.PP
\f[V]flatMap\f[R] can be used as a way to add and remove items (modify
the number of items) during a \f[V]map\f[R].
In other words, it allows you to map \f[I]many items to many items\f[R]
(by handling each input item separately), rather than always
\f[I]one-to-one\f[R].
In this sense, it works like the opposite of filter.
Return a 1-element array to keep the item, a multiple-element array to
add items, or a 0-element array to remove the item.
.IP
.nf
\f[C]
// Let\[aq]s say we want to remove all the negative numbers
// and split the odd numbers into an even number and a 1
const a = [5, 4, -3, 20, 17, -33, -4, 18];
//         |\[rs]  \[rs]  x   |  | \[rs]   x   x   |
//        [4,1, 4,   20, 16, 1,       18]

const result = a.flatMap((n) => {
  if (n < 0) {
    return [];
  }
  return n % 2 === 0 ? [n] : [n - 1, 1];
});
console.log(result); // [4, 1, 4, 20, 16, 1, 18]
\f[R]
.fi
.SS Using flatMap() on sparse arrays
.PP
The \f[V]callbackFn\f[R] won\[cq]t be called for empty slots in the
source array because \f[V]map()\f[R] doesn\[cq]t, while \f[V]flat()\f[R]
ignores empty slots in the returned arrays.
.IP
.nf
\f[C]
console.log([1, 2, , 4, 5].flatMap((x) => [x, x * 2])); // [1, 2, 2, 4, 4, 8, 5, 10]
console.log([1, 2, 3, 4].flatMap((x) => [, x * 2])); // [2, 4, 6, 8]
\f[R]
.fi
.SS Calling flatMap() on non-array objects
.PP
The \f[V]flatMap()\f[R] method reads the \f[V]length\f[R] property of
\f[V]this\f[R] and then accesses each integer index.
If the return value of the callback function is not an array, it is
always directly appended to the result array.
.IP
.nf
\f[C]
const arrayLike = {
  length: 3,
  0: 1,
  1: 2,
  2: 3,
};
console.log(Array.prototype.flatMap.call(arrayLike, (x) => [x, x * 2]));
// [1, 2, 2, 4, 3, 6]

// Array-like objects returned from the callback won\[aq]t be flattened
console.log(
  Array.prototype.flatMap.call(arrayLike, (x) => ({
    length: 1,
    0: x,
  })),
);
// [ { \[aq]0\[aq]: 1, length: 1 }, { \[aq]0\[aq]: 2, length: 1 }, { \[aq]0\[aq]: 3, length: 1 } ]
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]Array.prototype.flatMap\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-array)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[V]Array\f[R]
.IP \[bu] 2
\f[V]Array.prototype.concat()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.flat()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.map()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.reduce()\f[R]
