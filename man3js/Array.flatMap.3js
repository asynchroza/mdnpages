.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Array.flatMap" "JS" "November 27, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Array.flatMap - Array.prototype.flatMap()
.SH SYNOPSIS
The \f[B]\f[CB]flatMap()\f[B]\f[R] method of \f[CR]Array\f[R] instances
returns a new array formed by applying a given callback function to each
element of the array, and then flattening the result by one level.
It is identical to a \f[CR]map()\f[R] followed by a \f[CR]flat()\f[R] of
depth 1 (\f[CR]arr.map(...args).flat()\f[R]), but slightly more
efficient than calling those two methods separately.
.SH SYNTAX
.IP
.EX
flatMap(callbackFn)
flatMap(callbackFn, thisArg)
.EE
.SS Parameters
.TP
\f[B]callbackFn\f[R]
A function to execute for each element in the array.
It should return an array containing new elements of the new array, or a
single non-array value to be added to the new array.
The function is called with the following arguments:
.RS
.TP
\f[B]element\f[R]
The current element being processed in the array.
.TP
\f[B]index\f[R]
The index of the current element being processed in the array.
.TP
\f[B]array\f[R]
The array \f[CR]flatMap()\f[R] was called upon.
.RE
.TP
\f[B]thisArg\f[R] \f[I](optional)\f[R]
A value to use as \f[CR]this\f[R] when executing \f[CR]callbackFn\f[R].
See iterative methods.
.SS Return value
A new array with each element being the result of the callback function
and flattened by a depth of 1.
.SH DESCRIPTION
The \f[CR]flatMap()\f[R] method is an iterative method.
See \f[CR]Array.prototype.map()\f[R] for a detailed description of the
callback function.
The \f[CR]flatMap()\f[R] method is identical to
\f[CR]map(callbackFn, thisArg)\f[R] followed by \f[CR]flat(1)\f[R] \[em]
for each element, it produces an array of new elements, and concatenates
the resulting arrays together to form a new array.
Read the iterative methods section for more information about how these
methods work in general.
.PP
The \f[CR]flatMap()\f[R] method is generic.
It only expects the \f[CR]this\f[R] value to have a \f[CR]length\f[R]
property and integer-keyed properties.
However, the value returned from \f[CR]callbackFn\f[R] must be an array
if it is to be flattened.
.SS Alternative
.SS Pre-allocate and explicitly iterate
.IP
.EX
const arr = [1, 2, 3, 4];

arr.flatMap((x) => [x, x * 2]);
// is equivalent to
const n = arr.length;
const acc = new Array(n * 2);
for (let i = 0; i < n; i++) {
  const x = arr[i];
  acc[i * 2] = x;
  acc[i * 2 + 1] = x * 2;
}
// [1, 2, 2, 4, 3, 6, 4, 8]
.EE
.PP
Note that in this particular case the \f[CR]flatMap\f[R] approach is
slower than the for-loop approach \[em] due to the creation of temporary
arrays that must be garbage collected, as well as the return array not
needing to be frequently resized.
However, \f[CR]flatMap\f[R] may still be the correct solution in cases
where its flexibility and readability are desired.
.SH EXAMPLES
.SS map() and flatMap()
.IP
.EX
const arr1 = [1, 2, 3, 4];

arr1.map((x) => [x * 2]);
// [[2], [4], [6], [8]]

arr1.flatMap((x) => [x * 2]);
// [2, 4, 6, 8]

// only one level is flattened
arr1.flatMap((x) => [[x * 2]]);
// [[2], [4], [6], [8]]
.EE
.PP
While the above could have been achieved by using map itself, here is an
example that better showcases the use of \f[CR]flatMap()\f[R].
.PP
Let\[cq]s generate a list of words from a list of sentences.
.IP
.EX
const arr1 = [\[dq]it\[aq]s Sunny in\[dq], \[dq]\[dq], \[dq]California\[dq]];

arr1.map((x) => x.split(\[dq] \[dq]));
// [[\[dq]it\[aq]s\[dq],\[dq]Sunny\[dq],\[dq]in\[dq]],[\[dq]\[dq]],[\[dq]California\[dq]]]

arr1.flatMap((x) => x.split(\[dq] \[dq]));
// [\[dq]it\[aq]s\[dq],\[dq]Sunny\[dq],\[dq]in\[dq], \[dq]\[dq], \[dq]California\[dq]]
.EE
.PP
Notice, the output list length can be different from the input list
length.
.SS For adding and removing items during a map()
\f[CR]flatMap\f[R] can be used as a way to add and remove items (modify
the number of items) during a \f[CR]map\f[R].
In other words, it allows you to map \f[I]many items to many items\f[R]
(by handling each input item separately), rather than always
\f[I]one-to-one\f[R].
In this sense, it works like the opposite of filter.
Return a 1-element array to keep the item, a multiple-element array to
add items, or a 0-element array to remove the item.
.IP
.EX
// Let\[aq]s say we want to remove all the negative numbers
// and split the odd numbers into an even number and a 1
const a = [5, 4, -3, 20, 17, -33, -4, 18];
//         |\[rs]  \[rs]  x   |  | \[rs]   x   x   |
//        [4,1, 4,   20, 16, 1,       18]

const result = a.flatMap((n) => {
  if (n < 0) {
    return [];
  }
  return n % 2 === 0 ? [n] : [n - 1, 1];
});
console.log(result); // [4, 1, 4, 20, 16, 1, 18]
.EE
.SS Using the third argument of callbackFn
The \f[CR]array\f[R] argument is useful if you want to access another
element in the array, especially when you don\[cq]t have an existing
variable that refers to the array.
The following example first uses \f[CR]filter()\f[R] to extract
operational stations and then uses \f[CR]flatMap()\f[R] to create a new
array where each element contains a station and its next station.
On the last station, it returns an empty array to exclude it from the
final array.
.IP
.EX
const stations = [\[dq]New Haven\[dq], \[dq]West Haven\[dq], \[dq]Milford (closed)\[dq], \[dq]Stratford\[dq]];
const line = stations
  .filter((name) => !name.endsWith(\[dq](closed)\[dq]))
  .flatMap((name, idx, arr) => {
    // Without the arr argument, there\[aq]s no way to easily access the
    // intermediate array without saving it to a variable.
    if (idx === arr.length - 1) return []; // last station has no next station
    return [\[ga]${name} - ${arr[idx + 1]}\[ga]];
  });
console.log(line); // [\[aq]New Haven - West Haven\[aq], \[aq]West Haven - Stratford\[aq]]
.EE
.PP
The \f[CR]array\f[R] argument is \f[I]not\f[R] the array that is being
built \[em] there is no way to access the array being built from the
callback function.
.SS Using flatMap() on sparse arrays
The \f[CR]callbackFn\f[R] won\[cq]t be called for empty slots in the
source array because \f[CR]map()\f[R] doesn\[cq]t, while
\f[CR]flat()\f[R] ignores empty slots in the returned arrays.
.IP
.EX
console.log([1, 2, , 4, 5].flatMap((x) => [x, x * 2])); // [1, 2, 2, 4, 4, 8, 5, 10]
console.log([1, 2, 3, 4].flatMap((x) => [, x * 2])); // [2, 4, 6, 8]
.EE
.SS Calling flatMap() on non-array objects
The \f[CR]flatMap()\f[R] method reads the \f[CR]length\f[R] property of
\f[CR]this\f[R] and then accesses each property whose key is a
nonnegative integer less than \f[CR]length\f[R].
If the return value of the callback function is not an array, it is
always directly appended to the result array.
.IP
.EX
const arrayLike = {
  length: 3,
  0: 1,
  1: 2,
  2: 3,
  3: 4, // ignored by flatMap() since length is 3
};
console.log(Array.prototype.flatMap.call(arrayLike, (x) => [x, x * 2]));
// [1, 2, 2, 4, 3, 6]

// Array-like objects returned from the callback won\[aq]t be flattened
console.log(
  Array.prototype.flatMap.call(arrayLike, (x) => ({
    length: 1,
    0: x,
  })),
);
// [ { \[aq]0\[aq]: 1, length: 1 }, { \[aq]0\[aq]: 2, length: 1 }, { \[aq]0\[aq]: 3, length: 1 } ]
.EE
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]Array.prototype.flatMap\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-array)
.IP \[bu] 2
Indexed collections guide
.IP \[bu] 2
\f[CR]Array\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.concat()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.flat()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.map()\f[R]
.IP \[bu] 2
\f[CR]Array.prototype.reduce()\f[R]
