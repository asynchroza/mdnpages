.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Object" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
Object - Object
.SH SYNOPSIS
.PP
The \f[B]\f[VB]Object\f[B]\f[R] type represents one of JavaScript\[cq]s
data types.
It is used to store various keyed collections and more complex entities.
Objects can be created using the \f[V]Object()\f[R] constructor or the
object initializer / literal syntax.
.SH DESCRIPTION
.PP
Nearly all objects in JavaScript are instances of \f[V]Object\f[R]; a
typical object inherits properties (including methods) from
\f[V]Object.prototype\f[R], although these properties may be shadowed
(a.k.a.
overridden).
The only objects that don\[cq]t inherit from \f[V]Object.prototype\f[R]
are those with \f[V]null\f[R] prototype, or descended from other
\f[V]null\f[R] prototype objects.
.PP
Changes to the \f[V]Object.prototype\f[R] object are seen by
\f[B]all\f[R] objects through prototype chaining, unless the properties
and methods subject to those changes are overridden further along the
prototype chain.
This provides a very powerful although potentially dangerous mechanism
to override or extend object behavior.
To make it more secure, \f[V]Object.prototype\f[R] is the only object in
the core JavaScript language that has immutable prototype \[em] the
prototype of \f[V]Object.prototype\f[R] is always \f[V]null\f[R] and not
changeable.
.SS Object prototype properties
.PP
You should avoid calling any \f[V]Object.prototype\f[R] method,
especially those that are not intended to be polymorphic (i.e.\ only its
initial behavior makes sense and no descending object could override it
in a meaningful way).
All objects descending from \f[V]Object.prototype\f[R] may define a
custom own property that has the same name, but with entirely different
semantics from what you expect.
Furthermore, these properties are not inherited by
\f[V]null\f[R]-prototype objects.
All modern JavaScript utilities for working with objects are static.
More specifically:
.IP \[bu] 2
\f[V]valueOf()\f[R], \f[V]toString()\f[R], and
\f[V]toLocaleString()\f[R] exist to be polymorphic and you should expect
the object to define its own implementation with sensible behaviors, so
you can call them as instance methods.
However, \f[V]valueOf()\f[R] and \f[V]toString()\f[R] are usually
implicitly called through type conversion and you don\[cq]t need to call
them yourself in your code.
.IP \[bu] 2
\f[V]__defineGetter__()\f[R], \f[V]__defineSetter__()\f[R],
\f[V]__lookupGetter__()\f[R], and \f[V]__lookupSetter__()\f[R] are
deprecated and should not be used.
Use the static alternatives \f[V]Object.defineProperty()\f[R] and
\f[V]Object.getOwnPropertyDescriptor()\f[R] instead.
.IP \[bu] 2
The \f[V]__proto__\f[R] property is deprecated and should not be used.
The \f[V]Object.getPrototypeOf()\f[R] and
\f[V]Object.setPrototypeOf()\f[R] alternatives are static methods.
.IP \[bu] 2
The \f[V]propertyIsEnumerable()\f[R] and \f[V]hasOwnProperty()\f[R]
methods can be replaced with the
\f[V]Object.getOwnPropertyDescriptor()\f[R] and
\f[V]Object.hasOwn()\f[R] static methods, respectively.
.IP \[bu] 2
The \f[V]isPrototypeOf()\f[R] method can usually be replaced with
\f[V]instanceof\f[R], if you are checking the \f[V]prototype\f[R]
property of a constructor.
.PP
In case where a semantically equivalent static method doesn\[cq]t exist,
or if you really want to use the \f[V]Object.prototype\f[R] method, you
should directly \f[V]call()\f[R] the \f[V]Object.prototype\f[R] method
on your target object instead, to prevent the object from having an
overriding property that produces unexpected results.
.IP
.nf
\f[C]
const obj = {
  foo: 1,
  // You should not define such a method on your own object,
  // but you may not be able to prevent it from happening if
  // you are receiving the object from external input
  propertyIsEnumerable() {
    return false;
  },
};

obj.propertyIsEnumerable(\[dq]foo\[dq]); // false; unexpected result
Object.prototype.propertyIsEnumerable.call(obj, \[dq]foo\[dq]); // true; expected result
\f[R]
.fi
.SS Deleting a property from an object
.PP
There isn\[cq]t any method in an Object itself to delete its own
properties (such as \f[V]Map.prototype.delete()\f[R]).
To do so, one must use the delete operator.
.SS null-prototype objects
.PP
Almost all objects in JavaScript ultimately inherit from
\f[V]Object.prototype\f[R] (see inheritance and the prototype chain).
However, you may create \f[V]null\f[R]-prototype objects using
\f[V]Object.create(null)\f[R] or the object initializer syntax with
\f[V]__proto__: null\f[R] (note: the \f[V]__proto__\f[R] key in object
literals is different from the deprecated
\f[V]Object.prototype.__proto__\f[R] property).
You can also change the prototype of an existing object to
\f[V]null\f[R] by calling \f[V]Object.setPrototypeOf(obj, null)\f[R].
.IP
.nf
\f[C]
const obj = Object.create(null);
const obj2 = { __proto__: null };
\f[R]
.fi
.PP
An object with a \f[V]null\f[R] prototype can behave in unexpected ways,
because it doesn\[cq]t inherit any object methods from
\f[V]Object.prototype\f[R].
This is especially true when debugging, since common object-property
converting/detecting utility functions may generate errors, or lose
information (especially if using silent error-traps that ignore errors).
.PP
For example, the lack of \f[V]Object.prototype.toString()\f[R] often
makes debugging intractable:
.IP
.nf
\f[C]
const normalObj = {}; // create a normal object
const nullProtoObj = Object.create(null); // create an object with \[dq]null\[dq] prototype

console.log(\[ga]normalObj is: ${normalObj}\[ga]); // shows \[dq]normalObj is: [object Object]\[dq]
console.log(\[ga]nullProtoObj is: ${nullProtoObj}\[ga]); // throws error: Cannot convert object to primitive value

alert(normalObj); // shows [object Object]
alert(nullProtoObj); // throws error: Cannot convert object to primitive value
\f[R]
.fi
.PP
Other methods will fail as well.
.IP
.nf
\f[C]
normalObj.valueOf(); // shows {}
nullProtoObj.valueOf(); // throws error: nullProtoObj.valueOf is not a function

normalObj.hasOwnProperty(\[dq]p\[dq]); // shows \[dq]true\[dq]
nullProtoObj.hasOwnProperty(\[dq]p\[dq]); // throws error: nullProtoObj.hasOwnProperty is not a function

normalObj.constructor; // shows \[dq]Object() { [native code] }\[dq]
nullProtoObj.constructor; // shows \[dq]undefined\[dq]
\f[R]
.fi
.PP
We can add the \f[V]toString\f[R] method back to the null-prototype
object by assigning it one:
.IP
.nf
\f[C]
nullProtoObj.toString = Object.prototype.toString; // since new object lacks toString, add the original generic one back

console.log(nullProtoObj.toString()); // shows \[dq][object Object]\[dq]
console.log(\[ga]nullProtoObj is: ${nullProtoObj}\[ga]); // shows \[dq]nullProtoObj is: [object Object]\[dq]
\f[R]
.fi
.PP
Unlike normal objects, in which \f[V]toString()\f[R] is on the
object\[cq]s prototype, the \f[V]toString()\f[R] method here is an own
property of \f[V]nullProtoObj\f[R].
This is because \f[V]nullProtoObj\f[R] has no (\f[V]null\f[R])
prototype.
.PP
In practice, objects with \f[V]null\f[R] prototype are usually used as a
cheap substitute for maps.
The presence of \f[V]Object.prototype\f[R] properties will cause some
bugs:
.IP
.nf
\f[C]
const ages = { alice: 18, bob: 27 };

function hasPerson(name) {
  return name in ages;
}

function getAge(name) {
  return ages[name];
}

hasPerson(\[dq]hasOwnProperty\[dq]); // true
getAge(\[dq]toString\[dq]); // [Function: toString]
\f[R]
.fi
.PP
Using a null-prototype object removes this hazard without introducing
too much complexity to the \f[V]hasPerson\f[R] and \f[V]getAge\f[R]
functions:
.IP
.nf
\f[C]
const ages = Object.create(null, {
  alice: { value: 18, enumerable: true },
  bob: { value: 27, enumerable: true },
});

hasPerson(\[dq]hasOwnProperty\[dq]); // false
getAge(\[dq]toString\[dq]); // undefined
\f[R]
.fi
.PP
In such case, the addition of any method should be done cautiously, as
they can be confused with the other key-value pairs stored as data.
.PP
Making your object not inherit from \f[V]Object.prototype\f[R] also
prevents prototype pollution attacks.
If a malicious script adds a property to \f[V]Object.prototype\f[R], it
will be accessible on every object in your program, except objects that
have null prototype.
.IP
.nf
\f[C]
const user = {};

// A malicious script:
Object.prototype.authenticated = true;

// Unexpectedly allowing unauthenticated user to pass through
if (user.authenticated) {
  // access confidential data
}
\f[R]
.fi
.PP
JavaScript also has built-in APIs that produce \f[V]null\f[R]-prototype
objects, especially those that use objects as ad hoc key-value
collections.
For example:
.IP \[bu] 2
The return value of \f[V]Array.prototype.group()\f[R]
.IP \[bu] 2
The \f[V]groups\f[R] and \f[V]indices.groups\f[R] properties of the
result of \f[V]RegExp.prototype.exec()\f[R]
.IP \[bu] 2
\f[V]Array.prototype[\[at]\[at]unscopables]\f[R] (all
\f[V]\[at]\[at]unscopables\f[R] objects should have
\f[V]null\f[R]-prototype)
.IP \[bu] 2
\f[V]import.meta\f[R]
.IP \[bu] 2
Module namespace objects, obtained through
\f[V]import * as ns from \[dq]module\[dq];\f[R] or \f[V]import()\f[R]
.PP
The term \[lq]\f[V]null\f[R]-prototype object\[rq] often also includes
any object without \f[V]Object.prototype\f[R] in its prototype chain.
Such objects can be created with \f[V]extends null\f[R] when using
classes.
.SS Object coercion
.PP
Many built-in operations that expect objects first coerce their
arguments to objects.
The operation (https://tc39.es/ecma262/#sec-toobject) can be summarized
as follows:
.IP \[bu] 2
Objects are returned as-is.
.IP \[bu] 2
\f[V]undefined\f[R] and \f[V]null\f[R] throw a \f[V]TypeError\f[R].
.IP \[bu] 2
\f[V]Number\f[R], \f[V]String\f[R], \f[V]Boolean\f[R], \f[V]Symbol\f[R],
\f[V]BigInt\f[R] primitives are wrapped into their corresponding object
wrappers.
.PP
The best way to achieve the same effect in JavaScript is through the
\f[V]Object()\f[R] constructor.
\f[V]Object(x)\f[R] converts \f[V]x\f[R] to an object, and for
\f[V]undefined\f[R] or \f[V]null\f[R], it returns a plain object instead
of throwing a \f[V]TypeError\f[R].
.PP
Places that use object coercion include:
.IP \[bu] 2
The \f[V]object\f[R] parameter of \f[V]for...in\f[R] loops.
.IP \[bu] 2
The \f[V]this\f[R] value of \f[V]Array\f[R] methods.
.IP \[bu] 2
Parameters of \f[V]Object\f[R] methods such as \f[V]Object.keys()\f[R].
.IP \[bu] 2
Auto-boxing when a property is accessed on a primitive value, since
primitives do not have properties.
.IP \[bu] 2
The \f[V]this\f[R] value when calling a non-strict function.
Primitives are boxed while \f[V]null\f[R] and \f[V]undefined\f[R] are
replaced with the global object.
.PP
Unlike conversion to primitives, the object coercion process itself is
not observable in any way, since it doesn\[cq]t invoke custom code like
\f[V]toString\f[R] or \f[V]valueOf\f[R] methods.
.SH CONSTRUCTOR
.TP
\f[B]Object()\f[R]
Turns the input into an object.
.SH STATIC METHODS
.TP
\f[B]Object.assign()\f[R]
Copies the values of all enumerable own properties from one or more
source objects to a target object.
.TP
\f[B]Object.create()\f[R]
Creates a new object with the specified prototype object and properties.
.TP
\f[B]Object.defineProperties()\f[R]
Adds the named properties described by the given descriptors to an
object.
.TP
\f[B]Object.defineProperty()\f[R]
Adds the named property described by a given descriptor to an object.
.TP
\f[B]Object.entries()\f[R]
Returns an array containing all of the \f[V][key, value]\f[R] pairs of a
given object\[cq]s \f[B]own\f[R] enumerable string properties.
.TP
\f[B]Object.freeze()\f[R]
Freezes an object.
Other code cannot delete or change its properties.
.TP
\f[B]Object.fromEntries()\f[R]
Returns a new object from an iterable of \f[V][key, value]\f[R] pairs.
(This is the reverse of \f[V]Object.entries\f[R]).
.TP
\f[B]Object.getOwnPropertyDescriptor()\f[R]
Returns a property descriptor for a named property on an object.
.TP
\f[B]Object.getOwnPropertyDescriptors()\f[R]
Returns an object containing all own property descriptors for an object.
.TP
\f[B]Object.getOwnPropertyNames()\f[R]
Returns an array containing the names of all of the given object\[cq]s
\f[B]own\f[R] enumerable and non-enumerable properties.
.TP
\f[B]Object.getOwnPropertySymbols()\f[R]
Returns an array of all symbol properties found directly upon a given
object.
.TP
\f[B]Object.getPrototypeOf()\f[R]
Returns the prototype (internal \f[V][[Prototype]]\f[R] property) of the
specified object.
.TP
\f[B]Object.hasOwn()\f[R]
Returns \f[V]true\f[R] if the specified object has the indicated
property as its \f[I]own\f[R] property, or \f[V]false\f[R] if the
property is inherited or does not exist.
.TP
\f[B]Object.is()\f[R]
Compares if two values are the same value.
Equates all \f[V]NaN\f[R] values (which differs from both
\f[V]IsLooselyEqual\f[R] used by \f[V]==\f[R] and
\f[V]IsStrictlyEqual\f[R] used by \f[V]===\f[R]).
.TP
\f[B]Object.isExtensible()\f[R]
Determines if extending of an object is allowed.
.TP
\f[B]Object.isFrozen()\f[R]
Determines if an object was frozen.
.TP
\f[B]Object.isSealed()\f[R]
Determines if an object is sealed.
.TP
\f[B]Object.keys()\f[R]
Returns an array containing the names of all of the given object\[cq]s
\f[B]own\f[R] enumerable string properties.
.TP
\f[B]Object.preventExtensions()\f[R]
Prevents any extensions of an object.
.TP
\f[B]Object.seal()\f[R]
Prevents other code from deleting properties of an object.
.TP
\f[B]Object.setPrototypeOf()\f[R]
Sets the object\[cq]s prototype (its internal \f[V][[Prototype]]\f[R]
property).
.TP
\f[B]Object.values()\f[R]
Returns an array containing the values that correspond to all of a given
object\[cq]s \f[B]own\f[R] enumerable string properties.
.SH INSTANCE PROPERTIES
.PP
These properties are defined on \f[V]Object.prototype\f[R] and shared by
all \f[V]Object\f[R] instances.
.TP
\f[B]Object.prototype.__proto__\f[R] \f[I](deprecated)\f[R]
Points to the object which was used as prototype when the object was
instantiated.
.TP
\f[B]Object.prototype.constructor\f[R]
The constructor function that created the instance object.
For plain \f[V]Object\f[R] instances, the initial value is the
\f[V]Object\f[R] constructor.
Instances of other constructors each inherit the \f[V]constructor\f[R]
property from their respective \f[V]Constructor.prototype\f[R] object.
.SH INSTANCE METHODS
.TP
\f[B]Object.prototype.__defineGetter__()\f[R] \f[I](deprecated)\f[R]
Associates a function with a property that, when accessed, executes that
function and returns its return value.
.TP
\f[B]Object.prototype.__defineSetter__()\f[R] \f[I](deprecated)\f[R]
Associates a function with a property that, when set, executes that
function which modifies the property.
.TP
\f[B]Object.prototype.__lookupGetter__()\f[R] \f[I](deprecated)\f[R]
Returns the function bound as a getter to the specified property.
.TP
\f[B]Object.prototype.__lookupSetter__()\f[R] \f[I](deprecated)\f[R]
Returns the function bound as a setter to the specified property.
.TP
\f[B]Object.prototype.hasOwnProperty()\f[R]
Returns a boolean indicating whether an object contains the specified
property as a direct property of that object and not inherited through
the prototype chain.
.TP
\f[B]Object.prototype.isPrototypeOf()\f[R]
Returns a boolean indicating whether the object this method is called
upon is in the prototype chain of the specified object.
.TP
\f[B]Object.prototype.propertyIsEnumerable()\f[R]
Returns a boolean indicating whether the specified property is the
object\[cq]s enumerable own property.
.TP
\f[B]Object.prototype.toLocaleString()\f[R]
Calls \f[V]toString()\f[R].
.TP
\f[B]Object.prototype.toString()\f[R]
Returns a string representation of the object.
.TP
\f[B]Object.prototype.valueOf()\f[R]
Returns the primitive value of the specified object.
.SH EXAMPLES
.SS Constructing empty objects
.PP
The following example creates empty objects using the \f[V]new\f[R]
keyword with different arguments:
.IP
.nf
\f[C]
const o1 = new Object();
const o2 = new Object(undefined);
const o3 = new Object(null);
\f[R]
.fi
.SS Using Object to create Boolean objects
.PP
The following examples store \f[V]Boolean\f[R] objects in \f[V]o\f[R]:
.IP
.nf
\f[C]
// equivalent to const o = new Boolean(true)
const o = new Object(true);
\f[R]
.fi
.IP
.nf
\f[C]
// equivalent to const o = new Boolean(false)
const o = new Object(Boolean());
\f[R]
.fi
.SS Object prototypes
.PP
When altering the behavior of existing \f[V]Object.prototype\f[R]
methods, consider injecting code by wrapping your extension before or
after the existing logic.
For example, this (untested) code will pre-conditionally execute custom
logic before the built-in logic or someone else\[cq]s extension is
executed.
.PP
When modifying prototypes with hooks, pass \f[V]this\f[R] and the
arguments (the call state) to the current behavior by calling
\f[V]apply()\f[R] on the function.
This pattern can be used for any prototype, such as
\f[V]Node.prototype\f[R], \f[V]Function.prototype\f[R], etc.
.IP
.nf
\f[C]
const current = Object.prototype.valueOf;

// Since my property \[dq]-prop-value\[dq] is cross-cutting and isn\[aq]t always
// on the same prototype chain, I want to modify Object.prototype:
Object.prototype.valueOf = function (...args) {
  if (Object.hasOwn(this, \[dq]-prop-value\[dq])) {
    return this[\[dq]-prop-value\[dq]];
  } else {
    // It doesn\[aq]t look like one of my objects, so let\[aq]s fall back on
    // the default behavior by reproducing the current behavior as best we can.
    // The apply behaves like \[dq]super\[dq] in some other languages.
    // Even though valueOf() doesn\[aq]t take arguments, some other hook may.
    return current.apply(this, args);
  }
};
\f[R]
.fi
.RS
.PP
\f[B]Warning:\f[R] Modifying the \f[V]prototype\f[R] property of any
built-in constructor is considered a bad practice and risks forward
compatibility.
.RE
.PP
You can read more about prototypes in Inheritance and the prototype
chain.
.SH SEE ALSO
.IP \[bu] 2
Object initializer
