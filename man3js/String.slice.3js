.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "String.slice" "JS" "June 2, 2023" "JavaScript" "JavaScript Reference Manual"
.hy
.SH NAME
.PP
String.slice - String.prototype.slice()
.SH SYNOPSIS
.PP
The \f[B]\f[VB]slice()\f[B]\f[R] method extracts a section of a string
and returns it as a new string, without modifying the original string.
.SH SYNTAX
.IP
.nf
\f[C]
slice(indexStart)
slice(indexStart, indexEnd)
\f[R]
.fi
.SS Parameters
.TP
\f[B]indexStart\f[R]
The index of the first character to include in the returned substring.
.TP
\f[B]indexEnd\f[R] \f[I](optional)\f[R]
The index of the first character to exclude from the returned substring.
.SS Return value
.PP
A new string containing the extracted section of the string.
.SH DESCRIPTION
.PP
\f[V]slice()\f[R] extracts the text from one string and returns a new
string.
Changes to the text in one string do not affect the other string.
.PP
\f[V]slice()\f[R] extracts up to but not including \f[V]indexEnd\f[R].
For example, \f[V]str.slice(1, 4)\f[R] extracts the second character
through the fourth character (characters indexed \f[V]1\f[R],
\f[V]2\f[R], and \f[V]3\f[R]).
.IP \[bu] 2
If \f[V]indexStart >= str.length\f[R], an empty string is returned.
.IP \[bu] 2
If \f[V]indexStart < 0\f[R], the index is counted from the end of the
string.
More formally, in this case, the substring starts at
\f[V]max(indexStart + str.length, 0)\f[R].
.IP \[bu] 2
If \f[V]indexStart\f[R] is omitted, undefined, or cannot be converted to
a number (using \f[V]Number(indexStart)\f[R]), it\[cq]s treated as
\f[V]0\f[R].
.IP \[bu] 2
If \f[V]indexEnd\f[R] is omitted, undefined, or cannot be converted to a
number (using \f[V]Number(indexEnd)\f[R]), or if
\f[V]indexEnd >= str.length\f[R], \f[V]slice()\f[R] extracts to the end
of the string.
.IP \[bu] 2
If \f[V]indexEnd < 0\f[R], the index is counted from the end of the
string.
More formally, in this case, the substring ends at
\f[V]max(indexEnd + str.length, 0)\f[R].
.IP \[bu] 2
If \f[V]indexEnd <= indexStart\f[R] after normalizing negative values
(i.e.\ \f[V]indexEnd\f[R] represents a character that\[cq]s before
\f[V]indexStart\f[R]), an empty string is returned.
.SH EXAMPLES
.SS Using slice() to create a new string
.PP
The following example uses \f[V]slice()\f[R] to create a new string.
.IP
.nf
\f[C]
const str1 = \[dq]The morning is upon us.\[dq]; // The length of str1 is 23.
const str2 = str1.slice(1, 8);
const str3 = str1.slice(4, -2);
const str4 = str1.slice(12);
const str5 = str1.slice(30);
console.log(str2); // he morn
console.log(str3); // morning is upon u
console.log(str4); // is upon us.
console.log(str5); // \[dq]\[dq]
\f[R]
.fi
.SS Using slice() with negative indexes
.PP
The following example uses \f[V]slice()\f[R] with negative indexes.
.IP
.nf
\f[C]
const str = \[dq]The morning is upon us.\[dq];
str.slice(-3); // \[aq]us.\[aq]
str.slice(-3, -1); // \[aq]us\[aq]
str.slice(0, -1); // \[aq]The morning is upon us\[aq]
str.slice(4, -1); // \[aq]morning is upon us\[aq]
\f[R]
.fi
.PP
This example counts backwards from the end of the string by \f[V]11\f[R]
to find the start index and forwards from the start of the string by
\f[V]16\f[R] to find the end index.
.IP
.nf
\f[C]
console.log(str.slice(-11, 16)); // \[dq]is u\[dq]
\f[R]
.fi
.PP
Here it counts forwards from the start by \f[V]11\f[R] to find the start
index and backwards from the end by \f[V]7\f[R] to find the end index.
.IP
.nf
\f[C]
console.log(str.slice(11, -7)); // \[dq] is u\[dq]
\f[R]
.fi
.PP
These arguments count backwards from the end by \f[V]5\f[R] to find the
start index and backwards from the end by \f[V]1\f[R] to find the end
index.
.IP
.nf
\f[C]
console.log(str.slice(-5, -1)); // \[dq]n us\[dq]
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
\f[V]String.prototype.substr()\f[R]
.IP \[bu] 2
\f[V]String.prototype.substring()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.slice()\f[R]
