.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "ArrayBuffer" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]ArrayBuffer\f[B]\f[R] object is used to represent a
generic raw binary data buffer.
.PP
It is an array of bytes, often referred to in other languages as a
\[lq]byte array\[rq].
You cannot directly manipulate the contents of an \f[V]ArrayBuffer\f[R];
instead, you create one of the typed array objects or a
\f[V]DataView\f[R] object which represents the buffer in a specific
format, and use that to read and write the contents of the buffer.
.PP
The \f[V]ArrayBuffer()\f[R] constructor creates a new
\f[V]ArrayBuffer\f[R] of the given length in bytes.
You can also get an array buffer from existing data, for example, from a
Base64 string or from a local file.
.PP
\f[V]ArrayBuffer\f[R] is a transferable object.
.SH Description
.SS Resizing ArrayBuffers
.PP
\f[V]ArrayBuffer\f[R] objects can be made resizable by including the
\f[V]maxByteLength\f[R] option when calling the \f[V]ArrayBuffer()\f[R]
constructor.
You can query whether an \f[V]ArrayBuffer\f[R] is resizable and what its
maximum size is by accessing its \f[V]resizable\f[R] and
\f[V]maxByteLength\f[R] properties, respectively.
You can assign a new size to a resizable \f[V]ArrayBuffer\f[R] with a
\f[V]resize()\f[R] call.
New bytes are initialized to 0.
.PP
These features make resizing \f[V]ArrayBuffer\f[R]s more efficient \[em]
otherwise, you have to make a copy of the buffer with a new size.
It also gives JavaScript parity with WebAssembly in this regard (Wasm
linear memory can be resized with
\f[V]WebAssembly.Memory.prototype.grow()\f[R]).
.SH Constructor
.IP \[bu] 2
\f[V]ArrayBuffer()\f[R]
.RS 2
.IP \[bu] 2
Creates a new \f[V]ArrayBuffer\f[R] object.
.RE
.SH Static properties
.IP \[bu] 2
\f[V]ArrayBuffer[\[at]\[at]species]\f[R]
.RS 2
.IP \[bu] 2
The constructor function that is used to create derived objects.
.RE
.SH Static methods
.IP \[bu] 2
\f[V]ArrayBuffer.isView()\f[R]
.RS 2
.IP \[bu] 2
Returns \f[V]true\f[R] if \f[V]arg\f[R] is one of the ArrayBuffer views,
such as typed array objects or a \f[V]DataView\f[R].
Returns \f[V]false\f[R] otherwise.
.RE
.SH Instance properties
.PP
These properties are defined on \f[V]ArrayBuffer.prototype\f[R] and
shared by all \f[V]ArrayBuffer\f[R] instances.
.IP \[bu] 2
\f[V]ArrayBuffer.prototype.byteLength\f[R]
.RS 2
.IP \[bu] 2
The size, in bytes, of the \f[V]ArrayBuffer\f[R].
This is established when the array is constructed and can only be
changed using the \f[V]ArrayBuffer.prototype.resize()\f[R] method if the
\f[V]ArrayBuffer\f[R] is resizable.
.RE
.IP \[bu] 2
\f[V]ArrayBuffer.prototype.constructor\f[R]
.RS 2
.IP \[bu] 2
The constructor function that created the instance object.
For \f[V]ArrayBuffer\f[R] instances, the initial value is the
\f[V]ArrayBuffer\f[R] constructor.
.RE
.IP \[bu] 2
\f[V]ArrayBuffer.prototype.maxByteLength\f[R]
.RS 2
.IP \[bu] 2
The read-only maximum length, in bytes, that the \f[V]ArrayBuffer\f[R]
can be resized to.
This is established when the array is constructed and cannot be changed.
.RE
.IP \[bu] 2
\f[V]ArrayBuffer.prototype.resizable\f[R]
.RS 2
.IP \[bu] 2
Read-only.
Returns \f[V]true\f[R] if the \f[V]ArrayBuffer\f[R] can be resized, or
\f[V]false\f[R] if not.
.RE
.IP \[bu] 2
\f[V]ArrayBuffer.prototype[\[at]\[at]toStringTag]\f[R]
.RS 2
.IP \[bu] 2
The initial value of the \f[V]\[at]\[at]toStringTag\f[R] property is the
string \f[V]\[dq]ArrayBuffer\[dq]\f[R].
This property is used in \f[V]Object.prototype.toString()\f[R].
.RE
.SH Instance methods
.IP \[bu] 2
\f[V]ArrayBuffer.prototype.resize()\f[R]
.RS 2
.IP \[bu] 2
Resizes the \f[V]ArrayBuffer\f[R] to the specified size, in bytes.
.RE
.IP \[bu] 2
\f[V]ArrayBuffer.prototype.slice()\f[R]
.RS 2
.IP \[bu] 2
Returns a new \f[V]ArrayBuffer\f[R] whose contents are a copy of this
\f[V]ArrayBuffer\f[R]\[cq]s bytes from \f[V]begin\f[R] (inclusive) up to
\f[V]end\f[R] (exclusive).
If either \f[V]begin\f[R] or \f[V]end\f[R] is negative, it refers to an
index from the end of the array, as opposed to from the beginning.
.RE
.SH Examples
.SS Creating an ArrayBuffer
.PP
In this example, we create a 8-byte buffer with a \f[V]Int32Array\f[R]
view referring to the buffer:
.IP
.nf
\f[C]
const buffer = new ArrayBuffer(8);
const view = new Int32Array(buffer);
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]ArrayBuffer\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-typed-arrays)
.IP \[bu] 2
JavaScript typed arrays
.IP \[bu] 2
\f[V]SharedArrayBuffer\f[R]
.IP \[bu] 2
RangeError: invalid array length
