.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Math.trunc" "JS" "February 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Math.trunc - Math.trunc()
.SH SYNOPSIS
The \f[B]\f[CB]Math.trunc()\f[B]\f[R] static method returns the integer
part of a number by removing any fractional digits.
.SH SYNTAX
.IP
.EX
Math.trunc(x)
.EE
.SS Parameters
.TP
\f[B]x\f[R]
A number.
.SS Return value
The integer part of \f[CR]x\f[R].
.SH DESCRIPTION
Unlike the other three \f[CR]Math\f[R] methods: \f[CR]Math.floor()\f[R],
\f[CR]Math.ceil()\f[R] and \f[CR]Math.round()\f[R], the way
\f[CR]Math.trunc()\f[R] works is very simple.
It \f[I]truncates\f[R] (cuts off) the dot and the digits to the right of
it, no matter whether the argument is a positive or negative number.
.PP
Because \f[CR]trunc()\f[R] is a static method of \f[CR]Math\f[R], you
always use it as \f[CR]Math.trunc()\f[R], rather than as a method of a
\f[CR]Math\f[R] object you created (\f[CR]Math\f[R] is not a
constructor).
.SH EXAMPLES
.SS Using Math.trunc()
.IP
.EX
Math.trunc(-Infinity); // -Infinity
Math.trunc(\[dq]-1.123\[dq]); // -1
Math.trunc(-0.123); // -0
Math.trunc(-0); // -0
Math.trunc(0); // 0
Math.trunc(0.123); // 0
Math.trunc(13.37); // 13
Math.trunc(42.84); // 42
Math.trunc(Infinity); // Infinity
.EE
.SS Using bitwise no-ops to truncate numbers
.RS
.PP
\f[B]Warning:\f[R] This is not a polyfill for \f[CR]Math.trunc()\f[R]
because of non-negligible edge cases.
.RE
.PP
Bitwise operations convert their operands to 32-bit integers, which
people have historically taken advantage of to truncate float-point
numbers.
Common techniques include:
.IP
.EX
const original = 3.14;
const truncated1 = \[ti]\[ti]original; // Double negation
const truncated2 = original & -1; // Bitwise AND with -1
const truncated3 = original | 0; // Bitwise OR with 0
const truncated4 = original \[ha] 0; // Bitwise XOR with 0
const truncated5 = original >> 0; // Bitwise shifting by 0
.EE
.PP
Beware that this is essentially \f[CR]toInt32\f[R], which is not the
same as \f[CR]Math.trunc\f[R].
When the value does not satisfy -231 - 1 < \f[CR]value\f[R] < 231
(-2147483649 < \f[CR]value\f[R] < 2147483648), the conversion would
overflow.
.IP
.EX
const a = \[ti]\[ti]2147483648; // -2147483648
const b = \[ti]\[ti]-2147483649; // 2147483647
const c = \[ti]\[ti]4294967296; // 0
.EE
.PP
Only use \f[CR]\[ti]\[ti]\f[R] as a substitution for
\f[CR]Math.trunc()\f[R] when you are confident that the range of input
falls within the range of 32-bit integers.
.SH SEE ALSO
.IP \[bu] 2
Polyfill of \f[CR]Math.trunc\f[R] in
\f[CR]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-math)
.IP \[bu] 2
\f[CR]Math.abs()\f[R]
.IP \[bu] 2
\f[CR]Math.ceil()\f[R]
.IP \[bu] 2
\f[CR]Math.floor()\f[R]
.IP \[bu] 2
\f[CR]Math.round()\f[R]
.IP \[bu] 2
\f[CR]Math.sign()\f[R]
