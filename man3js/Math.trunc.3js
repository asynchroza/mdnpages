.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Math.trunc" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]Math.trunc()\f[B]\f[R] static method returns the integer
part of a number by removing any fractional digits.
.SH Syntax
.IP
.nf
\f[C]
Math.trunc(x)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]x\f[R]
.RS 2
.IP \[bu] 2
A number.
.RE
.SS Return value
.PP
The integer part of \f[V]x\f[R].
.SH Description
.PP
Unlike the other three \f[V]Math\f[R] methods: \f[V]Math.floor()\f[R],
\f[V]Math.ceil()\f[R] and \f[V]Math.round()\f[R], the way
\f[V]Math.trunc()\f[R] works is very simple.
It \f[I]truncates\f[R] (cuts off) the dot and the digits to the right of
it, no matter whether the argument is a positive or negative number.
.PP
Because \f[V]trunc()\f[R] is a static method of \f[V]Math\f[R], you
always use it as \f[V]Math.trunc()\f[R], rather than as a method of a
\f[V]Math\f[R] object you created (\f[V]Math\f[R] is not a constructor).
.SH Examples
.SS Using Math.trunc()
.IP
.nf
\f[C]
Math.trunc(-Infinity); // -Infinity
Math.trunc(\[dq]-1.123\[dq]); // -1
Math.trunc(-0.123); // -0
Math.trunc(-0); // -0
Math.trunc(0); // 0
Math.trunc(0.123); // 0
Math.trunc(13.37); // 13
Math.trunc(42.84); // 42
Math.trunc(Infinity); // Infinity
\f[R]
.fi
.SS Using bitwise no-ops to truncate numbers
.RS
.PP
\f[B]Warning:\f[R] This is not a polyfill for \f[V]Math.trunc()\f[R]
because of non-negligible edge cases.
.RE
.PP
Bitwise operations convert their operands to 32-bit integers, which
people have historically taken advantage of to truncate float-point
numbers.
Common techniques include:
.IP
.nf
\f[C]
const original = 3.14;
const truncated1 = \[ti]\[ti]original; // Double negation
const truncated2 = original & -1; // Bitwise AND with -1
const truncated3 = original | 0; // Bitwise OR with 0
const truncated4 = original \[ha] 0; // Bitwise XOR with 0
const truncated5 = original >> 0; // Bitwise shifting by 0
\f[R]
.fi
.PP
Beware that this is essentially \f[V]toInt32\f[R], which is not the same
as \f[V]Math.trunc\f[R].
When the value does not satisfy -231 - 1 < \f[V]value\f[R] < 231
(-2147483649 < \f[V]value\f[R] < 2147483648), the conversion would
overflow.
.IP
.nf
\f[C]
const a = \[ti]\[ti]2147483648; // -2147483648
const b = \[ti]\[ti]-2147483649; // 2147483647
const c = \[ti]\[ti]4294967296; // 0
\f[R]
.fi
.PP
Only use \f[V]\[ti]\[ti]\f[R] as a substitution for
\f[V]Math.trunc()\f[R] when you are confident that the range of input
falls within the range of 32-bit integers.
.SH See also
.IP \[bu] 2
Polyfill of \f[V]Math.trunc\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-math)
.IP \[bu] 2
\f[V]Math.abs()\f[R]
.IP \[bu] 2
\f[V]Math.ceil()\f[R]
.IP \[bu] 2
\f[V]Math.floor()\f[R]
.IP \[bu] 2
\f[V]Math.round()\f[R]
.IP \[bu] 2
\f[V]Math.sign()\f[R]
