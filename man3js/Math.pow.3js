.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Math.pow" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]Math.pow()\f[B]\f[R] static method returns the value of a
base raised to a power.
That is
.PP
𝙼𝚊𝚝𝚑.𝚙𝚘𝚠(𝚡,𝚢)=xy = x\[ha]y
.SH Syntax
.IP
.nf
\f[C]
Math.pow(base, exponent)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]base\f[R]
.RS 2
.IP \[bu] 2
The base number.
.RE
.IP \[bu] 2
\f[V]exponent\f[R]
.RS 2
.IP \[bu] 2
The exponent number.
.RE
.SS Return value
.PP
A number representing \f[V]base\f[R] taken to the power of
\f[V]exponent\f[R].
Returns \f[V]NaN\f[R] in one of the following cases:
.IP \[bu] 2
\f[V]exponent\f[R] is \f[V]NaN\f[R].
.IP \[bu] 2
\f[V]base\f[R] is \f[V]NaN\f[R] and \f[V]exponent\f[R] is not
\f[V]0\f[R].
.IP \[bu] 2
\f[V]base\f[R] is ±1 and \f[V]exponent\f[R] is ±\f[V]Infinity\f[R].
.IP \[bu] 2
\f[V]base < 0\f[R] and \f[V]exponent\f[R] is not an integer.
.SH Description
.PP
\f[V]Math.pow()\f[R] is equivalent to the \f[V]**\f[R] operator, except
\f[V]Math.pow()\f[R] only accepts numbers.
.PP
\f[V]Math.pow(NaN, 0)\f[R] (and the equivalent \f[V]NaN ** 0\f[R]) is
the only case where \f[V]NaN\f[R] doesn\[cq]t propagate through
mathematical operations \[em] it returns \f[V]1\f[R] despite the operand
being \f[V]NaN\f[R].
In addition, the behavior where \f[V]base\f[R] is 1 and
\f[V]exponent\f[R] is non-finite (±Infinity or \f[V]NaN\f[R]) is
different from IEEE 754, which specifies that the result should be 1,
whereas JavaScript returns \f[V]NaN\f[R] to preserve backward
compatibility with its original behavior.
.PP
Because \f[V]pow()\f[R] is a static method of \f[V]Math\f[R], use it as
\f[V]Math.pow()\f[R], rather than as a method of a \f[V]Math\f[R] object
you created (\f[V]Math\f[R] is not a constructor).
.SH Examples
.SS Using Math.pow()
.IP
.nf
\f[C]
// Simple cases
Math.pow(7, 2); // 49
Math.pow(7, 3); // 343
Math.pow(2, 10); // 1024

// Fractional exponents
Math.pow(4, 0.5); // 2 (square root of 4)
Math.pow(8, 1 / 3); // 2 (cube root of 8)
Math.pow(2, 0.5); // 1.4142135623730951 (square root of 2)
Math.pow(2, 1 / 3); // 1.2599210498948732 (cube root of 2)

// Signed exponents
Math.pow(7, -2); // 0.02040816326530612 (1/49)
Math.pow(8, -1 / 3); // 0.5

// Signed bases
Math.pow(-7, 2); // 49 (squares are positive)
Math.pow(-7, 3); // -343 (cubes can be negative)
Math.pow(-7, 0.5); // NaN (negative numbers don\[aq]t have a real square root)
// Due to \[dq]even\[dq] and \[dq]odd\[dq] roots laying close to each other,
// and limits in the floating number precision,
// negative bases with fractional exponents always return NaN,
// even when the mathematical result is real
Math.pow(-7, 1 / 3); // NaN

// Zero and infinity
Math.pow(0, 0); // 1 (anything ** ±0 is 1)
Math.pow(Infinity, 0.1); // Infinity (positive exponent)
Math.pow(Infinity, -1); // 0 (negative exponent)
Math.pow(-Infinity, 1); // -Infinity (positive odd integer exponent)
Math.pow(-Infinity, 1.5); // Infinity (positive exponent)
Math.pow(-Infinity, -1); // -0 (negative odd integer exponent)
Math.pow(-Infinity, -1.5); // 0 (negative exponent)
Math.pow(0, 1); // 0 (positive exponent)
Math.pow(0, -1); // Infinity (negative exponent)
Math.pow(-0, 1); // -0 (positive odd integer exponent)
Math.pow(-0, 1.5); // 0 (positive exponent)
Math.pow(-0, -1); // -Infinity (negative odd integer exponent)
Math.pow(-0, -1.5); // Infinity (negative exponent)
Math.pow(0.9, Infinity); // 0
Math.pow(1, Infinity); // NaN
Math.pow(1.1, Infinity); // Infinity
Math.pow(0.9, -Infinity); // Infinity
Math.pow(1, -Infinity); // NaN
Math.pow(1.1, -Infinity); // 0

// NaN: only Math.pow(NaN, 0) does not result in NaN
Math.pow(NaN, 0); // 1
Math.pow(NaN, 1); // NaN
Math.pow(1, NaN); // NaN
\f[R]
.fi
.SH See also
.IP \[bu] 2
\f[V]Math.cbrt()\f[R]
.IP \[bu] 2
\f[V]Math.exp()\f[R]
.IP \[bu] 2
\f[V]Math.log()\f[R]
.IP \[bu] 2
\f[V]Math.sqrt()\f[R]
.IP \[bu] 2
Exponentiation operator
