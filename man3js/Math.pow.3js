.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "Math.pow" "JS" "February 21, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
Math.pow - Math.pow()
.SH SYNOPSIS
The \f[B]\f[CB]Math.pow()\f[B]\f[R] static method returns the value of a
base raised to a power.
That is
.PP
𝙼𝚊𝚝𝚑.𝚙𝚘𝚠(𝚡,𝚢)=xy = x\[ha]y
.SH SYNTAX
.IP
.EX
Math.pow(base, exponent)
.EE
.SS Parameters
.TP
\f[B]base\f[R]
The base number.
.TP
\f[B]exponent\f[R]
The exponent number.
.SS Return value
A number representing \f[CR]base\f[R] taken to the power of
\f[CR]exponent\f[R].
Returns \f[CR]NaN\f[R] in one of the following cases:
.IP \[bu] 2
\f[CR]exponent\f[R] is \f[CR]NaN\f[R].
.IP \[bu] 2
\f[CR]base\f[R] is \f[CR]NaN\f[R] and \f[CR]exponent\f[R] is not
\f[CR]0\f[R].
.IP \[bu] 2
\f[CR]base\f[R] is ±1 and \f[CR]exponent\f[R] is ±\f[CR]Infinity\f[R].
.IP \[bu] 2
\f[CR]base < 0\f[R] and \f[CR]exponent\f[R] is not an integer.
.SH DESCRIPTION
\f[CR]Math.pow()\f[R] is equivalent to the \f[CR]**\f[R] operator,
except \f[CR]Math.pow()\f[R] only accepts numbers.
.PP
\f[CR]Math.pow(NaN, 0)\f[R] (and the equivalent \f[CR]NaN ** 0\f[R]) is
the only case where \f[CR]NaN\f[R] doesn\[cq]t propagate through
mathematical operations \[em] it returns \f[CR]1\f[R] despite the
operand being \f[CR]NaN\f[R].
In addition, the behavior where \f[CR]base\f[R] is 1 and
\f[CR]exponent\f[R] is non-finite (±Infinity or \f[CR]NaN\f[R]) is
different from IEEE 754, which specifies that the result should be 1,
whereas JavaScript returns \f[CR]NaN\f[R] to preserve backward
compatibility with its original behavior.
.PP
Because \f[CR]pow()\f[R] is a static method of \f[CR]Math\f[R], use it
as \f[CR]Math.pow()\f[R], rather than as a method of a \f[CR]Math\f[R]
object you created (\f[CR]Math\f[R] is not a constructor).
.SH EXAMPLES
.SS Using Math.pow()
.IP
.EX
// Simple cases
Math.pow(7, 2); // 49
Math.pow(7, 3); // 343
Math.pow(2, 10); // 1024

// Fractional exponents
Math.pow(4, 0.5); // 2 (square root of 4)
Math.pow(8, 1 / 3); // 2 (cube root of 8)
Math.pow(2, 0.5); // 1.4142135623730951 (square root of 2)
Math.pow(2, 1 / 3); // 1.2599210498948732 (cube root of 2)

// Signed exponents
Math.pow(7, -2); // 0.02040816326530612 (1/49)
Math.pow(8, -1 / 3); // 0.5

// Signed bases
Math.pow(-7, 2); // 49 (squares are positive)
Math.pow(-7, 3); // -343 (cubes can be negative)
Math.pow(-7, 0.5); // NaN (negative numbers don\[aq]t have a real square root)
// Due to \[dq]even\[dq] and \[dq]odd\[dq] roots laying close to each other,
// and limits in the floating number precision,
// negative bases with fractional exponents always return NaN,
// even when the mathematical result is real
Math.pow(-7, 1 / 3); // NaN

// Zero and infinity
Math.pow(0, 0); // 1 (anything ** ±0 is 1)
Math.pow(Infinity, 0.1); // Infinity (positive exponent)
Math.pow(Infinity, -1); // 0 (negative exponent)
Math.pow(-Infinity, 1); // -Infinity (positive odd integer exponent)
Math.pow(-Infinity, 1.5); // Infinity (positive exponent)
Math.pow(-Infinity, -1); // -0 (negative odd integer exponent)
Math.pow(-Infinity, -1.5); // 0 (negative exponent)
Math.pow(0, 1); // 0 (positive exponent)
Math.pow(0, -1); // Infinity (negative exponent)
Math.pow(-0, 1); // -0 (positive odd integer exponent)
Math.pow(-0, 1.5); // 0 (positive exponent)
Math.pow(-0, -1); // -Infinity (negative odd integer exponent)
Math.pow(-0, -1.5); // Infinity (negative exponent)
Math.pow(0.9, Infinity); // 0
Math.pow(1, Infinity); // NaN
Math.pow(1.1, Infinity); // Infinity
Math.pow(0.9, -Infinity); // Infinity
Math.pow(1, -Infinity); // NaN
Math.pow(1.1, -Infinity); // 0

// NaN: only Math.pow(NaN, 0) does not result in NaN
Math.pow(NaN, 0); // 1
Math.pow(NaN, 1); // NaN
Math.pow(1, NaN); // NaN
.EE
.SH SEE ALSO
.IP \[bu] 2
\f[CR]Math.cbrt()\f[R]
.IP \[bu] 2
\f[CR]Math.exp()\f[R]
.IP \[bu] 2
\f[CR]Math.log()\f[R]
.IP \[bu] 2
\f[CR]Math.sqrt()\f[R]
.IP \[bu] 2
Exponentiation operator
