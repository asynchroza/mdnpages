.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.indexOf" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]indexOf()\f[B]\f[R] method returns the first index at
which a given element can be found in the array, or -1 if it is not
present.
.SH Syntax
.IP
.nf
\f[C]
indexOf(searchElement)
indexOf(searchElement, fromIndex)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]searchElement\f[R]
.RS 2
.IP \[bu] 2
Element to locate in the array.
.RE
.IP \[bu] 2
\f[V]fromIndex\f[R] \f[I](optional)\f[R]
.RS 2
.IP \[bu] 2
Zero-based index at which to start searching, converted to an integer.
.RS 2
.IP \[bu] 2
Negative index counts back from the end of the array \[em] if
\f[V]fromIndex < 0\f[R], \f[V]fromIndex + array.length\f[R] is used.
Note, the array is still searched from front to back in this case.
.IP \[bu] 2
If \f[V]fromIndex < -array.length\f[R] or \f[V]fromIndex\f[R] is
omitted, \f[V]0\f[R] is used, causing the entire array to be searched.
.IP \[bu] 2
If \f[V]fromIndex >= array.length\f[R], the array is not searched and
\f[V]-1\f[R] is returned.
.RE
.RE
.SS Return value
.PP
The first index of the element in the array; \f[B]-1\f[R] if not found.
.SH Description
.PP
The \f[V]indexOf()\f[R] method compares \f[V]searchElement\f[R] to
elements of the array using strict equality (the same algorithm used by
the \f[V]===\f[R] operator).
\f[V]NaN\f[R] values are never compared as equal, so \f[V]indexOf()\f[R]
always returns \f[V]-1\f[R] when \f[V]searchElement\f[R] is
\f[V]NaN\f[R].
.PP
The \f[V]indexOf()\f[R] method skips empty slots in sparse arrays.
.PP
The \f[V]indexOf()\f[R] method is generic.
It only expects the \f[V]this\f[R] value to have a \f[V]length\f[R]
property and integer-keyed properties.
.SH Examples
.SS Using indexOf()
.PP
The following example uses \f[V]indexOf()\f[R] to locate values in an
array.
.IP
.nf
\f[C]
const array = [2, 9, 9];
array.indexOf(2); // 0
array.indexOf(7); // -1
array.indexOf(9, 2); // 2
array.indexOf(2, -1); // -1
array.indexOf(2, -3); // 0
\f[R]
.fi
.PP
You cannot use \f[V]indexOf()\f[R] to search for \f[V]NaN\f[R].
.IP
.nf
\f[C]
const array = [NaN];
array.indexOf(NaN); // -1
\f[R]
.fi
.SS Finding all the occurrences of an element
.IP
.nf
\f[C]
const indices = [];
const array = [\[dq]a\[dq], \[dq]b\[dq], \[dq]a\[dq], \[dq]c\[dq], \[dq]a\[dq], \[dq]d\[dq]];
const element = \[dq]a\[dq];
let idx = array.indexOf(element);
while (idx !== -1) {
  indices.push(idx);
  idx = array.indexOf(element, idx + 1);
}
console.log(indices);
// [0, 2, 4]
\f[R]
.fi
.SS Finding if an element exists in the array or not and updating the array
.IP
.nf
\f[C]
function updateVegetablesCollection(veggies, veggie) {
  if (veggies.indexOf(veggie) === -1) {
    veggies.push(veggie);
    console.log(\[ga]New veggies collection is: ${veggies}\[ga]);
  } else {
    console.log(\[ga]${veggie} already exists in the veggies collection.\[ga]);
  }
}

const veggies = [\[dq]potato\[dq], \[dq]tomato\[dq], \[dq]chillies\[dq], \[dq]green-pepper\[dq]];

updateVegetablesCollection(veggies, \[dq]spinach\[dq]);
// New veggies collection is: potato,tomato,chillies,green-pepper,spinach
updateVegetablesCollection(veggies, \[dq]spinach\[dq]);
// spinach already exists in the veggies collection.
\f[R]
.fi
.SS Using indexOf() on sparse arrays
.PP
You cannot use \f[V]indexOf()\f[R] to search for empty slots in sparse
arrays.
.IP
.nf
\f[C]
console.log([1, , 3].indexOf(undefined)); // -1
\f[R]
.fi
.SS Calling indexOf() on non-array objects
.PP
The \f[V]indexOf()\f[R] method reads the \f[V]length\f[R] property of
\f[V]this\f[R] and then accesses each integer index.
.IP
.nf
\f[C]
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.indexOf.call(arrayLike, 2));
// 0
console.log(Array.prototype.indexOf.call(arrayLike, 5));
// -1
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]Array.prototype.indexOf\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-array)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[V]Array\f[R]
.IP \[bu] 2
\f[V]Array.prototype.findIndex()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.findLastIndex()\f[R]
.IP \[bu] 2
\f[V]Array.prototype.lastIndexOf()\f[R]
.IP \[bu] 2
\f[V]TypedArray.prototype.indexOf()\f[R]
.IP \[bu] 2
\f[V]String.prototype.indexOf()\f[R]
