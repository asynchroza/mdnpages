.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "NavigationPreloadManager" "JS" "July 7, 2023" "JavaScript" "JavaScript Reference Manual"
.SH NAME
NavigationPreloadManager \- NavigationPreloadManager
.SH SYNOPSIS
The \f[B]\f[CB]NavigationPreloadManager\f[B]\f[R] interface of the
Service Worker API provides methods for managing the preloading of
resources in parallel with service worker bootup.
.PP
If supported, an object of this type is returned by
\f[CR]ServiceWorkerRegistration.navigationPreload\f[R].
The result of a preload fetch request is waited on using the promise
returned by \f[CR]FetchEvent.preloadResponse\f[R].
.SH INSTANCE METHODS
.TP
\f[B]NavigationPreloadManager.enable()\f[R]
Enables navigation preloading, returning a \f[CR]Promise\f[R] that
resolves with \f[CR]undefined\f[R].
.TP
\f[B]NavigationPreloadManager.disable()\f[R]
Disables navigation preloading, returning a \f[CR]Promise\f[R] that
resolves with \f[CR]undefined\f[R].
.TP
\f[B]NavigationPreloadManager.setHeaderValue()\f[R]
Sets the value of the \f[CR]Service\-Worker\-Navigation\-Preload\f[R]
HTTP header sent in preloading requests and returns an empty
\f[CR]Promise\f[R].
.TP
\f[B]NavigationPreloadManager.getState()\f[R]
Returns a \f[CR]Promise\f[R] that resolves to an object with properties
that indicate whether preloading is enabled, and what value will be sent
in the \f[CR]Service\-Worker\-Navigation\-Preload\f[R] HTTP header in
preloading requests.
.SH DESCRIPTION
Service workers handle \f[CR]fetch()\f[R] events on behalf of a site,
for pages within a given scope.
When a user navigates to a page that uses a service worker, the browser
boots up the worker (if it isn\[cq]t already running), then sends it a
fetch event and waits for the result.
On receiving an event, the worker returns the resource from a cache if
it is present, or otherwise fetches the resource from the remote server
(storing a copy for returning in future requests).
.PP
A service worker cannot process events from the browser until it has
booted.
This is unavoidable, but usually doesn\[cq]t have much impact.
Service workers are often already started (they remain active for some
time after processing other requests).
Even if a service worker does have to boot, much of the time it may be
returning values from a cache, which is very fast.
However, in those cases where a worker has to boot before it can start
fetching a remote resource, then the delay can be significant.
.PP
The \f[CR]NavigationPreloadManager\f[R] provides a mechanism to allow
fetching of the resources to run in parallel with service worker boot,
so that by the time the worker is able to handle the fetch request from
the browser, the resource may already have been fully or partially
downloaded.
This makes the case where the worker has to start up \[lq]no worse\[rq]
than when the worker is already started, and in some cases better.
.PP
The preload manager sends the
\f[CR]Service\-Worker\-Navigation\-Preload\f[R] HTTP header with preload
requests, allowing responses to be customized for preload requests.
This might be used, for example, to reduce the data sent to just part of
the original page, or to customize the response based on the user\[cq]s
log\-in state.
.SH EXAMPLES
The examples here are from \c
.UR https://developer.chrome.com/blog/navigation-preload/
Speed up Service Worker with Navigation Preloads
.UE \c
\ (developer.chrome.com).
.SS Feature detection and enabling navigation preloading
Below we enable navigation preloading in the service worker\[cq]s
\f[CR]activate\f[R] event handler, after first using
\f[CR]ServiceWorkerRegistration.navigationPreload\f[R] to determine if
the feature is supported (this returns either the
\f[CR]NavigationPreloadManager\f[R] for the service worker or
\f[CR]undefined\f[R] if the feature is not supported).
.IP
.EX
addEventListener(\[dq]activate\[dq], (event) => {
  event.waitUntil(
    (async () => {
      if (self.registration.navigationPreload) {
        // Enable navigation preloads!
        await self.registration.navigationPreload.enable();
      }
    })(),
  );
});
.EE
.SS Using a preloaded response
The following code shows a service worker fetch event handler that uses
a preloaded response (\f[CR]FetchEvent.preloadResponse\f[R]).
.PP
The \f[CR]fetch\f[R] event handler calls
\f[CR]FetchEvent.respondWith()\f[R] to pass a promise back to the
controlled page.
This promise will resolve with the requested resource, which may be from
the cache, a preloaded fetch request, or a new network request.
.PP
If there is a matching URL request in the \f[CR]Cache\f[R] object, then
the code returns a resolved promise for fetching the response from the
cache.
If no match is found in the cache, the code returns the resolved
preloaded response (\f[CR]FetchEvent.preloadResponse\f[R]).
If there is no matching cache entry or preloaded response, the code
starts a new fetch operation from the network and returns the
(unresolved) promise for that fetch operation.
.IP
.EX
addEventListener(\[dq]fetch\[dq], (event) => {
  event.respondWith(
    (async () => {
      // Respond from the cache if we can
      const cachedResponse = await caches.match(event.request);
      if (cachedResponse) return cachedResponse;

      // Else, use the preloaded response, if it\[aq]s there
      const response = await event.preloadResponse;
      if (response) return response;

      // Else try the network.
      return fetch(event.request);
    })(),
  );
});
.EE
.SS Custom responses
The browser sends the HTTP header
\f[CR]Service\-Worker\-Navigation\-Preload\f[R] with preload requests,
with a default directive value of \f[CR]true\f[R].
This allows servers to differentiate between normal and preload fetch
requests, and to send different responses in each case if required.
.RS
.PP
\f[B]Note:\f[R] If the response from preload and normal fetch operations
can be different, then the server must set
\f[CR]Vary: Service\-Worker\-Navigation\-Preload\f[R] to ensure that the
different responses are cached.
.RE
.PP
The header value can be changed to any other string value using
\f[CR]NavigationPreloadManager.setHeaderValue()\f[R] in order to provide
additional context for the prefetch operation.
For example, you might set the value to the ID of your most recently
cached resource, so that the server won\[cq]t return any resources
unless they are actually needed.
Similarly, you could configure the returned information based on
authentication status instead of using cookies.
.PP
The code below shows how to set the value of the header directive to
some variable \f[CR]newValue\f[R].
.IP
.EX
navigator.serviceWorker.ready
  .then((registration) =>
    registration.navigationPreload.setHeaderValue(newValue),
  )
  .then(() => {
    console.log(\[dq]Done!\[dq]);
  });
.EE
.PP
\c
.UR https://developer.chrome.com/blog/navigation-preload/
Speed up Service Worker with Navigation Preloads > Custom responses for
preloads
.UE \c
\ provides a more complete example of a site where the response for an
article web page is constructed from a cached header and footer, so that
only the article content is returned for a prefetch.
.SS Getting the state
You can use \f[CR]NavigationPreloadManager.getState()\f[R] to check
whether navigation preloading is enabled and to determine what directive
value is sent with the \f[CR]Service\-Worker\-Navigation\-Preload\f[R]
HTTP header for preload requests.
.PP
The code below shows how to get the promise that resolves to a
\f[CR]state\f[R] object and log the result.
.IP
.EX
navigator.serviceWorker.ready
  .then((registration) => registration.navigationPreload.getState())
  .then((state) => {
    console.log(state.enabled); // boolean
    console.log(state.headerValue); // string
  });
.EE
.SH SEE ALSO
.IP \[bu] 2
\c
.UR https://developer.chrome.com/blog/navigation-preload/
Speed up Service Worker with Navigation Preloads
.UE \c
\ (developer.chrome.com)
