.\" Automatically generated by Pandoc 3.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Array.isArray" "JS" "2023-06-02" "JavaScript" "JavaScript Reference Manual"
.hy
.SH Synopsis
.PP
The \f[B]\f[VB]Array.isArray()\f[B]\f[R] static method determines
whether the passed value is an \f[V]Array\f[R].
.SH Syntax
.IP
.nf
\f[C]
Array.isArray(value)
\f[R]
.fi
.SS Parameters
.IP \[bu] 2
\f[V]value\f[R]
.RS 2
.IP \[bu] 2
The value to be checked.
.RE
.SS Return value
.PP
\f[V]true\f[R] if \f[V]value\f[R] is an \f[V]Array\f[R]; otherwise,
\f[V]false\f[R].
\f[V]false\f[R] is always returned if \f[V]value\f[R] is a
\f[V]TypedArray\f[R] instance.
.SH Description
.PP
\f[V]Array.isArray()\f[R] checks if the passed value is an
\f[V]Array\f[R].
It does not check the value\[cq]s prototype chain, nor does it rely on
the \f[V]Array\f[R] constructor it is attached to.
It returns \f[V]true\f[R] for any value that was created using the array
literal syntax or the \f[V]Array\f[R] constructor.
This makes it safe to use with cross-realm objects, where the identity
of the \f[V]Array\f[R] constructor is different and would therefore
cause \f[V]instanceof Array\f[R] to fail.
.PP
See the article \[lq]Determining with absolute accuracy whether or not a
JavaScript object is an
array\[rq] (https://web.mit.edu/jwalden/www/isArray.html) for more
details.
.PP
\f[V]Array.isArray()\f[R] also rejects objects with
\f[V]Array.prototype\f[R] in its prototype chain but aren\[cq]t actual
arrays, which \f[V]instanceof Array\f[R] would accept.
.SH Examples
.SS Using Array.isArray()
.IP
.nf
\f[C]
// all following calls return true
Array.isArray([]);
Array.isArray([1]);
Array.isArray(new Array());
Array.isArray(new Array(\[dq]a\[dq], \[dq]b\[dq], \[dq]c\[dq], \[dq]d\[dq]));
Array.isArray(new Array(3));
// Little known fact: Array.prototype itself is an array:
Array.isArray(Array.prototype);

// all following calls return false
Array.isArray();
Array.isArray({});
Array.isArray(null);
Array.isArray(undefined);
Array.isArray(17);
Array.isArray(\[dq]Array\[dq]);
Array.isArray(true);
Array.isArray(false);
Array.isArray(new Uint8Array(32));
// This is not an array, because it was not created using the
// array literal syntax or the Array constructor
Array.isArray({ __proto__: Array.prototype });
\f[R]
.fi
.SS instanceof vs.\ Array.isArray()
.PP
When checking for \f[V]Array\f[R] instance, \f[V]Array.isArray()\f[R] is
preferred over \f[V]instanceof\f[R] because it works across realms.
.IP
.nf
\f[C]
const iframe = document.createElement(\[dq]iframe\[dq]);
document.body.appendChild(iframe);
const xArray = window.frames[window.frames.length - 1].Array;
const arr = new xArray(1, 2, 3); // [1, 2, 3]

// Correctly checking for Array
Array.isArray(arr); // true
// The prototype of arr is xArray.prototype, which is a
// different object from Array.prototype
arr instanceof Array; // false
\f[R]
.fi
.SH See also
.IP \[bu] 2
Polyfill of \f[V]Array.isArray\f[R] in
\f[V]core-js\f[R] (https://github.com/zloirock/core-js#ecmascript-array)
.IP \[bu] 2
Indexed collections
.IP \[bu] 2
\f[V]Array\f[R]
